*** misc/mozilla/build/autoconf/mozconfig-find	Fri Jul 16 14:13:24 2004
--- misc/build/mozilla/build/autoconf/mozconfig-find	Thu Mar 29 14:27:08 2007
***************
*** 51,60 ****
                 $topsrcdir/.mozconfig \
                 $topsrcdir/mozconfig \
                 $topsrcdir/mozconfig.sh \
!                $topsrcdir/myconfig.sh \
!                $HOME/.mozconfig \
!                $HOME/.mozconfig.sh \
!                $HOME/.mozmyconfig.sh
  do
    if test -f $_config; then
      echo $_config;
--- 51,57 ----
                 $topsrcdir/.mozconfig \
                 $topsrcdir/mozconfig \
                 $topsrcdir/mozconfig.sh \
!                $topsrcdir/myconfig.sh
  do
    if test -f $_config; then
      echo $_config;
*** misc/mozilla/build/cygwin-wrapper	Thu Oct 30 17:05:56 2003
--- misc/build/mozilla/build/cygwin-wrapper	Thu Mar 29 14:27:08 2007
***************
*** 1,4 ****
! #!/bin/sh
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
--- 1,4 ----
! #!/bin/bash
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
***************
*** 48,59 ****
                          i=-I${mountpoint}/${driveletter}/${pathname}
                      fi
                  else
!                     eval 'leader=${i%%'${mountpoint}'/[a-zA-Z]/*}'
!                     if ! test "${leader}" = "${i}"; then
!                         eval 'pathname=${i#'${leader}${mountpoint}'/[a-zA-Z]/}'
!                         eval 'no_mountpoint=${i#'${leader}${mountpoint}'/}'
!                         driveletter=${no_mountpoint%%/*}
!                         i=${leader}${driveletter}:/${pathname}
                      fi
                  fi
              fi
--- 48,83 ----
                          i=-I${mountpoint}/${driveletter}/${pathname}
                      fi
                  else
!       # The original version missed mounted paths, the new version below
!       # doesn't transform /para as this is most likely a parameter.
!       eval 'notinpath=${i%%'${mountpoint}'/[a-zA-Z]/*}'
!       if ! test "$notinpath" = "$i"; then
!          # found  $mountpoint
!          eval 'restpath=${i#'${notinpath}${mountpoint}'/[a-zA-Z]/}'
!          eval 'withdrive=${i#'${notinpath}${mountpoint}'/}'
!          driveletter=${withdrive%%/*}
!          i=${notinpath}${driveletter}:/${restpath}
!       else
!          # check for potential path. Precheck using shell methods
!          doconvert=""
!          # Shortcut -X<path> when path does not begin with '/'
!          noswitch=${i#-[a-zA-Z]}
!          if test "$noswitch" != "$i"; then
!             test "${noswitch#/}" != "$noswitch" && doconvert="1"
!          fi
!          # Precheck for possible path. Consider only absolute paths that contain at least
!          # a second / to prevent converting of /abc parameters.
!          test -z "$doconvert" -a "${i#/[a-zA-Z0-9_.-]*/}" != "$i" && doconvert="1"
!          if test -n "$doconvert"; then
!             # Can be a path. If forking grep would be faster or we could require bash 3
!             # this regexp would be all that's needed to find pathnames that need converting
!             pathname=`echo $i | grep -oE '^(-[a-zA-Z])?/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_./-]+$'`
!             eval 'notinpath=${i%'${pathname}'}'
!             if test "$notinpath" != "$i" -a "$pathname" != "${pathname#/}"; then
!                pathname=`cygpath -am "$pathname"`
!                i=${notinpath}${pathname}
!             fi
!          fi
                      fi
                  fi
              fi
*** misc/mozilla/calendar/Makefile.in	Sat Apr 10 10:27:46 2004
--- misc/build/mozilla/calendar/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 106,112 ****
  	mkdir -p ./xpi/bin/chrome
  	mkdir -p ./xpi/resources
  	cp $(DEPTH)/dist/bin/chrome/calendar.jar ./xpi/bin/chrome
! 	cp libxpical/$(LIB_PREFIX)xpical$(DLL_SUFFIX) ./xpi/bin/components
  	cp libxpical/_xpidlgen/calendar.xpt ./xpi/bin/components
  	cp $(srcdir)/resources/content/calendarService.js ./xpi/bin/components
  	cp -r $(srcdir)/resources/locale ./xpi/resources
--- 106,112 ----
  	mkdir -p ./xpi/bin/chrome
  	mkdir -p ./xpi/resources
  	cp $(DEPTH)/dist/bin/chrome/calendar.jar ./xpi/bin/chrome
! 	cp libxpical/$(DLL_PREFIX)xpical$(DLL_SUFFIX) ./xpi/bin/components
  	cp libxpical/_xpidlgen/calendar.xpt ./xpi/bin/components
  	cp $(srcdir)/resources/content/calendarService.js ./xpi/bin/components
  	cp -r $(srcdir)/resources/locale ./xpi/resources
*** misc/mozilla/calendar/sunbird/Makefile.in	Wed Apr  7 15:18:59 2004
--- misc/build/mozilla/calendar/sunbird/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 71,87 ****
  sunbird::sunbirddirs sunbirdunix
  endif
  	cp $(topsrcdir)/dist/bin/MozillaSunbird* ./MozillaSunbird
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)plc4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)ssl3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)xpcom$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)nss3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)smime3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)xpistub$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)nspr4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)nssckbi$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)plds4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)softokn3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)xpcom_compat$(DLL_SUFFIX) ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/mangle ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/shlibsign ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/xpicleanup ./MozillaSunbird/
--- 71,87 ----
  sunbird::sunbirddirs sunbirdunix
  endif
  	cp $(topsrcdir)/dist/bin/MozillaSunbird* ./MozillaSunbird
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)plc4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)ssl3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)xpcom$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)nss3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)smime3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)xpistub$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)nspr4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)nssckbi$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)plds4$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)softokn3$(DLL_SUFFIX) ./MozillaSunbird/
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)xpcom_compat$(DLL_SUFFIX) ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/mangle ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/shlibsign ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/xpicleanup ./MozillaSunbird/
***************
*** 185,191 ****
  	cp $(topsrcdir)/dist/bin/components/intl.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/lwbrk.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/chardet.xpt ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/components/$(LIB_PREFIX)jar50$(DLL_SUFFIX) ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/jar.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/oji.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/jsdservice.xpt ./MozillaSunbird/components
--- 185,191 ----
  	cp $(topsrcdir)/dist/bin/components/intl.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/lwbrk.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/chardet.xpt ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/components/$(DLL_PREFIX)jar50$(DLL_SUFFIX) ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/jar.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/oji.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/jsdservice.xpt ./MozillaSunbird/components
***************
*** 283,293 ****
  	cp $(topsrcdir)/dist/bin/components/downloads.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/calendar.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/chrome/calendar.jar ./MozillaSunbird/chrome
! 	cp $(topsrcdir)/dist/bin/components/$(LIB_PREFIX)xp*$(DLL_SUFFIX) ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/$(LIB_PREFIX)*js*$(DLL_SUFFIX) ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/components/xpcom_thread*.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/proxyObj*.xpt ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/components/$(LIB_PREFIX)jsd*$(DLL_SUFFIX) ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/docshell*.xpt ./MozillaSunbird/components
  
  sunbirdunix::
--- 283,293 ----
  	cp $(topsrcdir)/dist/bin/components/downloads.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/calendar.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/chrome/calendar.jar ./MozillaSunbird/chrome
! 	cp $(topsrcdir)/dist/bin/components/$(DLL_PREFIX)xp*$(DLL_SUFFIX) ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/$(DLL_PREFIX)*js*$(DLL_SUFFIX) ./MozillaSunbird/
  	cp $(topsrcdir)/dist/bin/components/xpcom_thread*.xpt ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/proxyObj*.xpt ./MozillaSunbird/components
! 	cp $(topsrcdir)/dist/bin/components/$(DLL_PREFIX)jsd*$(DLL_SUFFIX) ./MozillaSunbird/components
  	cp $(topsrcdir)/dist/bin/components/docshell*.xpt ./MozillaSunbird/components
  
  sunbirdunix::
*** misc/mozilla/config/Makefile.in	Mon Nov  1 14:30:40 2004
--- misc/build/mozilla/config/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 135,141 ****
  
  ifdef MOZ_ENABLE_GTK2
    GLIB_CFLAGS = $(MOZ_GTK2_CFLAGS)
!   GLIB_LIBS = $(MOZ_GTK2_LIBS)
  endif
  
  build_number: FORCE
--- 135,141 ----
  
  ifdef MOZ_ENABLE_GTK2
    GLIB_CFLAGS = $(MOZ_GTK2_CFLAGS)
!   GLIB_LIBS = $(filter -lglib% -L%,$(MOZ_GTK2_LIBS))
  endif
  
  build_number: FORCE
*** misc/mozilla/config/config.mk	Tue Oct 12 00:13:31 2004
--- misc/build/mozilla/config/config.mk	Thu Mar 29 14:27:08 2007
***************
*** 771,776 ****
--- 771,793 ----
  endif
  
  #
+ # Shared library RUNPATH linker option(s)
+ #
+ ifeq ($(OS_ARCH),Linux)
+ EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN
+ ifdef IS_COMPONENT
+ EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN/..
+ endif # IS_COMPONENT
+ endif # Linux
+ 
+ ifeq ($(OS_ARCH),SunOS)
+ EXTRA_DSO_LDOPTS += -R '$$ORIGIN'
+ ifdef IS_COMPONENT
+ EXTRA_DSO_LDOPTS += -R '$$ORIGIN/..'
+ endif # IS_COMPONENT
+ endif # SunOS
+ 
+ #
  # Include any personal overrides the user might think are needed.
  #
  -include $(MY_CONFIG)
*** misc/mozilla/config/rules.mk	Thu Jun 24 14:58:48 2004
--- misc/build/mozilla/config/rules.mk	Thu Mar 29 14:27:08 2007
***************
*** 516,523 ****
  ifeq ($(OS_ARCH),WINNT)
  ifdef GNU_CC
  ifndef IS_COMPONENT
! DSO_LDOPTS += -Wl,--out-implib -Wl,$(IMPORT_LIBRARY)
  endif
  endif
  endif
  
--- 516,524 ----
  ifeq ($(OS_ARCH),WINNT)
  ifdef GNU_CC
  ifndef IS_COMPONENT
! DSO_LDOPTS += -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY)
  endif
+ DSO_LDOPTS += -Wl,--enable-runtime-pseudo-reloc -Wl,-Map -Wl,$(LIB_PREFIX)$(LIBRARY_NAME).map
  endif
  endif
  
***************
*** 1320,1325 ****
--- 1321,1327 ----
  
  $(XPIDL_GEN_DIR)/%.h: %.idl $(XPIDL_COMPILE) $(XPIDL_GEN_DIR)/.done
  	$(REPORT_BUILD)
+ 	echo "PATH=" $(PATH)
  	$(ELOG) $(XPIDL_COMPILE) -m header -w -I$(srcdir) -I$(IDL_DIR) -o $(XPIDL_GEN_DIR)/$* $(_VPATH_SRCS)
  	@if test -n "$(findstring $*.h, $(EXPORTS) $(SDK_HEADERS))"; \
  	  then echo "*** WARNING: file $*.h generated from $*.idl overrides $(srcdir)/$*.h"; else true; fi
*** misc/mozilla/configure	Tue Oct 12 00:13:29 2004
--- misc/build/mozilla/configure	Thu Mar 29 14:27:08 2007
***************
*** 5228,5234 ****
      ;;
  
  *-freebsd*)
!     if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo aout` != "elf"; then
  	DLL_SUFFIX=".so.1.0"
  	DSO_LDOPTS="-shared"
      fi
--- 5228,5234 ----
      ;;
  
  *-freebsd*)
!     if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo elf` != "elf"; then
  	DLL_SUFFIX=".so.1.0"
  	DSO_LDOPTS="-shared"
      fi
***************
*** 5895,5901 ****
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
--- 5895,5901 ----
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -norunpath -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
***************
*** 7504,7509 ****
--- 7504,7511 ----
  case $target in
  *-hpux11.*)
  	;;
+ *-freebsd*)
+ 	;;
  *)
  	echo $ac_n "checking for gethostbyname_r in -lc_r""... $ac_c" 1>&6
  echo "configure:7510: checking for gethostbyname_r in -lc_r" >&5
***************
*** 16606,16613 ****
--- 16606,16617 ----
  
  case "$host_os" in
  mingw*|cygwin*|msvc*|mks*)
+ # Don't add the wrapper for the HOST_* versions as they contain an
+ # unexpanded $CC and therfore wil get the wrapper below.
+    if test -n "$GNU_CC"; then
      HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
      HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+    fi
      CC="\$(CYGWIN_WRAPPER) $CC"
      CXX="\$(CYGWIN_WRAPPER) $CXX"
      CPP="\$(CYGWIN_WRAPPER) $CPP"
*** misc/mozilla/configure.in	Tue Oct 12 00:13:29 2004
--- misc/build/mozilla/configure.in	Thu Mar 29 14:27:08 2007
***************
*** 1006,1012 ****
      ;;
  
  *-freebsd*)
!     if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo aout` != "elf"; then
  	DLL_SUFFIX=".so.1.0"
  	DSO_LDOPTS="-shared"
      fi
--- 1006,1012 ----
      ;;
  
  *-freebsd*)
!     if test `test -x /usr/bin/objformat && /usr/bin/objformat || echo elf` != "elf"; then
  	DLL_SUFFIX=".so.1.0"
  	DSO_LDOPTS="-shared"
      fi
***************
*** 1536,1542 ****
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
--- 1536,1542 ----
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -norunpath -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
***************
*** 1981,1986 ****
--- 1981,1988 ----
  case $target in
  *-hpux11.*)
  	;;
+ *-freebsd*)
+ 	;;
  *)
  	AC_CHECK_LIB(c_r, gethostbyname_r)
  	;;
***************
*** 5692,5699 ****
--- 5692,5703 ----
  dnl ========================================================
  case "$host_os" in
  mingw*|cygwin*|msvc*|mks*)
+ # Don't add the wrapper for the HOST_* versions as they contain an
+ # unexpanded $CC and therfore wil get the wrapper below.
+    if test -n "$GNU_CC"; then
      HOST_CC="\$(CYGWIN_WRAPPER) $HOST_CC"
      HOST_CXX="\$(CYGWIN_WRAPPER) $HOST_CXX"
+    fi
      CC="\$(CYGWIN_WRAPPER) $CC"
      CXX="\$(CYGWIN_WRAPPER) $CXX"
      CPP="\$(CYGWIN_WRAPPER) $CPP"
*** misc/mozilla/directory/c-sdk/build.mk	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/directory/c-sdk/build.mk	Thu Mar 29 14:27:08 2007
***************
*** 367,373 ****
  ifdef NS_USE_GCC
  LINK_EXE	= $(CC) -o $@ $(LDFLAGS) $(LCFLAGS) $(DEPLIBS) $(OBJS) $(EXTRA_LIBS) $(PLATFORMLIBS)
  LINK_LIB	= $(AR) cr $@ $(OBJS)
! LINK_DLL	= $(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(@:.$(DLL_SUFFIX)=.$(LIB_SUFFIX)) $(LLFLAGS) $(DLL_LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS) $(EXTRA_DLL_LIBS)
  else
  DEBUG_LINK_OPT=/DEBUG
  ifeq ($(BUILD_OPT), 1)
--- 367,373 ----
  ifdef NS_USE_GCC
  LINK_EXE	= $(CC) -o $@ $(LDFLAGS) $(LCFLAGS) $(DEPLIBS) $(OBJS) $(EXTRA_LIBS) $(PLATFORMLIBS)
  LINK_LIB	= $(AR) cr $@ $(OBJS)
! LINK_DLL	= $(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(LIB_PREFIX)$(@:.$(DLL_SUFFIX)=.$(LIB_SUFFIX)) $(LLFLAGS) $(DLL_LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS) $(EXTRA_DLL_LIBS)
  else
  DEBUG_LINK_OPT=/DEBUG
  ifeq ($(BUILD_OPT), 1)
*** misc/mozilla/directory/c-sdk/config/Makefile	Tue Feb 10 23:01:16 2004
--- misc/build/mozilla/directory/c-sdk/config/Makefile	Thu Mar 29 14:27:08 2007
***************
*** 48,58 ****
  
  include $(topsrcdir)/config/config.mk
  
! CSRCS	= nsinstall.c now.c
  
  PLSRCS	= nfspwd.pl
  
! ifneq (,$(filter WINNT OS2,$(OS_ARCH)))
  PROG_SUFFIX = .exe
  else
  PROG_SUFFIX =
--- 48,62 ----
  
  include $(topsrcdir)/config/config.mk
  
! ifndef MOZILLA_CLIENT
! CSRCS	= nsinstall.c 
! endif
! 
! CSRCS	+= now.c
  
  PLSRCS	= nfspwd.pl
  
! ifneq (,$(CROSS_COMPILE)$(filter WINNT OS2,$(OS_ARCH)))
  PROG_SUFFIX = .exe
  else
  PROG_SUFFIX =
***************
*** 92,100 ****
      XLDOPTS += $(LDFLAGS)
  endif
  
! ifdef XP_OS2_EMX
  XCFLAGS = $(OS_EXE_CFLAGS)
! XLDOPTS = -Zlinker /PM:VIO
  endif
  
  ifeq ($(MOZ_OS2_TOOLS),VACPP)
--- 96,104 ----
      XLDOPTS += $(LDFLAGS)
  endif
  
! ifeq ($(MOZ_OS2_TOOLS),EMX)
  XCFLAGS = $(OS_EXE_CFLAGS)
! XLDOPTS = -Zomf -Zlinker /PM:VIO
  endif
  
  ifeq ($(MOZ_OS2_TOOLS),VACPP)
***************
*** 114,121 ****
--- 118,127 ----
  
  OUTOPTION = -o # end of the line
  ifeq (,$(filter-out WINNT OS2,$(OS_ARCH)))
+ ifndef NS_USE_GCC
  OUTOPTION = /Fe
  endif
+ endif
  
  # Redefine MAKE_OBJDIR for just this directory
  define MAKE_OBJDIR
*** misc/mozilla/directory/c-sdk/config/autoconf.mk.in	Fri Mar  7 15:57:13 2003
--- misc/build/mozilla/directory/c-sdk/config/autoconf.mk.in	Thu Mar 29 14:27:08 2007
***************
*** 25,30 ****
--- 25,31 ----
  LIB_SUFFIX	= @LIB_SUFFIX@
  LIB_PREFIX	= @LIB_PREFIX@
  DLL_SUFFIX	= @DLL_SUFFIX@
+ DLL_PREFIX	= @DLL_PREFIX@
  ASM_SUFFIX	= @ASM_SUFFIX@
  PROG_SUFFIX	= @PROG_SUFFIX@
  MOD_NAME	= @NSPR_MODNAME@
*** misc/mozilla/directory/c-sdk/config/FreeBSD.mk	Tue Mar 26 16:51:46 2002
--- misc/build/mozilla/directory/c-sdk/config/FreeBSD.mk	Wed Apr  4 20:56:05 2007
***************
*** 66,72 ****
  
  ARCH			= freebsd
  
! MOZ_OBJFORMAT          := $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo aout)
  
  ifeq ($(MOZ_OBJFORMAT),elf)
  DLL_SUFFIX		= so
--- 66,72 ----
  
  ARCH			= freebsd
  
! MOZ_OBJFORMAT          := $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo elf)
  
  ifeq ($(MOZ_OBJFORMAT),elf)
  DLL_SUFFIX		= so
*** misc/mozilla/directory/c-sdk/config/cygwin-wrapper	Wed Apr  2 19:22:39 2003
--- misc/build/mozilla/directory/c-sdk/config/cygwin-wrapper	Thu Mar 29 14:27:08 2007
***************
*** 1,4 ****
! #!/bin/sh
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
--- 1,4 ----
! #!/bin/bash
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
***************
*** 18,23 ****
     shift
     args=`echo $* | sed -e "s|-I\([a-zA-Z]\):/|-I${mountpoint}/\1/|g;"`
  else
!    args=`echo $* | sed -e "s|${mountpoint}/\([a-zA-Z]\)/|\1:/|g;"`
  fi
  exec $prog $args
--- 18,57 ----
     shift
     args=`echo $* | sed -e "s|-I\([a-zA-Z]\):/|-I${mountpoint}/\1/|g;"`
  else
!    for i in "${@}"
!    do
!       # The original version missed mounted paths, the new version below
!       # doesn't transform /para as this is most likely a parameter.
!       eval 'notinpath=${i%%'${mountpoint}'/[a-zA-Z]/*}'
!       if ! test "$notinpath" = "$i"; then
!          # found  $mountpoint
!          eval 'restpath=${i#'${notinpath}${mountpoint}'/[a-zA-Z]/}'
!          eval 'withdrive=${i#'${notinpath}${mountpoint}'/}'
!          driveletter=${withdrive%%/*}
!          i=${notinpath}${driveletter}:/${restpath}
!       else
!          # check for potential path. Precheck using shell methods
!          doconvert=""
!          # Shortcut -X<path> when path does not begin with '/'
!          noswitch=${i#-[a-zA-Z]}
!          if test "$noswitch" != "$i"; then
!             test "${noswitch#/}" != "$noswitch" && doconvert="1"
!          fi
!          # Precheck for possible path. Consider only absolute paths that contain at least
!          # a second / to prevent converting of /abc parameters.
!          test -z "$doconvert" -a "${i#/[a-zA-Z0-9_.-]*/}" != "$i" && doconvert="1"
!          if test -n "$doconvert"; then
!             # Can be a path. If forking grep would be faster or we could require bash 3
!             # this regexp would be all that's needed to find pathnames that need converting
!             pathname=`echo $i | grep -oE '^(-[a-zA-Z])?/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_./-]+$'`
!             eval 'notinpath=${i%'${pathname}'}'
!             if test "$notinpath" != "$i" -a "$pathname" != "${pathname#/}"; then
!                pathname=`cygpath -am "$pathname"`
!                i=${notinpath}${pathname}
!             fi
!          fi
!       fi
!       args="${args} ${i}"
!    done
  fi
  exec $prog $args
*** misc/mozilla/directory/c-sdk/configure	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/directory/c-sdk/configure	Thu Mar 29 14:27:08 2007
***************
*** 2830,2835 ****
--- 2830,2836 ----
  LIB_SUFFIX=a
  LIB_PREFIX=lib
  DLL_SUFFIX=so
+ DLL_PREFIX=lib
  ASM_SUFFIX=s
  MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
  PR_MD_ASFILES=
***************
*** 3465,3471 ****
  EOF
  
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
--- 3465,3471 ----
  EOF
  
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
***************
*** 3832,3837 ****
--- 3833,3839 ----
      MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
      DSO_CFLAGS=-fPIC
      DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN'"
      OS_LIBS="$OS_LIBS -lc"
      _OPTIMIZE_FLAGS=-O2
      _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
***************
*** 3901,3907 ****
          CC="$CC -mno-cygwin"
          CXX="$CXX -mno-cygwin"
          DLL_SUFFIX=dll
!         MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
          # Use temp file for windres (bug 213281)
          RC="$WINDRES -O coff --use-temp-file"
      else
--- 3903,3910 ----
          CC="$CC -mno-cygwin"
          CXX="$CXX -mno-cygwin"
          DLL_SUFFIX=dll
! 	DLL_PREFIX=
!         MKSHLIB='$(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
          # Use temp file for windres (bug 213281)
          RC="$WINDRES -O coff --use-temp-file"
      else
***************
*** 3918,3923 ****
--- 3921,3927 ----
  	    LIB_SUFFIX=lib
  	    LIB_PREFIX=
  	    DLL_SUFFIX=dll
+ 	    DLL_PREFIX=
          
          CFLAGS="$CFLAGS -W3 -nologo -GF -Gy"
  
***************
*** 4318,4323 ****
--- 4322,4328 ----
      NSINSTALL=nsinstall
      LIB_PREFIX=
      LIB_SUFFIX=lib
+     DLL_PREFIX=
      DLL_SUFFIX=dll
      DLLTOOL=''
      RC=rc.exe
***************
*** 4685,4690 ****
--- 4690,4696 ----
      LD=/usr/ccs/bin/ld
      RANLIB=/usr/ccs/bin/ranlib
      DSO_LDOPTS='-G -h $(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
      if test -n "$GNU_CC"; then
          DSO_CFLAGS=-fPIC
      else
***************
*** 5882,5887 ****
--- 5888,5894 ----
  s%@LIB_SUFFIX@%$LIB_SUFFIX%g
  s%@LIB_PREFIX@%$LIB_PREFIX%g
  s%@DLL_SUFFIX@%$DLL_SUFFIX%g
+ s%@DLL_PREFIX@%$DLL_PREFIX%g
  s%@ASM_SUFFIX@%$ASM_SUFFIX%g
  s%@PROG_SUFFIX@%$PROG_SUFFIX%g
  s%@MKSHLIB@%$MKSHLIB%g
*** misc/mozilla/directory/c-sdk/configure.in	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/directory/c-sdk/configure.in	Thu Mar 29 14:27:08 2007
***************
*** 511,516 ****
--- 511,517 ----
  LIB_SUFFIX=a
  LIB_PREFIX=lib
  DLL_SUFFIX=so
+ DLL_PREFIX=lib
  ASM_SUFFIX=s
  MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
  PR_MD_ASFILES=
***************
*** 896,902 ****
      AC_DEFINE(FREEBSD)
      AC_DEFINE(HAVE_BSD_FLOCK)
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
--- 896,902 ----
      AC_DEFINE(FREEBSD)
      AC_DEFINE(HAVE_BSD_FLOCK)
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
***************
*** 1144,1149 ****
--- 1145,1151 ----
      MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
      DSO_CFLAGS=-fPIC
      DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN'"
      OS_LIBS="$OS_LIBS -lc"
      _OPTIMIZE_FLAGS=-O2
      _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
***************
*** 1195,1200 ****
--- 1197,1204 ----
          CC="$CC -mno-cygwin"
          CXX="$CXX -mno-cygwin"
          DLL_SUFFIX=dll
+         DLL_SUFFIX=dll
+ 	DLL_PREFIX=
          MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) -o $@'
          # Use temp file for windres (bug 213281)
          RC="$WINDRES -O coff --use-temp-file"
***************
*** 1212,1217 ****
--- 1216,1222 ----
  	    LIB_SUFFIX=lib
  	    LIB_PREFIX=
  	    DLL_SUFFIX=dll
+ 	    DLL_PREFIX=
          
          CFLAGS="$CFLAGS -W3 -nologo -GF -Gy"
  
***************
*** 1686,1691 ****
--- 1691,1697 ----
      LD=/usr/ccs/bin/ld
      RANLIB=/usr/ccs/bin/ranlib
      DSO_LDOPTS='-G -h $(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
      if test -n "$GNU_CC"; then
          DSO_CFLAGS=-fPIC
      else
***************
*** 2272,2277 ****
--- 2278,2284 ----
  AC_SUBST(LIB_SUFFIX)
  AC_SUBST(LIB_PREFIX)
  AC_SUBST(DLL_SUFFIX)
+ AC_SUBST(DLL_PREFIX)
  AC_SUBST(ASM_SUFFIX)
  AC_SUBST(PROG_SUFFIX)
  AC_SUBST(MKSHLIB)
*** misc/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	Wed Mar 10 13:47:25 2004
--- misc/build/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 93,99 ****
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBLDAP		= $(addprefix $(OBJDIR_NAME)/, $(LIB_PREFIX)$(LDAP_LIBNAME).$(LIB_SUFFIX))
! DLLLDAP		= $(addprefix $(OBJDIR_NAME)/, $(LIB_PREFIX)$(LDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR	= $(DIST)/$(OBJDIR_NAME)
  
--- 93,99 ----
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBLDAP		= $(addprefix $(OBJDIR_NAME)/, $(LIB_PREFIX)$(LDAP_LIBNAME).$(LIB_SUFFIX))
! DLLLDAP		= $(addprefix $(OBJDIR_NAME)/, $(DLL_PREFIX)$(LDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR	= $(DIST)/$(OBJDIR_NAME)
  
*** misc/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	Wed Mar 10 13:47:26 2004
--- misc/build/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 46,52 ****
  LIBPRLDAP =
  endif
  DLLPRLDAP	= $(addprefix $(OBJDIR_NAME)/, \
! 			$(LIB_PREFIX)$(PRLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
--- 46,52 ----
  LIBPRLDAP =
  endif
  DLLPRLDAP	= $(addprefix $(OBJDIR_NAME)/, \
! 			$(DLL_PREFIX)$(PRLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
*** misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	Tue Feb 10 23:01:15 2004
--- misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	Thu Mar 29 14:27:08 2007
***************
*** 41,47 ****
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
! DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
--- 41,47 ----
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
! DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(DLL_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
***************
*** 92,97 ****
--- 92,106 ----
  endif
  
  ifeq ($(OS_ARCH), WINNT)
+ ifdef NS_USE_GCC
+ EXTRA_DLL_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME) -l$(PRLDAP_LIBNAME) \
+ 	-l$(NSS_LIBNAME)
+ ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
+ EXTRA_DLL_LIBS += -l$(SOFTOKN_LIBNAME)
+ endif
+ EXTRA_DLL_LIBS += -l$(SSL_LIBNAME) \
+ 	-l$(PLC_BASENAME) -l$(PLDS_BASENAME) -l$(NSPR_BASENAME)
+ else
  EXTRA_LIBS =wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib \
              comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib \
              rpcrt4.lib uuid.lib odbc32.lib odbccp32.lib winmm.lib
***************
*** 106,111 ****
--- 115,121 ----
  endif
  EXTRA_LIBS += $(dist_libdir)/$(SSL_LIBNAME).lib
  endif
+ endif
  
  ifeq ($(OS_ARCH),OS2)
  EXTRA_LIBS = $(OS_LIBS)
*** misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	Fri Mar  7 15:57:17 2003
--- misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 40,46 ****
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
! DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
--- 40,46 ----
  HDIR		= $(topsrcdir)/ldap/include
  
  LIBSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(LIB_PREFIX)$(SSLDAP_LIBNAME).$(LIB_SUFFIX))
! DLLSSLDAP	= $(addprefix $(SSLOBJDEST)/, $(DLL_PREFIX)$(SSLDAP_LIBNAME).$(DLL_SUFFIX))
  
  INSTALLDIR      = $(DIST)/$(OBJDIR_NAME)
  
*** misc/mozilla/embedding/browser/gtk/src/Makefile.in	Thu Apr  8 15:18:25 2004
--- misc/build/mozilla/embedding/browser/gtk/src/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 111,117 ****
  		gtkmozembed_internal.h
  
  ifdef MOZ_ENABLE_GTK
! EXTRA_DSO_LDOPTS = \
  		$(MOZ_COMPONENT_LIBS) \
  		$(XPCOM_GLUE_LIBS) \
  		-lgtksuperwin \
--- 111,117 ----
  		gtkmozembed_internal.h
  
  ifdef MOZ_ENABLE_GTK
! EXTRA_DSO_LDOPTS += \
  		$(MOZ_COMPONENT_LIBS) \
  		$(XPCOM_GLUE_LIBS) \
  		-lgtksuperwin \
***************
*** 119,125 ****
  endif
  
  ifdef MOZ_ENABLE_GTK2
! EXTRA_DSO_LDOPTS = \
  		$(MOZ_COMPONENT_LIBS) \
  		$(NULL)
  endif
--- 119,125 ----
  endif
  
  ifdef MOZ_ENABLE_GTK2
! EXTRA_DSO_LDOPTS += \
  		$(MOZ_COMPONENT_LIBS) \
  		$(NULL)
  endif
*** misc/mozilla/embedding/browser/gtk/tests/Makefile.in	Mon Oct  6 22:43:00 2003
--- misc/build/mozilla/embedding/browser/gtk/tests/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 46,55 ****
  		TestGtkEmbedNotebook.cpp \
  		TestGtkEmbedSocket.cpp \
  		TestGtkEmbedChild.cpp
- endif
  
  SIMPLE_PROGRAMS = $(CPPSRCS:.cpp=)
  
  # ENABLE_GNOME=1
  
  ifdef ENABLE_GNOME
--- 46,56 ----
  		TestGtkEmbedNotebook.cpp \
  		TestGtkEmbedSocket.cpp \
  		TestGtkEmbedChild.cpp
  
  SIMPLE_PROGRAMS = $(CPPSRCS:.cpp=)
  
+ endif
+ 
  # ENABLE_GNOME=1
  
  ifdef ENABLE_GNOME
*** misc/mozilla/embedding/config/Makefile.in	Mon Jul  7 04:02:25 2003
--- misc/build/mozilla/embedding/config/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 85,91 ****
  	$(NSINSTALL) -t $(srcdir)/installed-chrome.txt $(DIST)/Embed/chrome
  	$(NSINSTALL) -t $(srcdir)/readme.html $(DIST)/Embed
  ifndef MINIMO
! 	-$(NSINSTALL) -t $(DEPTH)/embedding/lite/$(LIB_PREFIX)embed_lite$(DLL_SUFFIX) $(DIST)/Embed/components
  endif
  ifeq ($(OS_ARCH),WINNT)
  ifeq ($(WINAPP),mfcembed)
--- 85,91 ----
  	$(NSINSTALL) -t $(srcdir)/installed-chrome.txt $(DIST)/Embed/chrome
  	$(NSINSTALL) -t $(srcdir)/readme.html $(DIST)/Embed
  ifndef MINIMO
! 	-$(NSINSTALL) -t $(DEPTH)/embedding/lite/$(DLL_PREFIX)embed_lite$(DLL_SUFFIX) $(DIST)/Embed/components
  endif
  ifeq ($(OS_ARCH),WINNT)
  ifeq ($(WINAPP),mfcembed)
*** misc/mozilla/extensions/p3p/Makefile.in	Thu Dec  4 13:20:16 2003
--- misc/build/mozilla/extensions/p3p/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 62,84 ****
  p3p200010.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2000/10/18/P3Pv1 \
! 	-DHAS_TMPL_RETENTION\
  	$< > $@
  
  p3p200012.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2000/12/P3Pv1 \
! 	-DHAS_CALL_OURS\
  	$< > $@
  
  p3p200109.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2001/09/P3Pv1 \
! 	-DHAS_CALL_OURS\
  	$< > $@
  
  p3p200201.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2002/01/P3Pv1 \
! 	-DHAS_CALL_OURS -DHAS_PURPOSE_SRC\
  	$< > $@
--- 62,84 ----
  p3p200010.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2000/10/18/P3Pv1 \
! 	-DHAS_TMPL_RETENTION \
  	$< > $@
  
  p3p200012.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2000/12/P3Pv1 \
! 	-DHAS_CALL_OURS \
  	$< > $@
  
  p3p200109.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2001/09/P3Pv1 \
! 	-DHAS_CALL_OURS \
  	$< > $@
  
  p3p200201.xsl: resources/content/p3p.xsl.in Makefile.in
  	@$(RM) -f $@
  	$(PP) -DNAMESPACE=http://www.w3.org/2002/01/P3Pv1 \
! 	-DHAS_CALL_OURS -DHAS_PURPOSE_SRC \
  	$< > $@
*** misc/mozilla/extensions/pref/autoconfig/src/Makefile.in	Wed Jan  7 08:36:25 2004
--- misc/build/mozilla/extensions/pref/autoconfig/src/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 68,74 ****
  endif
  
  
! EXTRA_DSO_LDOPTS = \
                     $(LIBS_DIR) \
                     $(MOZ_JS_LIBS) \
                     $(MOZ_COMPONENT_LIBS) \
--- 68,74 ----
  endif
  
  
! EXTRA_DSO_LDOPTS += \
                     $(LIBS_DIR) \
                     $(MOZ_JS_LIBS) \
                     $(MOZ_COMPONENT_LIBS) \
*** misc/mozilla/extensions/sql/build/Makefile.in	Sun Feb  8 16:51:04 2004
--- misc/build/mozilla/extensions/sql/build/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 52,56 ****
  	cd $(DIST); zip -r $(XPI_FILE) \
  	bin/components/sql.xpt \
  	bin/components/sqlpgsql.xpt \
! 	bin/components/$(LIB_PREFIX)sql$(DLL_SUFFIX) \
  	bin/chrome/sql.jar
--- 52,56 ----
  	cd $(DIST); zip -r $(XPI_FILE) \
  	bin/components/sql.xpt \
  	bin/components/sqlpgsql.xpt \
! 	bin/components/$(DLL_PREFIX)sql$(DLL_SUFFIX) \
  	bin/chrome/sql.jar
*** misc/mozilla/gfx/idl/nsIFreeType2.idl	Thu Apr 15 21:09:33 2004
--- misc/build/mozilla/gfx/idl/nsIFreeType2.idl	Thu Mar 29 14:27:08 2007
***************
*** 76,85 ****
  native FT_Sfnt_Tag(FT_Sfnt_Tag);
  native FT_Size(FT_Size);
  
! [ptr] native FTC_Image_Desc_p(FTC_Image_Desc);
  native FTC_Face_Requester(FTC_Face_Requester);
  native FTC_Font(FTC_Font);
! native FTC_Image_Cache(FTC_Image_Cache);
  native FTC_Manager(FTC_Manager);
  
  // #ifdef MOZ_SVG
--- 76,86 ----
  native FT_Sfnt_Tag(FT_Sfnt_Tag);
  native FT_Size(FT_Size);
  
! [ptr] native FTC_ImageType_p(FTC_ImageType);
  native FTC_Face_Requester(FTC_Face_Requester);
  native FTC_Font(FTC_Font);
! native FTC_FaceID(FTC_FaceID);
! native FTC_ImageCache(FTC_ImageCache);
  native FTC_Manager(FTC_Manager);
  
  // #ifdef MOZ_SVG
***************
*** 99,105 ****
  
      readonly attribute FT_Library library;
      readonly attribute FTC_Manager FTCacheManager;
!     readonly attribute FTC_Image_Cache ImageCache;
  
      void    doneFace(in FT_Face face);
      void    doneFreeType(in FT_Library lib);
--- 100,106 ----
  
      readonly attribute FT_Library library;
      readonly attribute FTC_Manager FTCacheManager;
!     readonly attribute FTC_ImageCache ImageCache;
  
      void    doneFace(in FT_Face face);
      void    doneFreeType(in FT_Library lib);
***************
*** 115,130 ****
      void    outlineDecompose(in FT_Outline_p outline,
                               in const_FT_Outline_Funcs_p funcs, in voidPtr p);
      void    setCharmap(in FT_Face face, in FT_CharMap charmap);
!     void    imageCacheLookup(in FTC_Image_Cache cache, in FTC_Image_Desc_p desc,
                               in FT_UInt gindex, out FT_Glyph glyph);
!     void    managerLookupSize(in FTC_Manager manager, in FTC_Font font,
!                               out FT_Face face, out FT_Size size);
      void    managerDone(in FTC_Manager manager);
      void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                         in FT_UInt max_sizes, in FT_ULong max_bytes,
                         in FTC_Face_Requester requester, in FT_Pointer req_data,
                         out FTC_Manager manager);
!     void    imageCacheNew(in FTC_Manager manager, out FTC_Image_Cache cache);
  /* #ifdef MOZ_SVG */
      void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                          in FT_Vector_p delta);
--- 116,131 ----
      void    outlineDecompose(in FT_Outline_p outline,
                               in const_FT_Outline_Funcs_p funcs, in voidPtr p);
      void    setCharmap(in FT_Face face, in FT_CharMap charmap);
!     void    imageCacheLookup(in FTC_ImageCache cache, in FTC_ImageType_p desc,
                               in FT_UInt gindex, out FT_Glyph glyph);
!     void    managerLookupFace(in FTC_Manager manager, in FTC_FaceID face_id,
!                               out FT_Face face);
      void    managerDone(in FTC_Manager manager);
      void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                         in FT_UInt max_sizes, in FT_ULong max_bytes,
                         in FTC_Face_Requester requester, in FT_Pointer req_data,
                         out FTC_Manager manager);
!     void    imageCacheNew(in FTC_Manager manager, out FTC_ImageCache cache);
  /* #ifdef MOZ_SVG */
      void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                          in FT_Vector_p delta);
*** misc/mozilla/gfx/src/freetype/nsFreeType.cpp	Sat Feb  7 10:22:30 2004
--- misc/build/mozilla/gfx/src/freetype/nsFreeType.cpp	Thu Mar 29 14:27:08 2007
***************
*** 111,117 ****
    {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
    {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
    {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
!   {"FTC_Manager_Lookup_Size", NS_FT2_OFFSET(nsFTC_Manager_Lookup_Size), PR_TRUE},
    {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
    {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
    {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
--- 111,117 ----
    {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
    {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
    {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
!   {"FTC_Manager_LookupFace",  NS_FT2_OFFSET(nsFTC_Manager_LookupFace),  PR_TRUE},
    {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
    {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
    {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
***************
*** 282,288 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheLookup(FTC_Image_Cache cache, FTC_Image_Desc *desc,
                                FT_UInt glyphID, FT_Glyph *glyph)
  { 
    // call the FreeType2 function via the function pointer
--- 282,288 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheLookup(FTC_ImageCache cache, FTC_ImageType *desc,
                                FT_UInt glyphID, FT_Glyph *glyph)
  { 
    // call the FreeType2 function via the function pointer
***************
*** 291,301 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ManagerLookupSize(FTC_Manager manager, FTC_Font font,
!                                FT_Face *face, FT_Size *size)
  { 
    // call the FreeType2 function via the function pointer
!   FT_Error error = nsFTC_Manager_Lookup_Size(manager, font, face, size);
    return error ? NS_ERROR_FAILURE : NS_OK;
  } 
   
--- 291,301 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ManagerLookupFace(FTC_Manager manager, FTC_FaceID font,
!                                FT_Face *face)
  { 
    // call the FreeType2 function via the function pointer
!   FT_Error error = nsFTC_Manager_LookupFace(manager, font, face);
    return error ? NS_ERROR_FAILURE : NS_OK;
  } 
   
***************
*** 320,326 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_Image_Cache *cache)
  { 
    // call the FreeType2 function via the function pointer
    FT_Error error = nsFTC_Image_Cache_New(manager, cache);
--- 320,326 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_ImageCache *cache)
  { 
    // call the FreeType2 function via the function pointer
    FT_Error error = nsFTC_Image_Cache_New(manager, cache);
***************
*** 389,395 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::GetImageCache(FTC_Image_Cache *aCache)
  {
    *aCache = mImageCache;
    return NS_OK;
--- 389,395 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::GetImageCache(FTC_ImageCache *aCache)
  {
    *aCache = mImageCache;
    return NS_OK;
*** misc/mozilla/gfx/src/freetype/nsFreeType.h	Fri Apr 16 17:31:42 2004
--- misc/build/mozilla/gfx/src/freetype/nsFreeType.h	Thu Mar 29 14:27:08 2007
***************
*** 104,116 ****
  typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
  typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
  typedef FT_Error (*FTC_Image_Cache_Lookup_t)
!                       (FTC_Image_Cache, FTC_Image_Desc*, FT_UInt, FT_Glyph*);
! typedef FT_Error (*FTC_Manager_Lookup_Size_t)
!                       (FTC_Manager, FTC_Font, FT_Face*, FT_Size*);
  typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
  typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                         FTC_Face_Requester, FT_Pointer, FTC_Manager*);
! typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_Image_Cache*);
  // #ifdef MOZ_SVG
  typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
  typedef FT_Error (*FT_Get_Kerning_t)
--- 104,116 ----
  typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
  typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
  typedef FT_Error (*FTC_Image_Cache_Lookup_t)
!                        (FTC_ImageCache, FTC_ImageType*, FT_UInt, FT_Glyph*);
! typedef FT_Error (*FTC_Manager_LookupFace_t)
!                        (FTC_Manager, FTC_FaceID, FT_Face*);
  typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
  typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                         FTC_Face_Requester, FT_Pointer, FTC_Manager*);
! typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_ImageCache*);
  // #ifdef MOZ_SVG
  typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
  typedef FT_Error (*FT_Get_Kerning_t)
***************
*** 165,171 ****
    FT_Outline_Decompose_t    nsFT_Outline_Decompose;
    FT_Set_Charmap_t          nsFT_Set_Charmap;
    FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
!   FTC_Manager_Lookup_Size_t nsFTC_Manager_Lookup_Size;
    FTC_Manager_Done_t        nsFTC_Manager_Done;
    FTC_Manager_New_t         nsFTC_Manager_New;
    FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
--- 165,171 ----
    FT_Outline_Decompose_t    nsFT_Outline_Decompose;
    FT_Set_Charmap_t          nsFT_Set_Charmap;
    FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
!   FTC_Manager_LookupFace_t  nsFTC_Manager_LookupFace;
    FTC_Manager_Done_t        nsFTC_Manager_Done;
    FTC_Manager_New_t         nsFTC_Manager_New;
    FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
***************
*** 213,219 ****
    PRLibrary      *mSharedLib;
    FT_Library      mFreeTypeLibrary;
    FTC_Manager     mFTCacheManager;
!   FTC_Image_Cache mImageCache;
  
    static nsHashtable   *sFontFamilies;
    static nsHashtable   *sRange1CharSetNames;
--- 213,219 ----
    PRLibrary      *mSharedLib;
    FT_Library      mFreeTypeLibrary;
    FTC_Manager     mFTCacheManager;
!   FTC_ImageCache  mImageCache;
  
    static nsHashtable   *sFontFamilies;
    static nsHashtable   *sRange1CharSetNames;
*** misc/mozilla/gfx/src/gtk/Makefile.in	Mon Nov 10 07:24:51 2003
--- misc/build/mozilla/gfx/src/gtk/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 176,181 ****
--- 176,185 ----
  CXXFLAGS	+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
  CFLAGS		+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
  
+ ifeq ($(OS_ARCH), Darwin)
+ EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS)
+ endif
+ 
  ifeq ($(OS_ARCH), SunOS)
  ifndef GNU_CC
  # When using Sun's WorkShop compiler, including
*** misc/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	Wed Feb  4 20:57:05 2004
--- misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	Thu Mar 29 14:27:08 2007
***************
*** 1141,1150 ****
    
    mPixelSize = NSToIntRound(app2dev * mFont->size);
  
!   mImageDesc.font.face_id    = (void*)mEntry;
!   mImageDesc.font.pix_width  = mPixelSize;
!   mImageDesc.font.pix_height = mPixelSize;
!   mImageDesc.image_type = 0;
  
    nsresult rv;
    mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
--- 1141,1150 ----
    
    mPixelSize = NSToIntRound(app2dev * mFont->size);
  
!   mImageDesc->face_id = (FTC_FaceID)&mEntry;
!   mImageDesc->width  = mPixelSize;
!   mImageDesc->height = mPixelSize;
!   mImageDesc->flags = 0;
  
    nsresult rv;
    mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
***************
*** 1190,1196 ****
    if (!face)
      return 0;
  
!   FTC_Image_Cache iCache;
    nsresult rv = mFt2->GetImageCache(&iCache);
    if (NS_FAILED(rv)) {
      NS_ERROR("Failed to get Image Cache");
--- 1190,1196 ----
    if (!face)
      return 0;
  
!   FTC_ImageCache iCache;
    nsresult rv = mFt2->GetImageCache(&iCache);
    if (NS_FAILED(rv)) {
      NS_ERROR("Failed to get Image Cache");
***************
*** 1228,1235 ****
    
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
!                                         &face, nsnull);
    NS_ASSERTION(rv==0, "failed to get face/size");
    if (rv)
      return nsnull;
--- 1228,1235 ----
    
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
!                                         &face);
    NS_ASSERTION(rv==0, "failed to get face/size");
    if (rv)
      return nsnull;
***************
*** 1622,1637 ****
    mEntry->GetFamilyName(fontName);
    mEntry->GetStyleName(styleName);
    
!   mImageDesc.font.face_id    = (void*)mEntry;
    // TT glyph has no relation to size
!   mImageDesc.font.pix_width  = 16;
!   mImageDesc.font.pix_height = 16;
!   mImageDesc.image_type = 0;
    FT_Face face = nsnull;
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
!                                         &face, nsnull);
    if (NS_FAILED(rv))
      return;
   
--- 1622,1637 ----
    mEntry->GetFamilyName(fontName);
    mEntry->GetStyleName(styleName);
    
!   mImageDesc->face_id = (FTC_FaceID)&mEntry;
    // TT glyph has no relation to size
!   mImageDesc->width  = 16;
!   mImageDesc->height = 16;
!   mImageDesc->flags = 0;
    FT_Face face = nsnull;
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
!                                         &face);
    if (NS_FAILED(rv))
      return;
   
*** misc/mozilla/gfx/src/ps/nsFontMetricsPS.h	Tue Apr 22 12:25:09 2003
--- misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.h	Thu Mar 29 14:27:08 2007
***************
*** 320,326 ****
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
    nsCOMPtr<nsIFreeType2> mFt2;
    PRUint16        mPixelSize;
!   FTC_Image_Desc  mImageDesc;
  
  
    static PRBool AddUserPref(nsIAtom *aLang, const nsFont& aFont,
--- 320,326 ----
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
    nsCOMPtr<nsIFreeType2> mFt2;
    PRUint16        mPixelSize;
!   FTC_ImageType   mImageDesc;
  
  
    static PRBool AddUserPref(nsIAtom *aLang, const nsFont& aFont,
***************
*** 363,369 ****
  protected:
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
    nsCOMPtr<nsIFreeType2> mFt2;
!   FTC_Image_Desc  mImageDesc;
  };
  #endif
  
--- 363,369 ----
  protected:
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
    nsCOMPtr<nsIFreeType2> mFt2;
!   FTC_ImageType   mImageDesc;
  };
  #endif
  
*** misc/mozilla/gfx/src/windows/nsDeviceContextWin.cpp	Mon Jun  7 18:17:11 2004
--- misc/build/mozilla/gfx/src/windows/nsDeviceContextWin.cpp	Thu Mar 29 14:27:08 2007
***************
*** 378,384 ****
--- 378,388 ----
      memcpy(name, ptrLogFont->lfFaceName, LF_FACESIZE*2);
    else {
      MultiByteToWideChar(CP_ACP, 0, ptrLogFont->lfFaceName,
+ #ifdef __MINGW32__
+       strlen(ptrLogFont->lfFaceName) + 1, NS_REINTERPRET_CAST(LPWSTR, name), sizeof(name)/sizeof(name[0]));
+ #else
        strlen(ptrLogFont->lfFaceName) + 1, name, sizeof(name)/sizeof(name[0]));
+ #endif
    }
    aFont->name = name;
  
***************
*** 601,607 ****
--- 605,615 ----
    LOGFONT logFont;
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfPitchAndFamily = 0;
+ #ifdef __MINGW32__
+   int outlen = WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, aFontName.get()), aFontName.Length() + 1,
+ #else
    int outlen = WideCharToMultiByte(CP_ACP, 0, aFontName.get(), aFontName.Length() + 1,
+ #endif
                                     logFont.lfFaceName, sizeof(logFont.lfFaceName), nsnull, nsnull);
  
    // somehow the WideCharToMultiByte failed, let's try the old code
***************
*** 928,934 ****
--- 936,946 ----
     if(acp)
     {
        int outlen = ::WideCharToMultiByte( CP_ACP, 0, 
+ #ifdef __MINGW32__
+                       NS_REINTERPRET_CAST(LPCWSTR, PromiseFlatString(aStr).get()), aStr.Length(),
+ #else
                        PromiseFlatString(aStr).get(), aStr.Length(),
+ #endif
                        acp, acplen, NULL, NULL);
        if ( outlen > 0)
           acp[outlen] = '\0';  // null terminate
*** misc/mozilla/gfx/src/windows/nsFontMetricsWin.cpp	Sat Oct 16 00:14:42 2004
--- misc/build/mozilla/gfx/src/windows/nsFontMetricsWin.cpp	Thu Mar 29 14:27:08 2007
***************
*** 1259,1265 ****
--- 1259,1269 ----
      PRUnichar fname[LF_FACESIZE];
      fname[0] = 0;
      MultiByteToWideChar(CP_ACP, 0, aFontName,
+ #ifdef __MINGW32__
+     strlen(aFontName) + 1, NS_REINTERPRET_CAST(LPWSTR, fname), sizeof(fname)/sizeof(fname[0]));
+ #else
      strlen(aFontName) + 1, fname, sizeof(fname)/sizeof(fname[0]));
+ #endif
      name.Assign(NS_LITERAL_CSTRING("encoding.") + NS_ConvertUCS2toUTF8(fname) + NS_LITERAL_CSTRING(".ttf"));
    }
  
***************
*** 2121,2127 ****
--- 2125,2135 ----
      }
      // get the final rightBearing and width. Possible kerning is taken into account.
      SIZE size;
+ #ifdef __MIGW32__
+     ::GetTextExtentPointW(aDC, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength, &size);
+ #else
      ::GetTextExtentPointW(aDC, aString, aLength, &size);
+ #endif
      size.cx -= aOverhangCorrection;
      aBoundingMetrics.width = size.cx;
      aBoundingMetrics.rightBearing = size.cx - gm.gmCellIncX + gm.gmptGlyphOrigin.x + gm.gmBlackBoxX;
***************
*** 2352,2358 ****
--- 2360,2370 ----
     * but we don't really have a choice since CreateFontIndirectW is
     * not supported on Windows 9X (see below) -- erik
     */
+ #ifdef __MINGW32__
+   WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, aName.get()), aName.Length() + 1,
+ #else
    WideCharToMultiByte(CP_ACP, 0, aName.get(), aName.Length() + 1,
+ #endif
      aLogFont->lfFaceName, sizeof(aLogFont->lfFaceName), nsnull, nsnull);
  
    if (mFont.sizeAdjust <= 0) {
***************
*** 2502,2508 ****
--- 2514,2524 ----
    PRUnichar name[LF_FACESIZE];
    name[0] = 0;
    MultiByteToWideChar(CP_ACP, 0, logFont->lfFaceName,
+ #ifdef __MINGW32__
+     strlen(logFont->lfFaceName) + 1, NS_REINTERPRET_CAST(LPWSTR, name), sizeof(name)/sizeof(name[0]));
+ #else
      strlen(logFont->lfFaceName) + 1, name, sizeof(name)/sizeof(name[0]));
+ #endif
  
    nsGlobalFont* font = new nsGlobalFont;
    if (!font) {
***************
*** 2943,2949 ****
--- 2959,2969 ----
    // Look for all of the weights for a given font.
    LOGFONT logFont;
    logFont.lfCharSet = DEFAULT_CHARSET;
+ #ifdef __MINGW32__
+   WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, aFontName.get()), aFontName.Length() + 1,
+ #else
    WideCharToMultiByte(CP_ACP, 0, aFontName.get(), aFontName.Length() + 1,
+ #endif
      logFont.lfFaceName, sizeof(logFont.lfFaceName), nsnull, nsnull);
    logFont.lfPitchAndFamily = 0;
  
***************
*** 4098,4111 ****
--- 4118,4139 ----
  
  static PRBool
  NS_ExtTextOutW(HDC aDC, nsFontWin* aFont, PRInt32 aX, PRInt32 aY, UINT uOptions,
+ #ifdef __MINGW32__
+   LPCRECT lprc, const PRUnichar* aString, UINT aLength, INT *lpDx)
+ #else
    LPCRECT lprc, LPCWSTR aString, UINT aLength, INT *lpDx)
+ #endif
  {
    RECT clipRect;
    if (!lpDx && !lprc && aFont->FillClipRect(aX, aY, aLength, uOptions, clipRect)) {
      lprc = &clipRect;
      uOptions |= ETO_CLIPPED;
    }
+ #ifdef __MINGW32__
+   return ::ExtTextOutW(aDC, aX, aY, uOptions, lprc, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength, lpDx);
+ #else
    return ::ExtTextOutW(aDC, aX, aY, uOptions, lprc, aString, aLength, lpDx);
+ #endif
  }
  
  void
***************
*** 4150,4156 ****
--- 4178,4188 ----
    CheckLength(&aLength);
  
    SIZE size;
+ #ifdef __MINGW32__
+   ::GetTextExtentPoint32W(aDC, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength, &size);
+ #else
    ::GetTextExtentPoint32W(aDC, aString, aLength, &size);
+ #endif
    size.cx -= mOverhangCorrection;
    return size.cx;
  }
***************
*** 4177,4183 ****
--- 4209,4219 ----
        // Clip out the extra underline/strikethru caused by the
        // bug in WIN95.
        SIZE size;
+ #ifdef __MINGW32__
+       ::GetTextExtentPoint32W(aDC, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength, &size);
+ #else
        ::GetTextExtentPoint32W(aDC, aString, aLength, &size);
+ #endif
        size.cx -= mOverhangCorrection;
        RECT clipRect;
        clipRect.top = aY - size.cy;
***************
*** 4260,4266 ****
--- 4296,4306 ----
    if (!mIsWide)
      ::GetTextExtentPoint32A(aDC, buffer.get(), destLength, &size);
    else
+ #ifdef __MINGW32__
+     ::GetTextExtentPoint32W(aDC, NS_REINTERPRET_CAST(LPCWSTR, buffer.get()), destLength / 2, &size);
+ #else
      ::GetTextExtentPoint32W(aDC, (const PRUnichar*) buffer.get(), destLength / 2, &size);
+ #endif
    size.cx -= mOverhangCorrection;
  
    return size.cx;
***************
*** 4435,4441 ****
--- 4475,4485 ----
    if (NS_FAILED(rv) || !aLength) return 0;
  
    SIZE size;
+ #ifdef __MINGW32__
+   ::GetTextExtentPoint32W(aDC, NS_REINTERPRET_CAST(LPCWSTR, buffer.get()), aLength, &size);
+ #else
    ::GetTextExtentPoint32W(aDC, buffer.get(), aLength, &size);
+ #endif
    size.cx -= mOverhangCorrection;
  
    return size.cx;
***************
*** 4640,4652 ****
--- 4684,4704 ----
  {
    *aResultLength = 0;
    // Get the number of bytes needed for the conversion
+ #ifdef __MINGW32__
+   int nb = WideCharToMultiByte(mCodePage, 0, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength,
+ #else
    int nb = WideCharToMultiByte(mCodePage, 0, aString, aLength,
+ #endif
                                 nsnull, 0, nsnull, nsnull);
  
    if (!nb || !aResult.EnsureElemCapacity(nb)) return;
    char* buf = aResult.get();
    // Convert the Unicode string to ANSI
+ #ifdef __MINGW32__
+   *aResultLength = WideCharToMultiByte(mCodePage, 0, NS_REINTERPRET_CAST(LPCWSTR, aString), aLength,
+ #else
    *aResultLength = WideCharToMultiByte(mCodePage, 0, aString, aLength,
+ #endif
                                         buf, nb, nsnull, nsnull);
  }
  
*** misc/mozilla/gfx/src/windows/nsRenderingContextWin.cpp	Wed Feb  4 20:57:06 2004
--- misc/build/mozilla/gfx/src/windows/nsRenderingContextWin.cpp	Thu Mar 29 14:27:08 2007
***************
*** 2939,2955 ****
--- 2939,2967 ----
  
      GCP_RESULTSW gcpResult;
      gcpResult.lStructSize = sizeof(GCP_RESULTS);
+ #ifdef __MINGW32__
+     gcpResult.lpOutString = NS_REINTERPRET_CAST(LPWSTR, outStr);     // Output string
+ #else
      gcpResult.lpOutString = outStr;     // Output string
+ #endif
      gcpResult.lpOrder = nsnull;         // Ordering indices
      gcpResult.lpDx = distanceArray;     // Distances between character cells
      gcpResult.lpCaretPos = nsnull;      // Caret positions
      gcpResult.lpClass = nsnull;         // Character classifications
+ #ifdef __MINGW32__
+     gcpResult.lpGlyphs = NS_REINTERPRET_CAST(LPWSTR, glyphArray);    // Character glyphs
+ #else
      gcpResult.lpGlyphs = glyphArray;    // Character glyphs
+ #endif
      gcpResult.nGlyphs = 2;              // Array size
  
      PRUnichar inStr[] = {araAin, one};
  
+ #ifdef __MINGW32__
+     if (::GetCharacterPlacementW(mDC, NS_REINTERPRET_CAST(LPCWSTR, inStr), 2, 0, &gcpResult, GCP_REORDER) 
+ #else
      if (::GetCharacterPlacementW(mDC, inStr, 2, 0, &gcpResult, GCP_REORDER) 
+ #endif
          && (inStr[0] == outStr[1]) ) {
        gBidiInfo = GCP_REORDER | GCP_GLYPHSHAPE;
  #ifdef NS_DEBUG
***************
*** 2960,2966 ****
--- 2972,2982 ----
        const PRUnichar hebAlef = 0x05D0;
        inStr[0] = hebAlef;
        inStr[1] = one;
+ #ifdef __MINGW32__
+       if (::GetCharacterPlacementW(mDC, NS_REINTERPRET_CAST(LPCWSTR, inStr), 2, 0, &gcpResult, GCP_REORDER) 
+ #else
        if (::GetCharacterPlacementW(mDC, inStr, 2, 0, &gcpResult, GCP_REORDER) 
+ #endif
            && (inStr[0] == outStr[1]) ) {
          gBidiInfo = GCP_REORDER;
  #ifdef NS_DEBUG
*** misc/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	Thu Dec 25 03:24:52 2003
--- misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	Thu Mar 29 14:27:08 2007
***************
*** 177,183 ****
    FTC_Manager mgr;
    nsresult rv;
    mFt2->GetFTCacheManager(&mgr);
!   rv = mFt2->ManagerLookupSize(mgr, &mImageDesc.font, &face, nsnull);
    NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
    if (NS_FAILED(rv))
      return nsnull;
--- 177,183 ----
    FTC_Manager mgr;
    nsresult rv;
    mFt2->GetFTCacheManager(&mgr);
!   rv = mFt2->ManagerLookupFace(mgr, mImageDesc->face_id, &face);
    NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
    if (NS_FAILED(rv))
      return nsnull;
***************
*** 191,212 ****
    PRBool embedded_bimap = PR_FALSE;
    mFaceID = aFaceID;
    mPixelSize = aPixelSize;
!   mImageDesc.font.face_id    = (void*)mFaceID;
!   mImageDesc.font.pix_width  = aPixelSize;
!   mImageDesc.font.pix_height = aPixelSize;
!   mImageDesc.image_type = 0;
  
    if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
-     mImageDesc.image_type |= ftc_image_mono;
      anti_alias = PR_FALSE;
    }
  
-   if (nsFreeType2::gFreeType2Autohinted)
-     mImageDesc.image_type |= ftc_image_flag_autohinted;
- 
-   if (nsFreeType2::gFreeType2Unhinted)
-     mImageDesc.image_type |= ftc_image_flag_unhinted;
- 
    PRUint32  num_embedded_bitmaps, i;
    PRInt32*  embedded_bitmapheights;
    mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
--- 191,205 ----
    PRBool embedded_bimap = PR_FALSE;
    mFaceID = aFaceID;
    mPixelSize = aPixelSize;
!   mImageDesc->face_id = (FTC_FaceID)&mFaceID;
!   mImageDesc->width  = aPixelSize;
!   mImageDesc->height = aPixelSize;
!   mImageDesc->flags = 0;
  
    if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
      anti_alias = PR_FALSE;
    }
  
    PRUint32  num_embedded_bitmaps, i;
    PRInt32*  embedded_bitmapheights;
    mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
***************
*** 218,224 ****
          if (embedded_bitmapheights[i] == aPixelSize) {
            embedded_bimap = PR_TRUE;
            // unhinted must be set for embedded bitmaps to be used
-           mImageDesc.image_type |= ftc_image_flag_unhinted;
            break;
          }
        }
--- 211,216 ----
***************
*** 312,318 ****
    if (!face)
      return NS_ERROR_FAILURE;
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return NS_ERROR_FAILURE;
--- 304,310 ----
    if (!face)
      return NS_ERROR_FAILURE;
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return NS_ERROR_FAILURE;
***************
*** 401,407 ****
    if (!face)
      return 0;
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
--- 393,399 ----
    if (!face)
      return 0;
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
***************
*** 723,729 ****
      if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
  #endif
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
--- 715,721 ----
      if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
  #endif
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
*** misc/mozilla/gfx/src/x11shared/nsFontFreeType.h	Tue Apr 22 12:25:13 2003
--- misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.h	Thu Mar 29 14:27:08 2007
***************
*** 110,116 ****
    XImage *GetXImage(PRUint32 width, PRUint32 height);
    nsITrueTypeFontCatalogEntry *mFaceID;
    PRUint16        mPixelSize;
!   FTC_Image_Desc  mImageDesc;
    nsCOMPtr<nsIFreeType2> mFt2;
  };
  
--- 110,116 ----
    XImage *GetXImage(PRUint32 width, PRUint32 height);
    nsITrueTypeFontCatalogEntry *mFaceID;
    PRUint16        mPixelSize;
!   FTC_ImageType   mImageDesc;
    nsCOMPtr<nsIFreeType2> mFt2;
  };
  
*** misc/mozilla/jpeg/jmorecfg.h	Thu Mar 25 21:17:16 2004
--- misc/build/mozilla/jpeg/jmorecfg.h	Thu Mar 29 14:27:08 2007
***************
*** 108,115 ****
  /* Defines for MMX/SSE2 support. */
  
  #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
! #define HAVE_MMX_INTEL_MNEMONICS 
! #define HAVE_SSE2_INTEL_MNEMONICS 
  #endif
  
  /* Compressed datastreams are represented as arrays of JOCTET.
--- 108,115 ----
  /* Defines for MMX/SSE2 support. */
  
  #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
! //#define HAVE_MMX_INTEL_MNEMONICS 
! //#define HAVE_SSE2_INTEL_MNEMONICS 
  #endif
  
  /* Compressed datastreams are represented as arrays of JOCTET.
*** misc/mozilla/js/src/xpconnect/src/Makefile.in	Wed Jan  7 08:36:33 2004
--- misc/build/mozilla/js/src/xpconnect/src/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 148,151 ****
  .NOTPARALLEL::
  endif
  endif
- 
--- 148,150 ----
*** misc/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	Thu Mar 18 21:36:16 2004
--- misc/build/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	Thu Mar 29 14:27:08 2007
***************
*** 440,458 ****
      return;
    }
  
!   FTC_Image_Desc imageDesc;
!   imageDesc.font.face_id=(void*)font_data.font_entry.get(); // XXX do we need to addref?
    float twipstopixel = GetTwipsToPixels();
    float scale = GetPixelScale();
!   imageDesc.font.pix_width = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc.font.pix_height = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc.image_type |= ftc_image_grays;
  
    // get the face
    nsresult rv;
    FTC_Manager mgr;
    nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
!   rv = nsSVGLibartFreetype::ft2->ManagerLookupSize(mgr, &imageDesc.font, &mFace, nsnull);
    NS_ASSERTION(mFace, "failed to get face/size");
  }
  
--- 440,458 ----
      return;
    }
  
!   FTC_ImageType imageDesc;
!   imageDesc->face_id=(FTC_FaceID)font_data.font_entry.get(); // XXX do we need to addref?
    float twipstopixel = GetTwipsToPixels();
    float scale = GetPixelScale();
!   imageDesc->width = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc->height = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc->flags |= /* ftc_image_grays */0;
  
    // get the face
    nsresult rv;
    FTC_Manager mgr;
    nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
!   rv = nsSVGLibartFreetype::ft2->ManagerLookupFace(mgr, imageDesc->face_id, &mFace);
    NS_ASSERTION(mFace, "failed to get face/size");
  }
  
*** misc/mozilla/mailnews/addrbook/src/Makefile.in	Mon Oct  6 13:48:56 2003
--- misc/build/mozilla/mailnews/addrbook/src/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 86,91 ****
--- 86,92 ----
                  nsVCard.cpp \
                  nsVCardObj.cpp \
                  nsMsgVCardService.cpp \
+                 nsAbMD5sum.cpp	\
  		$(NULL)
  
  EXPORTS		= \
*** misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	Fri Oct 11 04:17:13 2002
--- misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	Thu Mar 29 14:27:08 2007
***************
*** 39,44 ****
--- 39,45 ----
  #include "nsAbBoolExprToLDAPFilter.h"
  #include "nsAbLDAPProperties.h"
  #include "nsXPIDLString.h"
+ #include "nsAbUtils.h"
  
  const int nsAbBoolExprToLDAPFilter::TRANSLATE_CARD_PROPERTY = 1 << 0 ;
  const int nsAbBoolExprToLDAPFilter::ALLOW_NON_CONVERTABLE_CARD_PROPERTY = 1 << 1 ;
***************
*** 186,198 ****
      rv = condition->GetName (getter_Copies (name));
      NS_ENSURE_SUCCESS(rv, rv);
  
!     const char* ldapProperty = name.get ();
      if (flags & TRANSLATE_CARD_PROPERTY)
      {
!         const MozillaLdapPropertyRelation* p =
!             MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ());
!         if (p)
!             ldapProperty = p->ldapProperty;
          else if (!(flags & ALLOW_NON_CONVERTABLE_CARD_PROPERTY))
              return NS_OK;
      }
--- 187,202 ----
      rv = condition->GetName (getter_Copies (name));
      NS_ENSURE_SUCCESS(rv, rv);
  
!     CharPtrArrayGuard attrs;
      if (flags & TRANSLATE_CARD_PROPERTY)
      {
!         if(const MozillaLdapPropertyRelation* property =
!             MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ()))
!         {
!             // allow even single ldap attribute mapppings to go through this to simplify the filter creation later.
!             rv = MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (property->ldapProperty, attrs.GetSizeAddr(), attrs.GetArrayAddr() );
!             NS_ENSURE_SUCCESS(rv, rv);
!         }
          else if (!(flags & ALLOW_NON_CONVERTABLE_CARD_PROPERTY))
              return NS_OK;
      }
***************
*** 202,207 ****
--- 206,242 ----
      NS_ENSURE_SUCCESS(rv, rv);
      NS_ConvertUCS2toUTF8 vUTF8 (value);
  
+     // check if using multiple ldap attributes
+     if(attrs.GetSize() == 1 ) 
+         GenerateSingleFilter(conditionType,filter,vUTF8,attrs.GetArray()[0]);
+     else
+     {
+         // add the opening brace if using multiple ldap attributes
+         switch (conditionType)
+         {
+             // 'NOT' conditionals use the 'AND' operator 
+             case nsIAbBooleanConditionTypes::DoesNotExist:
+             case nsIAbBooleanConditionTypes::DoesNotContain:
+             case nsIAbBooleanConditionTypes::IsNot:
+                 filter += NS_LITERAL_CSTRING("(&");
+                 break;
+             default:
+                 filter += NS_LITERAL_CSTRING("(|");
+                 break;
+         }
+         GenerateMultipleFilter(conditionType,filter,vUTF8,&attrs);
+         // add the closing brace if using multiple ldap attributes
+         filter += NS_LITERAL_CSTRING(")");
+     }
+ 
+     return rv;
+ }
+ void nsAbBoolExprToLDAPFilter:: GenerateSingleFilter(
+     nsAbBooleanConditionType conditionType,
+     nsCString& filter,
+     NS_ConvertUCS2toUTF8 &vUTF8,
+     const char *ldapProperty)
+ {
      switch (conditionType)
      {
          case nsIAbBooleanConditionTypes::DoesNotExist:
***************
*** 282,288 ****
          default:
              break;
      }
- 
-     return rv;
  }
  
--- 317,363 ----
          default:
              break;
      }
  }
+ void nsAbBoolExprToLDAPFilter:: GenerateMultipleFilter(
+     nsAbBooleanConditionType conditionType,
+     nsCString& filter,
+     NS_ConvertUCS2toUTF8 &vUTF8,
+     CharPtrArrayGuard *pAttrs)
+ {
+     PRUint16 i = 0;
+     PRUint16 inner = 0;
+ 
+     /*
+      * This function is based on the fact that we are trying to generate support
+      * for multiple occurring ldap attributes. Consider the following query:
+      * (PagerNumber,=,123456) where PagerNumber = pager|pagerphone translates to: 
+      * (|(&(pager=*)(pager=123456))(&(!(pager=*))(pagerphone=123456)))
+      * This can be shortened to:
+      * (|(pager=123456)(&(!(pager=*))(pagerphone=123456)))
+      *
+      * i.e. use the first occurring attribute if it exists otherwise if first 
+      * does not exist use the second etc. The assumption is that the first
+      * always takes precedence.
+      * This translates to: 
+      *      GenerateSingleFilter(Is);
+      *          GenerateSingleFilter(DoesNotExists); 
+      *          GenerateSingleFilter(Is);
+     */
  
+     for (i = 0; i < pAttrs->GetSize(); i++)
+     {
+         if(i == 0)
+             GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+         else
+         {
+             filter += NS_LITERAL_CSTRING("(&");
+             nsAbBooleanConditionType doesNotExistsType = nsIAbBooleanConditionTypes::DoesNotExist; 
+             for(inner = 0; inner < i; ++inner)
+             {
+                 GenerateSingleFilter(doesNotExistsType,filter,vUTF8,pAttrs->GetArray()[inner]); 
+             }
+             GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+             filter += NS_LITERAL_CSTRING(")");
+         }
+     }
+ }
*** misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	Fri Sep 28 16:06:21 2001
--- misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	Thu Mar 29 14:27:08 2007
***************
*** 42,47 ****
--- 42,48 ----
  #include "nsIAbBooleanExpression.h"
  #include "nsCOMPtr.h"
  #include "nsString.h"
+ #include "nsAbUtils.h"
  
  class nsAbBoolExprToLDAPFilter
  {
***************
*** 67,72 ****
--- 68,83 ----
          nsIAbBooleanConditionString* condition,
          nsCString& filter,
          int flags);
+     static void GenerateMultipleFilter(
+        nsAbBooleanConditionType conditionType,
+        nsCString& filter,
+        NS_ConvertUCS2toUTF8 &vUTF8,
+        CharPtrArrayGuard *pAttrs);
+     static void GenerateSingleFilter(
+        nsAbBooleanConditionType conditionType,
+        nsCString& filter,
+        NS_ConvertUCS2toUTF8 &vUTF8,
+        const char *ldapProperty);
  };
  
  #endif
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	Fri Feb 13 21:09:27 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	Thu Mar 29 14:27:08 2007
***************
*** 118,128 ****
  
      // use mURINoQuery to get a prefName
      nsCAutoString prefName;
!     prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) + NS_LITERAL_CSTRING(".uri");
  
      // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
      nsXPIDLCString URI;
!     rv = prefs->CopyCharPref(prefName.get(), getter_Copies(URI));
      if (NS_FAILED(rv))
      {
          /*
--- 118,130 ----
  
      // use mURINoQuery to get a prefName
      nsCAutoString prefName;
!     prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) ;
  
      // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
      nsXPIDLCString URI;
!     nsCAutoString uriPrefName;
!     uriPrefName = prefName + NS_LITERAL_CSTRING(".uri");
!     rv = prefs->CopyCharPref(uriPrefName.get(), getter_Copies(URI));
      if (NS_FAILED(rv))
      {
          /*
***************
*** 146,151 ****
--- 148,174 ----
          nsCAutoString tempLDAPURL(mURINoQuery);
          tempLDAPURL.ReplaceSubstring("moz-abldapdirectory:", "ldap:");
          rv = mURL->SetSpec(tempLDAPURL);
+ 		NS_ENSURE_SUCCESS(rv,rv);
+     
+         nsCAutoString aHost;
+         mURL->GetHost(aHost);
+         aHost.ReplaceChar('.','_');
+         prefName = nsDependentCString("ldap_2.servers.") + aHost;
+         PRBool useSSL=0;
+         rv = prefs->GetBoolPref(
+                 PromiseFlatCString(prefName
+                 + NS_LITERAL_CSTRING(".UseSSL")).get(),
+                 &useSSL
+             );
+         
+         // If use SSL,ldap url will look like this ldaps://host:port/.....
+         if (!NS_FAILED(rv) && useSSL)
+         {
+             tempLDAPURL.ReplaceSubstring("ldap:", "ldaps:"); 
+             rv = mURL->SetSpec(tempLDAPURL);
+         }
+         //NS_FAILED(rv) means ldap_2.servers.nscpphonebook.UseSSL not exist
+         rv = 0;
      }
      else
      {
***************
*** 156,179 ****
      // get the login information, if there is any 
      //
      rv = prefs->GetCharPref(
!         PromiseFlatCString(
!             Substring(mURINoQuery, kLDAPDirectoryRootLen,
!                       mURINoQuery.Length() - kLDAPDirectoryRootLen)
              + NS_LITERAL_CSTRING(".auth.dn")).get(),
          getter_Copies(mLogin));
      if (NS_FAILED(rv)) {
          mLogin.Truncate();  // zero out mLogin
      }
  
      // get the protocol version, if there is any.  using a string pref
      // here instead of an int, as protocol versions sometimes have names like
      // "4bis".
      //
      nsXPIDLCString protocolVersion;
      rv = prefs->GetCharPref(
!         PromiseFlatCString(
!             Substring(mURINoQuery, kLDAPDirectoryRootLen,
!                       mURINoQuery.Length() - kLDAPDirectoryRootLen)
              + NS_LITERAL_CSTRING(".protocolVersion")).get(),
          getter_Copies(protocolVersion));
  
--- 179,207 ----
      // get the login information, if there is any 
      //
      rv = prefs->GetCharPref(
!         PromiseFlatCString(prefName
              + NS_LITERAL_CSTRING(".auth.dn")).get(),
          getter_Copies(mLogin));
      if (NS_FAILED(rv)) {
          mLogin.Truncate();  // zero out mLogin
      }
  
+     // get the password information, if there is any 
+     //
+     rv = prefs->GetCharPref(
+         PromiseFlatCString(prefName
+             + NS_LITERAL_CSTRING(".auth.pwd")).get(),
+         getter_Copies(mPassword));
+     if (NS_FAILED(rv)) {
+         mPassword.Truncate();  // zero out mLogin
+     }
      // get the protocol version, if there is any.  using a string pref
      // here instead of an int, as protocol versions sometimes have names like
      // "4bis".
      //
      nsXPIDLCString protocolVersion;
      rv = prefs->GetCharPref(
!         PromiseFlatCString(prefName
              + NS_LITERAL_CSTRING(".protocolVersion")).get(),
          getter_Copies(protocolVersion));
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	Fri Feb 13 21:09:27 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	Thu Mar 29 14:27:08 2007
***************
*** 74,80 ****
          PRInt32 resultLimit = -1,
          PRInt32 timeOut = 0);
      virtual ~nsAbQueryLDAPMessageListener ();
! 
  protected:
      nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
      nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
--- 74,80 ----
          PRInt32 resultLimit = -1,
          PRInt32 timeOut = 0);
      virtual ~nsAbQueryLDAPMessageListener ();
!     void SetPassword(const nsAString& aPassword){m_sPassword = aPassword;};
  protected:
      nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
      nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
***************
*** 105,110 ****
--- 105,112 ----
      PRBool mInitialized;
      PRBool mCanceled;
  
+     nsAutoString m_sPassword;
+ 
      nsCOMPtr<nsILDAPOperation> mSearchOperation;
  
      PRLock* mLock;
***************
*** 255,261 ****
  
      // If mLogin is set, we're expected to use it to get a password.
      //
!     if (!mDirectoryQuery->mLogin.IsEmpty()) {
  // XXX hack until nsUTF8AutoString exists
  #define nsUTF8AutoString nsCAutoString
          nsUTF8AutoString spec;
--- 257,263 ----
  
      // If mLogin is set, we're expected to use it to get a password.
      //
!     if (!mDirectoryQuery->mLogin.IsEmpty() && !m_sPassword.Length()) {
  // XXX hack until nsUTF8AutoString exists
  #define nsUTF8AutoString nsCAutoString
          nsUTF8AutoString spec;
***************
*** 398,407 ****
      rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
      NS_ENSURE_SUCCESS(rv, rv);
  
!     // Bind
!     rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
      NS_ENSURE_SUCCESS(rv, rv);
- 
      return rv;
  }
  
--- 400,412 ----
      rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
      NS_ENSURE_SUCCESS(rv, rv);
  
! 	
! 	// Bind
!     if (m_sPassword.Length())
! 		rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(m_sPassword));
! 	else
! 	    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
      NS_ENSURE_SUCCESS(rv, rv);
      return rv;
  }
  
***************
*** 685,691 ****
      rv = getLdapReturnAttributes (arguments, returnAttributes);
      NS_ENSURE_SUCCESS(rv, rv);
  
! 
      // Get the filter
      nsCOMPtr<nsISupports> supportsExpression;
      rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
--- 690,696 ----
      rv = getLdapReturnAttributes (arguments, returnAttributes);
      NS_ENSURE_SUCCESS(rv, rv);
  
!     
      // Get the filter
      nsCOMPtr<nsISupports> supportsExpression;
      rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
***************
*** 811,816 ****
--- 816,826 ----
                  timeOut);
      if (_messageListener == NULL)
              return NS_ERROR_OUT_OF_MEMORY;
+     
+     nsAutoString wPassword;
+     wPassword.AssignWithConversion(mPassword.get());
+     _messageListener->SetPassword(wPassword);
+ 
      messageListener = _messageListener;
      nsVoidKey key (NS_REINTERPRET_CAST(void *,contextID));
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	Fri Feb 13 21:09:27 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	Thu Mar 29 14:27:08 2007
***************
*** 74,79 ****
--- 74,80 ----
      nsresult RemoveListener (PRInt32 contextID);
      nsresult Initiate ();
      nsXPIDLCString mLogin; // authenticate to the LDAP server as...
+     nsXPIDLCString mPassword; // password to the LDAP server as...
      nsCOMPtr<nsILDAPURL> mDirectoryUrl; // the URL for the server
      PRUint32 mProtocolVersion; // version of LDAP (see nsILDAPConnection.idl)
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	Sat Mar 22 11:43:29 2003
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	Thu Mar 29 14:27:08 2007
***************
*** 39,44 ****
--- 39,45 ----
  #include "nsAbLDAPProperties.h"
  
  #include "nsAbUtils.h"
+ #include "nsCRT.h"
  
  #include "nsCOMPtr.h"
  #include "nsString.h"
***************
*** 59,64 ****
--- 60,80 ----
      If there are multiple entries for a mozilla
      property the first takes precedence.
  
+     But where we need to do a query against 
+     a multiple occurring ldap attribute we 
+     need to OR all the possible ldap entries e.g.
+ 
+     (CellularNumber=123456) translates to 
+     (|(mobile=123456)(&(!(mobile=*))(cellphone=123456))(&(!(mobile=*))(!(cellphone=*))(carphone=123456)))
+ 
+     i.e. use the first occurring attribute otherwise if 
+     first does not exist use the second etc.
+ 
+     [Multiple occurring ldap attributes do not
+     include aliases. We have also ignored the case 
+     for including 'displayname' as the first occurring
+     attribute 'cn' is a required attribute.] 
+ 
      This ensures that
      
          1) Generality is maintained when mapping from
***************
*** 101,152 ****
      {MozillaProperty_String, "FaxNumber",        "fax"},
      // organizationalPerson
      {MozillaProperty_String, "FaxNumber",        "facsimiletelephonenumber"},
!     // inetOrgPerson
!     {MozillaProperty_String, "PagerNumber",        "pager"},
!     // ?
!     {MozillaProperty_String, "PagerNumber",        "pagerphone"},
!     // inetOrgPerson
!     {MozillaProperty_String, "CellularNumber",    "mobile"},
!     // ?
!     {MozillaProperty_String, "CellularNumber",    "cellphone"},
!     // ?
!     {MozillaProperty_String, "CellularNumber",    "carphone"},
  
      // No Home* properties defined yet
  
!     // organizationalPerson
!     {MozillaProperty_String, "WorkAddress",        "postofficebox"},
!     // ?
!     {MozillaProperty_String, "WorkAddress",        "streetaddress"},
      // ?
      {MozillaProperty_String, "WorkCity",        "l"},
      // ?
      {MozillaProperty_String, "WorkCity",        "locality"},
      // ?
!     {MozillaProperty_String, "WorkState",        "st"},
!     // ?
!     {MozillaProperty_String, "WorkState",        "region"},
!     // organizationalPerson
!     {MozillaProperty_String, "WorkZipCode",        "postalcode"},
!     // ?
!     {MozillaProperty_String, "WorkZipCode",        "zip"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
  
      // organizationalPerson
      {MozillaProperty_String, "JobTitle",        "title"},
      // ?
!     {MozillaProperty_String, "Department",        "ou"},
!     // ?
!     {MozillaProperty_String, "Department",        "orgunit"},
!     // ?
!     {MozillaProperty_String, "Department",        "department"},
!     // ?
!     {MozillaProperty_String, "Department",        "departmentnumber"},
!     // inetOrgPerson
!     {MozillaProperty_String, "Company",        "o"},
!     // ?
!     {MozillaProperty_String, "Company",        "company"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
      // ?
--- 117,148 ----
      {MozillaProperty_String, "FaxNumber",        "fax"},
      // organizationalPerson
      {MozillaProperty_String, "FaxNumber",        "facsimiletelephonenumber"},
!     // inetOrgPerson,?
!     {MozillaProperty_String, "PagerNumber",        "pager,pagerphone"},
!     // inetOrgPerson,?,?
!     {MozillaProperty_String, "CellularNumber",    "mobile,cellphone,carphone"},
  
      // No Home* properties defined yet
  
!     // organizationalPerson,?
!     {MozillaProperty_String, "WorkAddress",        "postofficebox,streetaddress"},
      // ?
      {MozillaProperty_String, "WorkCity",        "l"},
      // ?
      {MozillaProperty_String, "WorkCity",        "locality"},
      // ?
!     {MozillaProperty_String, "WorkState",        "st,region"},
!     // organizationalPerson,?
!     {MozillaProperty_String, "WorkZipCode",        "postalcode,zip"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
  
      // organizationalPerson
      {MozillaProperty_String, "JobTitle",        "title"},
      // ?
!     {MozillaProperty_String, "Department",      "ou,orgunit,department,departmentnumber"},
!    // inetOrgPerson,?
!     {MozillaProperty_String, "Company",        "o,company"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
      // ?
***************
*** 168,177 ****
      // ?
      {MozillaProperty_String, "Custom4",        "custom4"},
  
!     // ?
!     {MozillaProperty_String, "Notes",        "notes"},
!     // person
!     {MozillaProperty_String, "Notes",        "description"},
  
      // mozilla specfic
      {MozillaProperty_Int, "PreferMailFormat",    "xmozillausehtmlmail"},
--- 164,171 ----
      // ?
      {MozillaProperty_String, "Custom4",        "custom4"},
  
!     // ?,person
!     {MozillaProperty_String, "Notes",        "notes,description"},
  
      // mozilla specfic
      {MozillaProperty_Int, "PreferMailFormat",    "xmozillausehtmlmail"},
***************
*** 209,218 ****
      if (IsInitialized) { return ; }
  
      for (int i = tableSize - 1 ; i >= 0 ; -- i) {
-         nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
-         nsCStringKey keyLdap (table [i].ldapProperty, -1, nsCStringKey::NEVER_OWN);
  
          mLdapToMozilla.Put(&keyLdap, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
          mMozillaToLdap.Put(&keyMozilla, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
      }
      IsInitialized = PR_TRUE;
--- 203,224 ----
      if (IsInitialized) { return ; }
  
      for (int i = tableSize - 1 ; i >= 0 ; -- i) {
  
+         char *attrToken = nsnull;
+         char *LDAPProperty = nsCRT::strdup(table[i].ldapProperty);
+         char *tmpLDAPProperty;
+ 
+         attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+         while (attrToken != nsnull)
+         {
+             while ( ' ' == *attrToken) 
+                 attrToken++;
+             nsCStringKey keyLdap (attrToken, -1, nsCStringKey::NEVER_OWN);
          mLdapToMozilla.Put(&keyLdap, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
+             attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+         }
+ 
+         nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
          mMozillaToLdap.Put(&keyMozilla, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
      }
      IsInitialized = PR_TRUE;
***************
*** 234,243 ****
  const MozillaLdapPropertyRelation* MozillaLdapPropertyRelator::findMozillaPropertyFromLdap (const char* ldapProperty)
  {
      Initialize();
      // ensure that we always do a case insensitive comparison
      // against the incoming ldap attributes.
!     nsCAutoString lowercasedProp(ldapProperty);
!     ToLowerCase(nsDependentCString(ldapProperty), lowercasedProp);
      nsCStringKey key(lowercasedProp);
  
      return NS_REINTERPRET_CAST(const MozillaLdapPropertyRelation *, mLdapToMozilla.Get(&key)) ;
--- 240,252 ----
  const MozillaLdapPropertyRelation* MozillaLdapPropertyRelator::findMozillaPropertyFromLdap (const char* ldapProperty)
  {
      Initialize();
+     char *attrToken;
+     char *tmpLDAPProperty;
+     attrToken = nsCRT::strtok(NS_CONST_CAST(char *,ldapProperty), ",", &tmpLDAPProperty);
      // ensure that we always do a case insensitive comparison
      // against the incoming ldap attributes.
!     nsCAutoString lowercasedProp (attrToken) ;
!     ToLowerCase(nsDependentCString(attrToken),lowercasedProp);
      nsCStringKey key(lowercasedProp);
  
      return NS_REINTERPRET_CAST(const MozillaLdapPropertyRelation *, mLdapToMozilla.Get(&key)) ;
***************
*** 289,291 ****
--- 298,361 ----
  
      return rv;
  }
+ 
+ // Parse the input string which may contain a single ldap attribute or multiple attributes in the form
+ // "string" or "string1,string2,string3" respectively and assign to the array.
+ nsresult MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes)
+ {
+     NS_ENSURE_ARG_POINTER(aAttrCount);
+     NS_ENSURE_ARG_POINTER(aAttributes);
+ 
+     nsresult rv = NS_OK;
+ 
+     *aAttributes = 0;
+     // we must have at least one attribute 
+     *aAttrCount = 1;
+ 
+     // if no multiple ldap attributes then allocate our single entry and exit
+     if (!strchr(aLDAPProperty,','))
+     {
+         if (!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(sizeof(char *)))))
+             return NS_ERROR_OUT_OF_MEMORY;
+         if (!((*aAttributes)[0] = nsCRT::strdup(aLDAPProperty)))
+             return NS_ERROR_OUT_OF_MEMORY;
+ 
+         return rv;
+     }
+ 
+     char *attrToken = nsnull;
+     char *LDAPProperty = nsnull;
+     char *tmpLDAPProperty;
+ 
+     if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     // set our tokenizer to the start 
+     attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty); 
+ 
+     // Count up the attribute names 
+     while ((attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty)) != nsnull)
+         *aAttrCount += 1;
+ 
+     nsCRT::free (LDAPProperty);
+     if(!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(*aAttrCount * sizeof(char *)))))
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     PRInt32 j = 0;
+     attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+     while (nsnull != attrToken) {
+         if(((*aAttributes)[j++] = nsCRT::strdup(attrToken)) == nsnull)
+         {
+             nsCRT::free(LDAPProperty);
+             return NS_ERROR_OUT_OF_MEMORY;
+         }
+ 		
+         attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+     }
+ 
+     nsCRT::free(LDAPProperty);
+     return rv;
+ }
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	Tue Apr  9 05:27:24 2002
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	Thu Mar 29 14:27:08 2007
***************
*** 85,90 ****
--- 85,91 ----
      static nsresult createCardPropertyFromLDAPMessage (nsILDAPMessage* message,
              nsIAbCard* card,
              PRBool* hasSetCardProperty);
+     static nsresult getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes);
  };
  
  #endif
*** misc/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	Thu Mar 29 14:34:48 2007
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	Thu Mar 29 14:27:08 2007
***************
*** 1 ****
! dummy
--- 1,633 ----
! /*
!  * The contents of this file are subject to the Mozilla Public
!  * License Version 1.1 (the "License"); you may not use this file
!  * except in compliance with the License. You may obtain a copy of
!  * the License at http://www.mozilla.org/MPL/
!  * 
!  * Software distributed under the License is distributed on an "AS
!  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
!  * implied. See the License for the specific language governing
!  * rights and limitations under the License.
!  * 
!  * The Original Code is the Netscape security libraries.
!  * 
!  * The Initial Developer of the Original Code is Netscape
!  * Communications Corporation.	Portions created by Netscape are 
!  * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
!  * Rights Reserved.
!  * 
!  * Contributor(s):
!  * 
!  * Alternatively, the contents of this file may be used under the
!  * terms of the GNU General Public License Version 2 or later (the
!  * "GPL"), in which case the provisions of the GPL are applicable 
!  * instead of those above.	If you wish to allow use of your 
!  * version of this file only under the terms of the GPL and not to
!  * allow others to use your version of this file under the MPL,
!  * indicate your decision by deleting the provisions above and
!  * replace them with the notice and other provisions required by
!  * the GPL.  If you do not delete the provisions above, a recipient
!  * may use your version of this file under either the MPL or the
!  * GPL.
!  */
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include "prerr.h"
! 
! #include "prtypes.h"
! #include "prlong.h"
! #include "plstr.h"
! #include "nsMemory.h"
! 
! #define MD5_HASH_LEN 16
! #define MD5_BUFFER_SIZE 64
! #define MD5_END_BUFFER (MD5_BUFFER_SIZE - 8)
! 
! #define CV0_1 0x67452301
! #define CV0_2 0xefcdab89
! #define CV0_3 0x98badcfe
! #define CV0_4 0x10325476
! 
! #define T1_0  0xd76aa478
! #define T1_1  0xe8c7b756
! #define T1_2  0x242070db
! #define T1_3  0xc1bdceee
! #define T1_4  0xf57c0faf
! #define T1_5  0x4787c62a
! #define T1_6  0xa8304613
! #define T1_7  0xfd469501
! #define T1_8  0x698098d8
! #define T1_9  0x8b44f7af
! #define T1_10 0xffff5bb1
! #define T1_11 0x895cd7be
! #define T1_12 0x6b901122
! #define T1_13 0xfd987193
! #define T1_14 0xa679438e
! #define T1_15 0x49b40821
! 
! #define T2_0  0xf61e2562
! #define T2_1  0xc040b340
! #define T2_2  0x265e5a51
! #define T2_3  0xe9b6c7aa
! #define T2_4  0xd62f105d
! #define T2_5  0x02441453
! #define T2_6  0xd8a1e681
! #define T2_7  0xe7d3fbc8
! #define T2_8  0x21e1cde6
! #define T2_9  0xc33707d6
! #define T2_10 0xf4d50d87
! #define T2_11 0x455a14ed
! #define T2_12 0xa9e3e905
! #define T2_13 0xfcefa3f8
! #define T2_14 0x676f02d9
! #define T2_15 0x8d2a4c8a
! 
! #define T3_0  0xfffa3942
! #define T3_1  0x8771f681
! #define T3_2  0x6d9d6122
! #define T3_3  0xfde5380c
! #define T3_4  0xa4beea44
! #define T3_5  0x4bdecfa9
! #define T3_6  0xf6bb4b60
! #define T3_7  0xbebfbc70
! #define T3_8  0x289b7ec6
! #define T3_9  0xeaa127fa
! #define T3_10 0xd4ef3085
! #define T3_11 0x04881d05
! #define T3_12 0xd9d4d039
! #define T3_13 0xe6db99e5
! #define T3_14 0x1fa27cf8
! #define T3_15 0xc4ac5665
! 
! #define T4_0  0xf4292244
! #define T4_1  0x432aff97
! #define T4_2  0xab9423a7
! #define T4_3  0xfc93a039
! #define T4_4  0x655b59c3
! #define T4_5  0x8f0ccc92
! #define T4_6  0xffeff47d
! #define T4_7  0x85845dd1
! #define T4_8  0x6fa87e4f
! #define T4_9  0xfe2ce6e0
! #define T4_10 0xa3014314
! #define T4_11 0x4e0811a1
! #define T4_12 0xf7537e82
! #define T4_13 0xbd3af235
! #define T4_14 0x2ad7d2bb
! #define T4_15 0xeb86d391
! 
! #define R1B0  0
! #define R1B1  1
! #define R1B2  2
! #define R1B3  3
! #define R1B4  4
! #define R1B5  5
! #define R1B6  6
! #define R1B7  7
! #define R1B8  8
! #define R1B9  9
! #define R1B10 10
! #define R1B11 11
! #define R1B12 12
! #define R1B13 13
! #define R1B14 14
! #define R1B15 15
! 
! #define R2B0  1
! #define R2B1  6
! #define R2B2  11
! #define R2B3  0
! #define R2B4  5
! #define R2B5  10
! #define R2B6  15
! #define R2B7  4
! #define R2B8  9
! #define R2B9  14
! #define R2B10 3 
! #define R2B11 8 
! #define R2B12 13
! #define R2B13 2 
! #define R2B14 7 
! #define R2B15 12
! 
! #define R3B0  5
! #define R3B1  8
! #define R3B2  11
! #define R3B3  14
! #define R3B4  1
! #define R3B5  4
! #define R3B6  7
! #define R3B7  10
! #define R3B8  13
! #define R3B9  0
! #define R3B10 3 
! #define R3B11 6 
! #define R3B12 9 
! #define R3B13 12
! #define R3B14 15
! #define R3B15 2 
! 
! #define R4B0  0
! #define R4B1  7
! #define R4B2  14
! #define R4B3  5
! #define R4B4  12
! #define R4B5  3
! #define R4B6  10
! #define R4B7  1
! #define R4B8  8
! #define R4B9  15
! #define R4B10 6 
! #define R4B11 13
! #define R4B12 4 
! #define R4B13 11
! #define R4B14 2 
! #define R4B15 9 
! 
! #define S1_0 7
! #define S1_1 12
! #define S1_2 17
! #define S1_3 22
! 
! #define S2_0 5
! #define S2_1 9
! #define S2_2 14
! #define S2_3 20
! 
! #define S3_0 4
! #define S3_1 11
! #define S3_2 16
! #define S3_3 23
! 
! #define S4_0 6
! #define S4_1 10
! #define S4_2 15
! #define S4_3 21
! 
! struct MD5ContextStr {
! 	PRUint32      lsbInput;
! 	PRUint32      msbInput;
! 	PRUint32      cv[4];
! 	union {
! 		PRUint8 b[64];
! 		PRUint32 w[16];
! 	} u;
! };
! typedef struct MD5ContextStr        MD5Context;
! 
! #define inBuf u.b
! 
! int MD5_Hash(unsigned char *dest, const char *src);
! int MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length);
! MD5Context * MD5_NewContext(void);
! void MD5_DestroyContext(MD5Context *cx, PRBool freeit);
! void MD5_Begin(MD5Context *cx);
! static void md5_compress(MD5Context *cx);
! void MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen);
! void MD5_End(MD5Context *cx, unsigned char *digest,
!         unsigned int *digestLen, unsigned int maxDigestLen);
! unsigned int MD5_FlattenSize(MD5Context *cx);
! int MD5_Flatten(MD5Context *cx, unsigned char *space);
! MD5Context * MD5_Resurrect(unsigned char *space, void *arg);
! void MD5_TraceState(MD5Context *cx);
! 
! int 
! MD5_Hash(unsigned char *dest, const char *src)
! {
! 	return MD5_HashBuf(dest, (unsigned char *)src, PL_strlen(src));
! }
! 
! int 
! MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length)
! {
! 	unsigned int len;
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return -1;
! 	}
! 	MD5_Begin(cx);
! 	MD5_Update(cx, src, src_length);
! 	MD5_End(cx, dest, &len, MD5_HASH_LEN);
! 	MD5_DestroyContext(cx, PR_TRUE);
! 	return 0;
! }
! 
! MD5Context *
! MD5_NewContext(void)
! {
! 	MD5Context *cx = (MD5Context *)malloc(sizeof(MD5Context));
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return NULL;
! 	}
! 	return cx;
! }
! 
! void 
! MD5_DestroyContext(MD5Context *cx, PRBool freeit)
! {
! 	if (freeit) {
! 		free(cx);
! 	}
! }
! 
! void 
! MD5_Begin(MD5Context *cx)
! {
! 	cx->lsbInput = 0;
! 	cx->msbInput = 0;
! 	memset(cx->inBuf, 0, sizeof(cx->inBuf));
! 	cx->cv[0] = CV0_1;
! 	cx->cv[1] = CV0_2;
! 	cx->cv[2] = CV0_3;
! 	cx->cv[3] = CV0_4;
! }
! 
! #define cls(i32, s) (tmp = i32, tmp << s | tmp >> (32 - s))
! 
! #define MASK 0x00ff00ff
! #ifdef IS_LITTLE_ENDIAN
! #define lendian(i32) \
! 	(i32)
! #else
! #define lendian(i32) \
! 	(tmp = i32 >> 16 | i32 << 16, (tmp & MASK) << 8 | tmp >> 8 & MASK)
! #endif
! 
! #if defined(SOLARIS) || defined(HPUX)
! #define addto64(sumhigh, sumlow, addend) \
! 	sumlow += addend; sumhigh += (sumlow < addend);
! #else
! #define addto64(sumhigh, sumlow, addend) \
! 	sumlow += addend; if (sumlow < addend) ++sumhigh;
! #endif
! 
! #define F(X, Y, Z) \
! 	((X & Y) | ((~X) & Z))
! 
! #define G(X, Y, Z) \
! 	((X & Z) | (Y & (~Z)))
! 
! #define H(X, Y, Z) \
! 	(X ^ Y ^ Z)
! 
! #define I(X, Y, Z) \
! 	(Y ^ (X | (~Z)))
! 
! #define FF(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + F(b, c, d) + bufint + ti, s)
! 
! #define GG(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + G(b, c, d) + bufint + ti, s)
! 
! #define HH(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + H(b, c, d) + bufint + ti, s)
! 
! #define II(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + I(b, c, d) + bufint + ti, s)
! 
! static void
! md5_compress(MD5Context *cx)
! {
! 	PRUint32 a, b, c, d;
! 	PRUint32 tmp;
! 	a = cx->cv[0];
! 	b = cx->cv[1];
! 	c = cx->cv[2];
! 	d = cx->cv[3];
! #ifndef IS_LITTLE_ENDIAN
! 	cx->u.w[0] = lendian(cx->u.w[0]);
! 	cx->u.w[1] = lendian(cx->u.w[1]);
! 	cx->u.w[2] = lendian(cx->u.w[2]);
! 	cx->u.w[3] = lendian(cx->u.w[3]);
! 	cx->u.w[4] = lendian(cx->u.w[4]);
! 	cx->u.w[5] = lendian(cx->u.w[5]);
! 	cx->u.w[6] = lendian(cx->u.w[6]);
! 	cx->u.w[7] = lendian(cx->u.w[7]);
! 	cx->u.w[8] = lendian(cx->u.w[8]);
! 	cx->u.w[9] = lendian(cx->u.w[9]);
! 	cx->u.w[10] = lendian(cx->u.w[10]);
! 	cx->u.w[11] = lendian(cx->u.w[11]);
! 	cx->u.w[12] = lendian(cx->u.w[12]);
! 	cx->u.w[13] = lendian(cx->u.w[13]);
! 	cx->u.w[14] = lendian(cx->u.w[14]);
! 	cx->u.w[15] = lendian(cx->u.w[15]);
! #endif
! 	FF(a, b, c, d, cx->u.w[R1B0 ], S1_0, T1_0);
! 	FF(d, a, b, c, cx->u.w[R1B1 ], S1_1, T1_1);
! 	FF(c, d, a, b, cx->u.w[R1B2 ], S1_2, T1_2);
! 	FF(b, c, d, a, cx->u.w[R1B3 ], S1_3, T1_3);
! 	FF(a, b, c, d, cx->u.w[R1B4 ], S1_0, T1_4);
! 	FF(d, a, b, c, cx->u.w[R1B5 ], S1_1, T1_5);
! 	FF(c, d, a, b, cx->u.w[R1B6 ], S1_2, T1_6);
! 	FF(b, c, d, a, cx->u.w[R1B7 ], S1_3, T1_7);
! 	FF(a, b, c, d, cx->u.w[R1B8 ], S1_0, T1_8);
! 	FF(d, a, b, c, cx->u.w[R1B9 ], S1_1, T1_9);
! 	FF(c, d, a, b, cx->u.w[R1B10], S1_2, T1_10);
! 	FF(b, c, d, a, cx->u.w[R1B11], S1_3, T1_11);
! 	FF(a, b, c, d, cx->u.w[R1B12], S1_0, T1_12);
! 	FF(d, a, b, c, cx->u.w[R1B13], S1_1, T1_13);
! 	FF(c, d, a, b, cx->u.w[R1B14], S1_2, T1_14);
! 	FF(b, c, d, a, cx->u.w[R1B15], S1_3, T1_15);
! 	GG(a, b, c, d, cx->u.w[R2B0 ], S2_0, T2_0);
! 	GG(d, a, b, c, cx->u.w[R2B1 ], S2_1, T2_1);
! 	GG(c, d, a, b, cx->u.w[R2B2 ], S2_2, T2_2);
! 	GG(b, c, d, a, cx->u.w[R2B3 ], S2_3, T2_3);
! 	GG(a, b, c, d, cx->u.w[R2B4 ], S2_0, T2_4);
! 	GG(d, a, b, c, cx->u.w[R2B5 ], S2_1, T2_5);
! 	GG(c, d, a, b, cx->u.w[R2B6 ], S2_2, T2_6);
! 	GG(b, c, d, a, cx->u.w[R2B7 ], S2_3, T2_7);
! 	GG(a, b, c, d, cx->u.w[R2B8 ], S2_0, T2_8);
! 	GG(d, a, b, c, cx->u.w[R2B9 ], S2_1, T2_9);
! 	GG(c, d, a, b, cx->u.w[R2B10], S2_2, T2_10);
! 	GG(b, c, d, a, cx->u.w[R2B11], S2_3, T2_11);
! 	GG(a, b, c, d, cx->u.w[R2B12], S2_0, T2_12);
! 	GG(d, a, b, c, cx->u.w[R2B13], S2_1, T2_13);
! 	GG(c, d, a, b, cx->u.w[R2B14], S2_2, T2_14);
! 	GG(b, c, d, a, cx->u.w[R2B15], S2_3, T2_15);
! 	HH(a, b, c, d, cx->u.w[R3B0 ], S3_0, T3_0);
! 	HH(d, a, b, c, cx->u.w[R3B1 ], S3_1, T3_1);
! 	HH(c, d, a, b, cx->u.w[R3B2 ], S3_2, T3_2);
! 	HH(b, c, d, a, cx->u.w[R3B3 ], S3_3, T3_3);
! 	HH(a, b, c, d, cx->u.w[R3B4 ], S3_0, T3_4);
! 	HH(d, a, b, c, cx->u.w[R3B5 ], S3_1, T3_5);
! 	HH(c, d, a, b, cx->u.w[R3B6 ], S3_2, T3_6);
! 	HH(b, c, d, a, cx->u.w[R3B7 ], S3_3, T3_7);
! 	HH(a, b, c, d, cx->u.w[R3B8 ], S3_0, T3_8);
! 	HH(d, a, b, c, cx->u.w[R3B9 ], S3_1, T3_9);
! 	HH(c, d, a, b, cx->u.w[R3B10], S3_2, T3_10);
! 	HH(b, c, d, a, cx->u.w[R3B11], S3_3, T3_11);
! 	HH(a, b, c, d, cx->u.w[R3B12], S3_0, T3_12);
! 	HH(d, a, b, c, cx->u.w[R3B13], S3_1, T3_13);
! 	HH(c, d, a, b, cx->u.w[R3B14], S3_2, T3_14);
! 	HH(b, c, d, a, cx->u.w[R3B15], S3_3, T3_15);
! 	II(a, b, c, d, cx->u.w[R4B0 ], S4_0, T4_0);
! 	II(d, a, b, c, cx->u.w[R4B1 ], S4_1, T4_1);
! 	II(c, d, a, b, cx->u.w[R4B2 ], S4_2, T4_2);
! 	II(b, c, d, a, cx->u.w[R4B3 ], S4_3, T4_3);
! 	II(a, b, c, d, cx->u.w[R4B4 ], S4_0, T4_4);
! 	II(d, a, b, c, cx->u.w[R4B5 ], S4_1, T4_5);
! 	II(c, d, a, b, cx->u.w[R4B6 ], S4_2, T4_6);
! 	II(b, c, d, a, cx->u.w[R4B7 ], S4_3, T4_7);
! 	II(a, b, c, d, cx->u.w[R4B8 ], S4_0, T4_8);
! 	II(d, a, b, c, cx->u.w[R4B9 ], S4_1, T4_9);
! 	II(c, d, a, b, cx->u.w[R4B10], S4_2, T4_10);
! 	II(b, c, d, a, cx->u.w[R4B11], S4_3, T4_11);
! 	II(a, b, c, d, cx->u.w[R4B12], S4_0, T4_12);
! 	II(d, a, b, c, cx->u.w[R4B13], S4_1, T4_13);
! 	II(c, d, a, b, cx->u.w[R4B14], S4_2, T4_14);
! 	II(b, c, d, a, cx->u.w[R4B15], S4_3, T4_15);
! 	cx->cv[0] += a;
! 	cx->cv[1] += b;
! 	cx->cv[2] += c;
! 	cx->cv[3] += d;
! }
! 
! void 
! MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen)
! {
! 	PRUint32 bytesToConsume;
! 	PRUint32 inBufIndex = cx->lsbInput & 63;
! 
! 	/* Add the number of input bytes to the 64-bit input counter. */
! 	addto64(cx->msbInput, cx->lsbInput, inputLen);
! 	if (inBufIndex) {
! 		/* There is already data in the buffer.  Fill with input. */
! 		bytesToConsume = PR_MIN(inputLen, MD5_BUFFER_SIZE - inBufIndex);
! 		memcpy(&cx->inBuf[inBufIndex], input, bytesToConsume);
! 		if (inBufIndex + bytesToConsume >= MD5_BUFFER_SIZE)
! 			/* The buffer is filled.  Run the compression function. */
! 			md5_compress(cx);
! 		/* Remaining input. */
! 		inputLen -= bytesToConsume;
! 		input += bytesToConsume;
! 	}
! 
! 	/* Iterate over 64-byte chunks of the message. */
! 	while (inputLen >= MD5_BUFFER_SIZE) {
! 		memcpy(cx->inBuf, input, MD5_BUFFER_SIZE);
! 		md5_compress(cx);
! 		inputLen -= MD5_BUFFER_SIZE;
! 		input += MD5_BUFFER_SIZE;
! 	}
! 
! 	/* Tail of message (message bytes mod 64). */
! 	if (inputLen)
! 		memcpy(cx->inBuf, input, inputLen);
! }
! 
! static const unsigned char padbytes[] = {
! 	0x80, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00
! };
! 
! void 
! MD5_End(MD5Context *cx, unsigned char *digest,
!         unsigned int *digestLen, unsigned int maxDigestLen)
! {
! #ifndef IS_LITTLE_ENDIAN
! 	PRUint32 tmp;
! #endif
! 	PRUint32 lowInput, highInput;
! 	PRUint32 inBufIndex = cx->lsbInput & 63;
! 
! 	if (maxDigestLen < MD5_HASH_LEN) {
! //		PORT_SetError(SEC_ERROR_INVALID_ARGS);
! 		return;
! 	}
! 
! 	/* Copy out the length of bits input before padding. */
! 	lowInput = cx->lsbInput; 
! 	highInput = (cx->msbInput << 3) | (lowInput >> 29);
! 	lowInput <<= 3;
! 
! 	if (inBufIndex < MD5_END_BUFFER) {
! 		MD5_Update(cx, padbytes, MD5_END_BUFFER - inBufIndex);
! 	} else {
! 		MD5_Update(cx, padbytes, 
! 		           MD5_END_BUFFER + MD5_BUFFER_SIZE - inBufIndex);
! 	}
! 
! 	/* Store the number of bytes input (before padding) in final 64 bits. */
! 	cx->u.w[14] = lendian(lowInput);
! 	cx->u.w[15] = lendian(highInput);
! 
! 	/* Final call to compress. */
! 	md5_compress(cx);
! 
! 	/* Copy the resulting values out of the chain variables into return buf. */
! 	*digestLen = MD5_HASH_LEN;
! #ifndef IS_LITTLE_ENDIAN
! 	cx->cv[0] = lendian(cx->cv[0]);
! 	cx->cv[1] = lendian(cx->cv[1]);
! 	cx->cv[2] = lendian(cx->cv[2]);
! 	cx->cv[3] = lendian(cx->cv[3]);
! #endif
! 	memcpy(digest, cx->cv, MD5_HASH_LEN);
! }
! 
! unsigned int 
! MD5_FlattenSize(MD5Context *cx)
! {
! 	return sizeof(*cx);
! }
! 
! int 
! MD5_Flatten(MD5Context *cx, unsigned char *space)
! {
! 	memcpy(space, cx, sizeof(*cx));
! 	return 0;
! }
! 
! MD5Context * 
! MD5_Resurrect(unsigned char *space, void *arg)
! {
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx)
! 		memcpy(cx, space, sizeof(*cx));
! 	return cx;
! }
! 
! void 
! MD5_TraceState(MD5Context *cx)
! {
! //	PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
! }
! 
! int
! md5_stream (FILE *stream, unsigned char *dest)
! {
!   /* Important: BLOCKSIZE must be a multiple of 64.  */
! #define BLOCKSIZE 4096
! 	unsigned int len;
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return -1;
! 	}
! 
!   unsigned char buffer[BLOCKSIZE + 72];
!   size_t sum;
! 
!   /* Initialize the computation context.  */
!   MD5_Begin(cx);
! 
!   /* Iterate over full file contents.  */
!   while (1)
!     {
!       /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
! 	 computation function processes the whole buffer so that with the
! 	 next round of the loop another block can be read.  */
!       size_t n;
!       sum = 0;
! 
!       /* Read block.  Take care for partial reads.  */
!       do
! 	{
! 	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
! 
! 	  sum += n;
! 	}
!       while (sum < BLOCKSIZE && n != 0);
!       if (n == 0 && ferror (stream))
!         return 1;
! 
!       /* If end of file is reached, end the loop.  */
!       if (n == 0)
! 	break;
! 
!       /* Process buffer with BLOCKSIZE bytes.  Note that
! 			BLOCKSIZE % 64 == 0
!        */
! 	MD5_Update(cx, buffer, BLOCKSIZE);
!     }
! 
!   /* Add the last bytes if necessary.  */
!   if (sum > 0)
! 	MD5_Update(cx, buffer, sum);
! 
! 	MD5_End(cx, dest, &len, MD5_HASH_LEN);
! 	MD5_DestroyContext(cx, PR_TRUE);
! 	return len;
! 
! }
! 
! int getMD5sum(const char * fileName,char * sum)
! {
! 	unsigned char bin_sum[16];
! 	int len=0;
! 	if (fileName)
! 	{
! 		FILE *fp=fopen(fileName,"rb");
! 		if (fp)
! 		{
! 			len=md5_stream(fp,bin_sum);
! 			memset(sum,0,33);
! 			for (int i = 0; i < len; ++i)
! 				sprintf (sum,"%s%02x",sum, bin_sum[i]);
! 			fclose(fp);
! 			return 0;
! 		}
! 	}
! 	return 1;
! }
! 
! int testMD5sum(const char * fileName,char * sum)
! {
! 	char newSum[33]="";
! 	if (getMD5sum(fileName,newSum))
! 		return 1;
! 	return strcmp(newSum,sum);
! }
*** misc/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	Tue Nov 12 14:19:56 2002
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	Thu Mar 29 14:27:08 2007
***************
*** 266,273 ****
  	if (mCardDatabase)
  	{
  		mCardDatabase->EditCard(this, PR_TRUE);
!     mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
! 		return NS_OK;
  	}
  	else
  		return NS_ERROR_FAILURE;
--- 266,272 ----
  	if (mCardDatabase)
  	{
  		mCardDatabase->EditCard(this, PR_TRUE);
! 		return mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  	}
  	else
  		return NS_ERROR_FAILURE;
*** misc/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	Tue Mar  9 09:42:24 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	Thu Mar 29 14:27:08 2007
***************
*** 537,543 ****
          }
        }
      }
!     mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
    }
    return rv;
  }
--- 537,543 ----
          }
        }
      }
!     rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
    }
    return rv;
  }
***************
*** 684,689 ****
--- 684,690 ----
      return NS_ERROR_NOT_IMPLEMENTED;
  
    nsresult rv = NS_OK;
+ 
    if (!mDatabase)
      rv = GetAbDatabase();
  
***************
*** 713,722 ****
      mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE);
    else
      mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
!   mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  
    NS_IF_ADDREF(*addedCard = newCard);
!   return NS_OK;
  }
  
  NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
--- 714,724 ----
      mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE);
    else
      mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
!   rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  
+   NS_ENSURE_SUCCESS(rv, rv);
    NS_IF_ADDREF(*addedCard = newCard);
!   return rv;
  }
  
  NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	Tue Mar  9 10:18:40 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	Thu Mar 29 14:27:08 2007
***************
*** 97,102 ****
--- 97,103 ----
  {
      index_DisplayName = 0,
      index_EmailAddress,
+     index_SecondEmailAddress,
      index_FirstName,
      index_LastName,
      index_NickName,
***************
*** 124,155 ****
  
  static const ULONG OutlookCardMAPIProps [] = 
  {
!     PR_DISPLAY_NAME_W,
!     PR_EMAIL_ADDRESS_W,
!     PR_GIVEN_NAME_W,
!     PR_SURNAME_W,
!     PR_NICKNAME_W,
!     PR_BUSINESS_TELEPHONE_NUMBER_W,
!     PR_HOME_TELEPHONE_NUMBER_W,
!     PR_BUSINESS_FAX_NUMBER_W,
!     PR_PAGER_TELEPHONE_NUMBER_W,
!     PR_MOBILE_TELEPHONE_NUMBER_W,
!     PR_HOME_ADDRESS_CITY_W,
!     PR_HOME_ADDRESS_STATE_OR_PROVINCE_W,
!     PR_HOME_ADDRESS_POSTAL_CODE_W,
!     PR_HOME_ADDRESS_COUNTRY_W,
!     PR_BUSINESS_ADDRESS_CITY_W,
!     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W,
!     PR_BUSINESS_ADDRESS_POSTAL_CODE_W,
!     PR_BUSINESS_ADDRESS_COUNTRY_W,
!     PR_TITLE_W,
!     PR_DEPARTMENT_NAME_W,
!     PR_COMPANY_NAME_W,
!     PR_BUSINESS_HOME_PAGE_W,
!     PR_PERSONAL_HOME_PAGE_W,
!     PR_COMMENT_W
  } ;
  
  nsresult nsAbOutlookCard::Init(const char *aUri)
  {
      nsresult retCode = nsRDFResource::Init(aUri) ;
--- 125,158 ----
  
  static const ULONG OutlookCardMAPIProps [] = 
  {
!     PR_DISPLAY_NAME_A,//0x8035001E
!     PR_EMAIL_ADDRESS_A,//0x8034001E
!     PR_SECOND_EMAIL_ADDRESS_A,//Second Email Address
!     PR_GIVEN_NAME_A,
!     PR_SURNAME_A,
!     PR_NICKNAME_A,
!     PR_BUSINESS_TELEPHONE_NUMBER_A,
!     PR_HOME_TELEPHONE_NUMBER_A,
!     PR_BUSINESS_FAX_NUMBER_A,
!     PR_PAGER_TELEPHONE_NUMBER_A,
!     PR_MOBILE_TELEPHONE_NUMBER_A,
!     PR_HOME_ADDRESS_CITY_A,
!     PR_HOME_ADDRESS_STATE_OR_PROVINCE_A,
!     PR_HOME_ADDRESS_POSTAL_CODE_A,
!     PR_HOME_ADDRESS_COUNTRY_A,
!     PR_BUSINESS_ADDRESS_CITY_A,
!     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A,
!     PR_BUSINESS_ADDRESS_POSTAL_CODE_A,
!     PR_BUSINESS_ADDRESS_COUNTRY_A,
!     PR_TITLE_A,
!     PR_DEPARTMENT_NAME_A,
!     PR_COMPANY_NAME_A,
!     PR_BUSINESS_HOME_PAGE_A,
!     PR_PERSONAL_HOME_PAGE_A,
!     PR_COMMENT_A
  } ;
  
+ 
  nsresult nsAbOutlookCard::Init(const char *aUri)
  {
      nsresult retCode = nsRDFResource::Init(aUri) ;
***************
*** 176,181 ****
--- 179,185 ----
          SetDisplayName(unichars [index_DisplayName]->get()) ;
          SetNickName(unichars [index_NickName]->get()) ;
          SetPrimaryEmail(unichars [index_EmailAddress]->get()) ;
+         SetSecondEmail(unichars [index_SecondEmailAddress]->get()) ;
          SetWorkPhone(unichars [index_WorkPhoneNumber]->get()) ;
          SetHomePhone(unichars [index_HomePhoneNumber]->get()) ;
          SetFaxNumber(unichars [index_WorkFaxNumber]->get()) ;
***************
*** 210,221 ****
      nsAutoString unichar ;
      nsAutoString unicharBis ;
  
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_W, unichar)) {
          splitString(unichar, unicharBis) ;
          SetHomeAddress(unichar.get()) ;
          SetHomeAddress2(unicharBis.get()) ;
      }
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_W, unichar)) {
          splitString(unichar, unicharBis) ;
          SetWorkAddress(unichar.get()) ;
          SetWorkAddress2(unicharBis.get()) ;
--- 214,225 ----
      nsAutoString unichar ;
      nsAutoString unicharBis ;
  
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_A, unichar)) {
          splitString(unichar, unicharBis) ;
          SetHomeAddress(unichar.get()) ;
          SetHomeAddress2(unicharBis.get()) ;
      }
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_A, unichar)) {
          splitString(unichar, unicharBis) ;
          SetWorkAddress(unichar.get()) ;
          SetWorkAddress2(unicharBis.get()) ;
***************
*** 297,302 ****
--- 301,307 ----
      SetDisplayName(properties [index_DisplayName]) ;
      GetNickName(getter_Copies(properties [index_NickName])) ;
      GetPrimaryEmail(getter_Copies(properties [index_EmailAddress])) ;
+     GetSecondEmail(getter_Copies(properties [index_SecondEmailAddress])) ;
      GetWorkPhone(getter_Copies(properties [index_WorkPhoneNumber])) ;
      GetHomePhone(getter_Copies(properties [index_HomePhoneNumber])) ;
      GetFaxNumber(getter_Copies(properties [index_WorkFaxNumber])) ;
***************
*** 316,324 ****
      GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
      GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
      GetNotes(getter_Copies(properties [index_Comments])) ;
!     if (!mapiAddBook->SetPropertiesUString(*mMapiData, OutlookCardMAPIProps, 
!         index_LastProp, properties)) {
!         PRINTF(("Cannot set general properties.\n")) ;
      }
      delete [] properties ;
      nsXPIDLString unichar ;
--- 321,336 ----
      GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
      GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
      GetNotes(getter_Copies(properties [index_Comments])) ;
! 
!     int i=0;
!     for (i=0;i<index_LastProp;i++)
!     {
!         if (!mapiAddBook->SetPropertyUString(*mMapiData,
!                                             OutlookCardMAPIProps[i],
!                                             properties[i]))
!         {
!             PRINTF(("Cannot set properties:%d.\n",OutlookCardMAPIProps[i])) ;
!     }
      }
      delete [] properties ;
      nsXPIDLString unichar ;
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	Tue Feb 25 16:36:33 2003
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	Thu Mar 29 14:27:08 2007
***************
*** 124,131 ****
      nsCAutoString uri ;
      nsCOMPtr<nsIRDFResource> resource ;
  
!     for (ULONG i = 0 ; i < folders.mNbEntries ; ++ i) {
!         folders.mEntries [i].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
          uri.Append(entryId) ;
          
--- 124,131 ----
      nsCAutoString uri ;
      nsCOMPtr<nsIRDFResource> resource ;
  
!     for (ULONG i = 0 ; i < folders.GetSize() ; ++ i) {
!         folders[i].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
          uri.Append(entryId) ;
          
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	Thu Feb  5 13:33:06 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	Thu Mar 29 14:27:08 2007
***************
*** 126,132 ****
          PRINTF(("Cannot get type.\n")) ;
          return NS_ERROR_FAILURE ;
      }
!     if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, unichars)) {
          PRINTF(("Cannot get name.\n")) ;
          return NS_ERROR_FAILURE ;
      }
--- 126,132 ----
          PRINTF(("Cannot get type.\n")) ;
          return NS_ERROR_FAILURE ;
      }
!     if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, unichars)) {
          PRINTF(("Cannot get name.\n")) ;
          return NS_ERROR_FAILURE ;
      }
***************
*** 163,207 ****
      return retCode;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
  {
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsCOMPtr<nsISupportsArray> cardList ;
      nsresult retCode ;
      
-     mCardList.Reset() ;
      if (mIsQueryURI) {
          retCode = StartSearch() ;
-         NS_NewISupportsArray(getter_AddRefs(cardList)) ;
      }
      else {
!         retCode = GetChildCards(getter_AddRefs(cardList), nsnull) ;
      }
      if (NS_SUCCEEDED(retCode)) {
          // Fill the results array and update the card list
          // Also update the address list and notify any changes.
          PRUint32 nbCards = 0 ;
!         nsCOMPtr<nsISupports> element ;
          
-         cardList->Enumerate(aCards) ;
-         cardList->Count(&nbCards) ;
          for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
!             cardList->GetElementAt(i, getter_AddRefs(element)) ;
!             nsVoidKey newKey (NS_STATIC_CAST(void *, element)) ;
!             nsCOMPtr<nsISupports> oldElement = mCardList.Get(&newKey) ;
  
!             if (!oldElement) {
                  // We are dealing with a new element (probably directly
                  // added from Outlook), we may need to sync m_AddressList
!                 mCardList.Put(&newKey, element) ;
!                 nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
  
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  PRBool isMailList = PR_FALSE ;
  
                  retCode = card->GetIsMailList(&isMailList) ;
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  if (isMailList) {
                      // We can have mailing lists only in folder, 
                      // we must add the directory to m_AddressList
--- 163,247 ----
      return retCode;
  }
  
+ nsresult nsAbOutlookDirectory::BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                                                 PRBool aSearchForOld, PRBool& aIsNewCard)
+ {   
+     nsresult retCode = NS_OK ;
+     if (aSearchForOld) {
+         nsCStringKey key(uriName) ;
+         nsCOMPtr<nsISupports> existingCard = mCardList.Get(&key) ;
+         
+         if (existingCard) {
+             nsCOMPtr<nsIAbCard> card(do_QueryInterface(existingCard, &retCode)) ;
+             
+             NS_ENSURE_SUCCESS(retCode, retCode) ;
+             NS_IF_ADDREF(*aNewCard = card) ;
+             aIsNewCard = PR_FALSE ;
+             return retCode ;
+         }
+     }
+     aIsNewCard = PR_TRUE ;
+     nsCOMPtr<nsIRDFResource> resource ;
+ 
+     nsCOMPtr<nsIAbCard> childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     resource = do_QueryInterface(childCard, &retCode) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     retCode = resource->Init(uriName.get()) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     NS_IF_ADDREF(*aNewCard = childCard);
+     return retCode ;
+ }
+ 
  NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
  {
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsCOMPtr<nsISupportsArray> cardList ;
+     nsCStringArray uriList ;
+     nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsresult retCode ;
      
      if (mIsQueryURI) {
          retCode = StartSearch() ;
      }
      else {
!         retCode = GetChildCards(uriList, nsnull) ;
      }
+     NS_NewISupportsArray(getter_AddRefs(cardList)) ;
      if (NS_SUCCEEDED(retCode)) {
          // Fill the results array and update the card list
          // Also update the address list and notify any changes.
          PRUint32 nbCards = 0 ;
!         nsCAutoString uriName;
!         nsCOMPtr <nsIAbCard> childCard;
!         PRBool searchForOldCards = 0; //(mCardList.Count() != 0) ;
! 
!         nbCards = uriList.Count();
! 		NS_NewISupportsArray(getter_AddRefs(m_AddressList));
          
          for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
!             PRBool isNewCard = PR_FALSE ;
  
!             uriList.CStringAt(i,uriName);
!             retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), searchForOldCards, isNewCard);
!             NS_ENSURE_SUCCESS(retCode, retCode) ;
!             cardList->AppendElement(childCard);
! 
!             if (isNewCard) {
                  // We are dealing with a new element (probably directly
                  // added from Outlook), we may need to sync m_AddressList
!                 nsCStringKey newKey(uriName) ;
! 
!                 mCardList.Put(&newKey, childCard) ;
!                 nsCOMPtr<nsIAbCard> card (do_QueryInterface(childCard, &retCode)) ;
  
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  PRBool isMailList = PR_FALSE ;
  
                  retCode = card->GetIsMailList(&isMailList) ;
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
+ 
                  if (isMailList) {
                      // We can have mailing lists only in folder, 
                      // we must add the directory to m_AddressList
***************
*** 224,241 ****
                      NotifyItemAddition(card) ;
                  }
              }
-             else {
-                 NS_ASSERTION(oldElement == element, "Different card stored") ;
              }
          }
      }
      return retCode ;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
  {
      if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
!     nsVoidKey key (NS_STATIC_CAST(void *, aCard)) ;
  
      *aHasCard = mCardList.Exists(&key) ;
      return NS_OK ;
--- 264,296 ----
                      NotifyItemAddition(card) ;
                  }
              }
              }
          }
+     return cardList->Enumerate(aCards) ;
      }
+ 
+ static nsresult ExtractUriFromCard(nsIAbCard *aCard, nsCString& aUri) {
+     nsresult retCode = NS_OK ;
+     nsCOMPtr<nsIRDFResource> resource (do_QueryInterface(aCard, &retCode)) ;
+     
+     // Receiving a non-RDF card is accepted
+     if (NS_FAILED(retCode)) { return NS_OK ; }
+     nsXPIDLCString uri ;
+     
+     retCode = resource->GetValue(getter_Copies(uri)) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     aUri = uri.get() ;
      return retCode ;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
  {
      if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
!     *aHasCard = PR_FALSE ;
!     nsCString uri ;
! 
!     ExtractUriFromCard(aCard, uri) ;
!     nsCStringKey key(uri) ;
  
      *aHasCard = mCardList.Exists(&key) ;
      return NS_OK ;
***************
*** 317,323 ****
                  PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
              }
              else {
!                 nsVoidKey key (NS_STATIC_CAST(void *, element)) ;
                  
                  mCardList.Remove(&key) ;
                  if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
--- 372,381 ----
                  PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
              }
              else {
!                 nsCString uri ;
! 
!                 ExtractUriFromCard(card, uri) ;
!                 nsCStringKey key(uri) ;
                  
                  mCardList.Remove(&key) ;
                  if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
***************
*** 386,392 ****
      }
      retCode = CreateCard(aData, addedCard) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nsVoidKey newKey (NS_STATIC_CAST(void *, *addedCard)) ;
      
      mCardList.Put(&newKey, *addedCard) ;
      if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
--- 444,453 ----
      }
      retCode = CreateCard(aData, addedCard) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nsCString uri ;
! 
!     ExtractUriFromCard(*addedCard, uri) ;
!     nsCStringKey newKey(uri) ;
      
      mCardList.Put(&newKey, *addedCard) ;
      if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
***************
*** 457,463 ****
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      retCode = GetDirName(getter_Copies(name)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, name.get())) {
          return NS_ERROR_FAILURE ;
      }
      retCode = CommitAddressList() ;
--- 518,524 ----
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      retCode = GetDirName(getter_Copies(name)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, name.get())) {
          return NS_ERROR_FAILURE ;
      }
      retCode = CommitAddressList() ;
***************
*** 518,523 ****
--- 579,585 ----
      {"DisplayName", PR_DISPLAY_NAME_A},
      {"NickName", PR_NICKNAME_A},
      {"PrimaryEmail", PR_EMAIL_ADDRESS_A},
+     {"SecondEmail",PR_SECOND_EMAIL_ADDRESS_A},
      {"WorkPhone", PR_BUSINESS_TELEPHONE_NUMBER_A},
      {"HomePhone", PR_HOME_TELEPHONE_NUMBER_A},
      {"FaxNumber", PR_BUSINESS_FAX_NUMBER_A},
***************
*** 1032,1038 ****
  
  nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
  {
!     nsVoidKey newKey (NS_STATIC_CAST(void *, aCard)) ;
      nsresult retCode = NS_OK ;
      
      mCardList.Put(&newKey, aCard) ;
--- 1094,1103 ----
  
  nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
  {
!     nsCString uri ;
! 
!     ExtractUriFromCard(aCard, uri) ;
!     nsCStringKey newKey(uri) ;
      nsresult retCode = NS_OK ;
      
      mCardList.Put(&newKey, aCard) ;
***************
*** 1056,1069 ****
      retCode = BuildRestriction(aArguments, arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsISupportsArray> resultsArray ;
      PRUint32 nbResults = 0 ;
      
!     retCode = GetChildCards(getter_AddRefs(resultsArray), 
                              arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
      DestroyRestriction(arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     retCode = resultsArray->Count(&nbResults) ;
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsIAbDirectoryQueryResult> result ;
      nsAbDirectoryQueryResult *newResult = nsnull ;
  
--- 1121,1134 ----
      retCode = BuildRestriction(aArguments, arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsISupportsArray> resultsArray ;
+     nsCStringArray uriArray ;
      PRUint32 nbResults = 0 ;
      
!     retCode = GetChildCards(uriArray, 
                              arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
      DestroyRestriction(arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nbResults = uriArray.Count() ;
      nsCOMPtr<nsIAbDirectoryQueryResult> result ;
      nsAbDirectoryQueryResult *newResult = nsnull ;
  
***************
*** 1071,1085 ****
          nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
      }
      PRUint32 i = 0 ;
-     nsCOMPtr<nsISupports> element ;
      nsCOMPtr<nsISupportsArray> propertyValues ;
      
      for (i = 0 ; i < nbResults ; ++ i) {
!         retCode = resultsArray->GetElementAt(i, getter_AddRefs(element)) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
          
          NS_ENSURE_SUCCESS(retCode, retCode) ;
          FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
          newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                   nsIAbDirectoryQueryResult::queryResultMatch, 
--- 1136,1153 ----
          nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
      }
      PRUint32 i = 0 ;
      nsCOMPtr<nsISupportsArray> propertyValues ;
      
+     nsCAutoString uriName;
+     nsCOMPtr <nsIAbCard> card;
+ 
      for (i = 0 ; i < nbResults ; ++ i) {
!         PRBool isNewCard = PR_FALSE ;
          
+         uriArray.CStringAt(i,uriName);
+         retCode = BuildCardFromURI(uriName,getter_AddRefs(card), PR_FALSE, isNewCard);
          NS_ENSURE_SUCCESS(retCode, retCode) ;
+         
          FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
          newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                   nsIAbDirectoryQueryResult::queryResultMatch, 
***************
*** 1104,1116 ****
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsresult retCode = NS_OK ;
!     nsCOMPtr<nsISupportsArray> cards ;
      nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsMapiEntryArray cardEntries ;
      LPSRestriction restriction = (LPSRestriction) aRestriction ;
  
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
-     retCode = NS_NewISupportsArray(getter_AddRefs(cards)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
          PRINTF(("Cannot get cards.\n")) ;
--- 1172,1214 ----
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsresult retCode = NS_OK ;
! 
!     nsCOMPtr<nsISupportsArray> cards;
!     retCode = NS_NewISupportsArray(getter_AddRefs(cards));
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
! 
!     nsCStringArray uriList;
!     retCode = GetChildCards(uriList,aRestriction);
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
!     
!     nsCAutoString uriName;
!     nsCOMPtr <nsIAbCard> childCard;
!     PRUint32 nbURIs = 0 ;
!     nbURIs = uriList.Count();
!     PRUint32 i = 0 ;
!         
!     for (i = 0 ; i < nbURIs ; ++ i) {
!         PRBool isNewCard = PR_FALSE ;
! 
!         uriList.CStringAt(i,uriName);
!         retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), PR_TRUE, isNewCard);
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         cards->AppendElement(childCard);
!     }        
!     
!     NS_IF_ADDREF(*aCards = cards);
!     return retCode ;
! }
! 
! nsresult nsAbOutlookDirectory::GetChildCards(nsCStringArray& aURI, 
!                                              void *aRestriction)
! {
!     nsresult retCode = NS_OK ;
      nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsMapiEntryArray cardEntries ;
      LPSRestriction restriction = (LPSRestriction) aRestriction ;
  
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
          PRINTF(("Cannot get cards.\n")) ;
***************
*** 1119,1140 ****
      nsCAutoString entryId ;
      nsCAutoString uriName ;
      nsCOMPtr<nsIRDFResource> resource ;
!     nsCOMPtr <nsIAbCard> childCard;
!         
!     for (ULONG card = 0 ; card < cardEntries.mNbEntries ; ++ card) {
!         cardEntries.mEntries [card].ToString(entryId) ;
          buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
!         childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         resource = do_QueryInterface(childCard, &retCode) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         retCode = resource->Init(uriName.get()) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         cards->AppendElement(childCard) ;
      }
-     *aCards = cards ;
-     NS_ADDREF(*aCards) ;
      return retCode ;
  }
  
--- 1217,1230 ----
      nsCAutoString entryId ;
      nsCAutoString uriName ;
      nsCOMPtr<nsIRDFResource> resource ;
!     aURI.Clear();
!     
!     for (ULONG card = 0 ; card < cardEntries.GetSize() ; ++ card) {
!         cardEntries [card].ToString(entryId) ;
          buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
!         aURI.AppendCString(uriName);
      }
      return retCode ;
  }
  
***************
*** 1158,1165 ****
      nsCAutoString uriName ;
      nsCOMPtr <nsIRDFResource> resource ;
  
!     for (ULONG node = 0 ; node < nodeEntries.mNbEntries ; ++ node) {
!         nodeEntries.mEntries [node].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
          retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
--- 1248,1255 ----
      nsCAutoString uriName ;
      nsCOMPtr <nsIRDFResource> resource ;
  
!     for (ULONG node = 0 ; node < nodeEntries.GetSize() ; ++ node) {
!         nodeEntries [node].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
          retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
***************
*** 1280,1286 ****
          // In the case of a mailing list, we cannot directly create a new card,
          // we have to create a temporary one in a real folder (to be able to use
          // templates) and then copy it to the mailing list.
!         if (m_IsMailList) {
              nsMapiEntry parentEntry ;
              nsMapiEntry temporaryEntry ;
  
--- 1370,1376 ----
          // In the case of a mailing list, we cannot directly create a new card,
          // we have to create a temporary one in a real folder (to be able to use
          // templates) and then copy it to the mailing list.
!         if (m_IsMailList && mAbWinType == nsAbWinType_OutlookExp) {
              nsMapiEntry parentEntry ;
              nsMapiEntry temporaryEntry ;
  
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	Thu Feb  5 13:33:06 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	Thu Mar 29 14:27:08 2007
***************
*** 46,51 ****
--- 46,52 ----
  #include "nsHashtable.h"
  
  #include "nsISupportsArray.h"
+ #include "nsVoidArray.h"
  
  struct nsMapiEntry ;
  
***************
*** 92,97 ****
--- 93,100 ----
  protected:
      // Retrieve hierarchy as cards, with an optional restriction
      nsresult GetChildCards(nsISupportsArray **aCards, void *aRestriction) ;
+     // Retrieve hierarchy as URIs, with an optional restriction
+     nsresult GetChildCards(nsCStringArray& aURI, void *aRestriction) ;
      // Retrieve hierarchy as directories
      nsresult GetChildNodes(nsISupportsArray **aNodes) ;
      // Create a new card
***************
*** 103,108 ****
--- 106,114 ----
      nsresult CommitAddressList(void) ;
      // Read MAPI repository
      nsresult UpdateAddressList(void) ;
+     // Search for an existing card or build a new one
+     nsresult BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                               PRBool aSearchForOld, PRBool& aIsNewCard) ;
  
      nsMapiEntry *mMapiData ;
      // Container for the query threads
*** misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	Wed Apr 14 16:16:12 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	Thu Mar 29 14:27:08 2007
***************
*** 41,46 ****
--- 41,49 ----
  #define USES_IID_IABContainer
  #define USES_IID_IMAPITable
  #define USES_IID_IDistList
+ #define USES_IID_IMsgStore
+ #define USES_IID_IMessage
+ #define USES_IID_IMAPIFolder
  
  #include "nsAbWinHelper.h"
  #include "nsAbUtils.h"
***************
*** 59,77 ****
  
  #define PRINTF(args) PR_LOG(gAbWinHelperLog, PR_LOG_DEBUG, args)
  
- // Small utility to ensure release of all MAPI interfaces
- template <class tInterface> struct nsMapiInterfaceWrapper
- {
-     tInterface mInterface ;
- 
-     nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
-     ~nsMapiInterfaceWrapper(void) {
-         if (mInterface != NULL) { mInterface->Release() ; }
-     }
-     operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
-     tInterface operator -> (void) const { return mInterface ; }
-     operator tInterface *(void) { return &mInterface ; }
- } ;
  
  static void assignEntryID(LPENTRYID& aTarget, LPENTRYID aSource, ULONG aByteCount)
  {
--- 62,67 ----
***************
*** 249,272 ****
  MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
  
  nsMapiEntryArray::nsMapiEntryArray(void)
- : mEntries(NULL), mNbEntries(0)
  {
      MOZ_COUNT_CTOR(nsMapiEntryArray) ;
  }
  
  nsMapiEntryArray::~nsMapiEntryArray(void)
  {
!     if (mEntries) { delete [] mEntries ; }
      MOZ_COUNT_DTOR(nsMapiEntryArray) ;
  }
! 
  void nsMapiEntryArray::CleanUp(void)
  {
!     if (mEntries != NULL) { 
!         delete [] mEntries ;
!         mEntries = NULL ;
!         mNbEntries = 0 ;
      }
  }
  
  MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
--- 239,266 ----
  MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
  
  nsMapiEntryArray::nsMapiEntryArray(void)
  {
      MOZ_COUNT_CTOR(nsMapiEntryArray) ;
  }
  
  nsMapiEntryArray::~nsMapiEntryArray(void)
  {
!     CleanUp();
      MOZ_COUNT_DTOR(nsMapiEntryArray) ;
  }
! void  nsMapiEntryArray::AddItem(nsMapiEntry * aEntries)
! {
!     m_array.AppendElement(aEntries);
! }
  void nsMapiEntryArray::CleanUp(void)
  {
!     nsMapiEntry *pEntries;
!     for (int i = 0; i < m_array.Count(); i++)
!     {
!         pEntries = (nsMapiEntry *)m_array.ElementAt( i);
!         delete pEntries;
      }
+     m_array.Clear();
  }
  
  MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
***************
*** 280,379 ****
  // same protection (MAPI is supposed to be thread-safe).
  PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
  
  nsAbWinHelper::nsAbWinHelper(void)
! : mAddressBook(NULL), mLastError(S_OK)
  {
      MOZ_COUNT_CTOR(nsAbWinHelper) ;
  }
  
  nsAbWinHelper::~nsAbWinHelper(void)
  {
      MOZ_COUNT_DTOR(nsAbWinHelper) ;
! }
! 
! BOOL nsAbWinHelper::GetFolders(nsMapiEntryArray& aFolders)
  {
!     aFolders.CleanUp() ;
!     nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
!     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
!     ULONG objType = 0 ;
!     ULONG rowCount = 0 ;
!     SRestriction restriction ;
!     SPropTagArray folderColumns ;
! 
!     mLastError = mAddressBook->OpenEntry(0, NULL, NULL, 0, &objType, 
!                                          rootFolder) ;
!     if (HR_FAILED(mLastError)) { 
!         PRINTF(("Cannot open root %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
-     mLastError = rootFolder->GetHierarchyTable(0, folders) ;
-     if (HR_FAILED(mLastError)) {
-         PRINTF(("Cannot get hierarchy %08x.\n", mLastError)) ;
-         return FALSE ; 
      }
!     // We only take into account modifiable containers, 
!     // otherwise, we end up with all the directory services...
!     restriction.rt = RES_BITMASK ;
!     restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
!     restriction.res.resBitMask.relBMR = BMR_NEZ ;
!     restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
!     mLastError = folders->Restrict(&restriction, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
!     }
!     folderColumns.cValues = 1 ;
!     folderColumns.aulPropTag [0] = PR_ENTRYID ;
!     mLastError = folders->SetColumns(&folderColumns, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = folders->GetRowCount(0, &rowCount) ;
!     if (HR_SUCCEEDED(mLastError)) {
!         aFolders.mEntries = new nsMapiEntry [rowCount] ;
!         aFolders.mNbEntries = 0 ;
!         do {
!             LPSRowSet rowSet = NULL ;
! 
!             rowCount = 0 ;
!             mLastError = folders->QueryRows(1, 0, &rowSet) ;
!             if (HR_SUCCEEDED(mLastError)) {
!                 rowCount = rowSet->cRows ;
!                 if (rowCount > 0) {
!                     nsMapiEntry& current = aFolders.mEntries [aFolders.mNbEntries ++] ;
!                     SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
!                     
!                     current.Assign(currentValue.Value.bin.cb,
!                                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
!                 }
!                 MyFreeProws(rowSet) ;
!             }
!             else {
!                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
!             }
!         } while (rowCount > 0) ;
!     }
!     return HR_SUCCEEDED(mLastError) ;
! }
  
  BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                               nsMapiEntryArray& aCards)
  {
      aCards.CleanUp() ;
!     return GetContents(aParent, aRestriction, &aCards.mEntries, aCards.mNbEntries, 0) ;
  }
   
  BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
  { 
      aNodes.CleanUp() ;
!     return GetContents(aParent, NULL, &aNodes.mEntries, aNodes.mNbEntries, MAPI_DISTLIST) ;
  }
  
  BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
  {
!     aNbCards = 0 ;
!     return GetContents(aParent, NULL, NULL, aNbCards, 0) ;
  }
  
  BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
--- 274,328 ----
  // same protection (MAPI is supposed to be thread-safe).
  PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
  
+ int            nsAbWinHelper::m_clients = 0;
+ 
+ PRUnichar *    nsAbWinHelper::m_pUniBuff = NULL;
+ int            nsAbWinHelper::m_uniBuffLen = 0;
+ char      *    nsAbWinHelper::m_pCStrBuff = NULL;
+ int            nsAbWinHelper::m_cstrBuffLen = 0;
+ 
  nsAbWinHelper::nsAbWinHelper(void)
! :mLastError(S_OK)
  {
      MOZ_COUNT_CTOR(nsAbWinHelper) ;
+     m_clients++;
  }
  
  nsAbWinHelper::~nsAbWinHelper(void)
  {
      MOZ_COUNT_DTOR(nsAbWinHelper) ;
!     m_clients--;
!     if (!m_clients)
  {
!         delete [] m_pUniBuff;
!         m_pUniBuff = NULL;
!         m_uniBuffLen = 0;
!         delete [] m_pCStrBuff;
!         m_pCStrBuff = NULL;
!         m_cstrBuffLen = 0;
      }
      }
! 
  
  BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                               nsMapiEntryArray& aCards)
  {
      aCards.CleanUp() ;
!     return GetContents(aParent, aRestriction, &aCards, 0) ;
  }
   
  BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
  { 
      aNodes.CleanUp() ;
!     return GetContents(aParent, NULL, &aNodes, MAPI_DISTLIST) ;
  }
  
  BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
  {
!     nsMapiEntryArray aCards;
!     BOOL ret=GetContents(aParent, NULL, &aCards,  0) ;
!     aNbCards=aCards.GetSize();
!     return ret;
  }
  
  BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
***************
*** 390,396 ****
              aName = values->Value.lpszA ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
!             aName.AssignWithConversion(values->Value.lpszW) ;
          }
      }
      FreeBuffer(values) ;
--- 339,345 ----
              aName = values->Value.lpszA ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
!             UnicodeToCStr(values->Value.lpszW,aName) ;
          }
      }
      FreeBuffer(values) ;
***************
*** 410,416 ****
              aName = values->Value.lpszW ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
!             aName.AssignWithConversion(values->Value.lpszA) ;
          }
      }
      FreeBuffer(values) ;
--- 359,365 ----
              aName = values->Value.lpszW ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
!             CStrToUnicode(values->Value.lpszA,aName) ;
          }
      }
      FreeBuffer(values) ;
***************
*** 431,446 ****
          ULONG i = 0 ;
  
          for (i = 0 ; i < valueCount ; ++ i) {
!             if (PROP_ID(values [i].ulPropTag) == PROP_ID(aPropertyTags [i])) {
                  if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                      nsAutoString temp ;
  
!                     temp.AssignWithConversion (values [i].Value.lpszA) ;
                      aNames.AppendString(temp) ;
                  }
                  else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                      aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                  }
                  else {
                      aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                  }
--- 380,401 ----
          ULONG i = 0 ;
  
          for (i = 0 ; i < valueCount ; ++ i) {
!             if (PROP_TYPE( values [i].ulPropTag) != PT_ERROR && values [i].Value.l != MAPI_E_NOT_FOUND){
                  if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                      nsAutoString temp ;
  
!                     CStrToUnicode(values [i].Value.lpszA,temp) ;
                      aNames.AppendString(temp) ;
                  }
                  else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                      aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                  }
+                 else if (aPropertyTags [i] == PR_EMAIL_ADDRESS_A) {
+                     nsAutoString temp ;
+ 
+                     CStrToUnicode (values [i].Value.lpszA,temp) ;
+                     aNames.AppendString(temp) ;
+                 }
                  else {
                      aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                  }
***************
*** 466,472 ****
      if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) { return FALSE ; }
      if (valueCount == 1 && values != NULL && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
          SYSTEMTIME readableTime ;
- 
          if (FileTimeToSystemTime(&values->Value.ft, &readableTime)) {
              aYear = readableTime.wYear ;
              aMonth = readableTime.wMonth ;
--- 421,426 ----
***************
*** 518,524 ****
      nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
      ULONG objType = 0 ;
      
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IMAPIContainer, 0, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 472,478 ----
      nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
      ULONG objType = 0 ;
      
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IMAPIContainer, 0, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 537,543 ****
      SBinary entry ;
      SBinaryArray entryArray ;
  
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 491,497 ----
      SBinary entry ;
      SBinaryArray entryArray ;
  
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 567,580 ****
          value.Value.lpszW = NS_CONST_CAST(WORD *, aValue) ;
      }
      else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
!         alternativeValue.AssignWithConversion(aValue) ;
          value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
      }
      else {
          PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
          return TRUE ;
      }
!     return SetMAPIProperties(aObject, 1, &value) ;
  }
  
  BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
--- 521,535 ----
          value.Value.lpszW = NS_CONST_CAST(WORD *, aValue) ;
      }
      else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
!         UnicodeToCStr(aValue,alternativeValue) ;
          value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
      }
      else {
          PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
          return TRUE ;
      }
!     LPSPropValue values=&value;
!     return SetMAPIProperties(aObject, 1, values) ;
  }
  
  BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
***************
*** 595,601 ****
              values [currentValue ++].Value.lpszW = NS_CONST_CAST(WORD *, aValues [i].get()) ;
          }
          else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
!             alternativeValue.AssignWithConversion(aValues [i].get()) ;
              char *av = nsCRT::strdup(alternativeValue.get()) ;
              if (!av) {
                  retCode = FALSE ;
--- 550,556 ----
              values [currentValue ++].Value.lpszW = NS_CONST_CAST(WORD *, aValues [i].get()) ;
          }
          else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
!             UnicodeToCStr(aValues [i].get(),alternativeValue) ;
              char *av = nsCRT::strdup(alternativeValue.get()) ;
              if (!av) {
                  retCode = FALSE ;
***************
*** 633,639 ****
          readableTime.wSecond = 0 ;
          readableTime.wMilliseconds = 0 ;
          if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
!             return SetMAPIProperties(aObject, 1, &value) ;
          }
          return TRUE ;
      }
--- 588,595 ----
          readableTime.wSecond = 0 ;
          readableTime.wMilliseconds = 0 ;
          if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
!             LPSPropValue values=&value;
!             return SetMAPIProperties(aObject, 1, values) ;
          }
          return TRUE ;
      }
***************
*** 645,651 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
--- 601,607 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
***************
*** 708,714 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 664,670 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 773,779 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
--- 729,735 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
***************
*** 810,1003 ****
      return TRUE ;
  }
  
- BOOL nsAbWinHelper::GetDefaultContainer(nsMapiEntry& aContainer)
- {
-     LPENTRYID entryId = NULL ; 
-     ULONG byteCount = 0 ;
- 
-     mLastError = mAddressBook->GetPAB(&byteCount, &entryId) ;
-     if (HR_FAILED(mLastError)) {
-         PRINTF(("Cannot get PAB %08x.\n", mLastError)) ;
-         return FALSE ;
-     }
-     aContainer.Assign(byteCount, entryId) ;
-     FreeBuffer(entryId) ;
-     return TRUE ;
- }
  
- enum
- {
-     ContentsColumnEntryId = 0,
-     ContentsColumnObjectType,
-     ContentsColumnsSize
- } ;
  
- static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
- {
-     ContentsColumnsSize,
-     {
-         PR_ENTRYID,
-         PR_OBJECT_TYPE
-     }
- } ;
  
! BOOL nsAbWinHelper::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
!                                 nsMapiEntry **aList, ULONG& aNbElements, ULONG aMapiType)
  {
!     if (aList != NULL) { *aList = NULL ; }
!     aNbElements = 0 ;
!     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
!     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
!     ULONG objType = 0 ;
!     ULONG rowCount = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId, 
!                                          &IID_IMAPIContainer, 0, &objType, 
!                                          parent) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
!         return FALSE ; 
!     }
!     // Here, flags for WAB and MAPI could be different, so this works
!     // only as long as we don't want to use any flag in GetContentsTable
!     mLastError = parent->GetContentsTable(0, contents) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
!     if (aRestriction != NULL) {
!         mLastError = contents->Restrict(aRestriction, 0) ;
!         if (HR_FAILED(mLastError)) {
!             PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
!             return FALSE ;
!         }
!     }
!     mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = contents->GetRowCount(0, &rowCount) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     if (aList != NULL) { *aList = new nsMapiEntry [rowCount] ; }
!     aNbElements = 0 ;
!     do {
!         LPSRowSet rowSet = NULL ;
!         
!         rowCount = 0 ;
!         mLastError = contents->QueryRows(1, 0, &rowSet) ;
!         if (HR_FAILED(mLastError)) {
!             PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
!             return FALSE ;
!         }
!         rowCount = rowSet->cRows ;
!         if (rowCount > 0 &&
!             (aMapiType == 0 ||
!             rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)) {
!             if (aList != NULL) {
!                 nsMapiEntry& current = (*aList) [aNbElements] ;
!                 SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
!                 
!                 current.Assign(currentValue.Value.bin.cb,
!                     NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
              }
!             ++ aNbElements ;
          }
-         MyFreeProws(rowSet) ;
-     } while (rowCount > 0) ;
-     return TRUE ;
  }
! 
! BOOL nsAbWinHelper::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
!                                       ULONG aNbProperties, LPSPropValue& aValue, 
!                                       ULONG& aValueCount)
  {
!     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
!     ULONG objType = 0 ;
!     LPSPropTagArray properties = NULL ;
!     ULONG i = 0 ;
!     
!     mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
!                                          &IID_IMAPIProp, 0, &objType, 
!                                          object) ;
!     if (HR_FAILED(mLastError)) { 
!         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
!     AllocateBuffer(CbNewSPropTagArray(aNbProperties), 
!                    NS_REINTERPRET_CAST(void **, &properties)) ;
!     properties->cValues = aNbProperties ;
!     for (i = 0 ; i < aNbProperties ; ++ i) {
!         properties->aulPropTag [i] = aPropertyTags [i] ;
!     }
!     mLastError = object->GetProps(properties, 0, &aValueCount, &aValue) ;
!     FreeBuffer(properties) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get props %08x.\n", mLastError)) ;
      }
-     return HR_SUCCEEDED(mLastError) ;
  }
  
! BOOL nsAbWinHelper::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                                       const LPSPropValue& aValues)
! {
!     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
!     ULONG objType = 0 ;
!     LPSPropProblemArray problems = NULL ;
  
!     mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
!                                          &IID_IMAPIProp, MAPI_MODIFY, &objType, 
!                                          object) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     if (problems != NULL) {
!         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
!             PRINTF(("Problem %d: index %d code %08x.\n", i, 
!                 problems->aProblem [i].ulIndex, 
!                 problems->aProblem [i].scode)) ;
!         }
!     }
!     mLastError = object->SaveChanges(0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
!     }
!     return HR_SUCCEEDED(mLastError) ;
  }
  
! void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
! {
!     if (aRowset == NULL) { return ; }
!     ULONG i = 0 ; 
  
!     for (i = 0 ; i < aRowset->cRows ; ++ i) {
!         FreeBuffer(aRowset->aRow [i].lpProps) ;
!     }
!     FreeBuffer(aRowset) ;
  }
  
  nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
  : mHelper(NULL) 
  {
      switch(aType) {
!     case nsAbWinType_Outlook: mHelper = new nsMapiAddressBook ; break ;
!     case nsAbWinType_OutlookExp: mHelper = new nsWabAddressBook ; break ;
      default: break ;
      }
  }
  
  nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
  {
-     delete mHelper ;
  }
  
  const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
--- 766,842 ----
      return TRUE ;
  }
  
  
  
  
! void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
  {
!     if (aRowset == NULL) { return ; }
!     ULONG i = 0 ;
  
!     for (i = 0 ; i < aRowset->cRows ; ++ i) {
!         FreeBuffer(aRowset->aRow [i].lpProps) ;
      }
!     FreeBuffer(aRowset) ;
!         }
! void nsAbWinHelper::CStrToUnicode( const char *pStr, nsString& result)
! {
!     result.Truncate( 0);
!     int wLen = MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, 0);
!     if (wLen >= m_uniBuffLen)
!     {
!         delete [] m_pUniBuff;
!         m_pUniBuff = new PRUnichar[wLen + 64];
!         m_uniBuffLen = wLen + 64;
              }
!     if (wLen)
!     {
!         MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, m_uniBuffLen);
!         result = m_pUniBuff;
          }
  }
! void nsAbWinHelper::UnicodeToCStr( const  PRUnichar *pUStr,nsCString& result)
  {
!     result.Truncate( 0);
!     int cLen = WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, 0,NULL,NULL);
!     if (cLen >= m_cstrBuffLen) {
!         if (m_pCStrBuff)
!             delete [] m_pCStrBuff;
!         m_pCStrBuff = new char[cLen + 64];
!         m_cstrBuffLen = cLen + 64;
      }
!     if (cLen) {
!         WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, m_cstrBuffLen,NULL,NULL);
!         result = m_pCStrBuff;
      }
  }
  
! static nsAbWinHelper *getOutlookAddressBook(void) {
!     static nsMapiAddressBook *addressBook = NULL ;
  
!     if (addressBook == NULL) { addressBook = new nsMapiAddressBook ; } 
!     return addressBook ;
  }
  
! static nsAbWinHelper *getOutlookExpAddressBook(void) {
!     static nsWabAddressBook *addressBook = NULL ;
  
!     if (addressBook == NULL) { addressBook = new nsWabAddressBook ; } 
!     return addressBook ;
  }
  
  nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
  : mHelper(NULL) 
  {
      switch(aType) {
!     case nsAbWinType_Outlook: mHelper = getOutlookAddressBook() ; break ;
!     case nsAbWinType_OutlookExp: mHelper = getOutlookExpAddressBook() ; break ;
      default: break ;
      }
  }
  
  nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
  {
  }
  
  const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
*** misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	Wed Apr 14 16:16:12 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	Thu Mar 29 14:27:08 2007
***************
*** 45,50 ****
--- 45,68 ----
  #include "nsVoidArray.h"
  #include "nsXPIDLString.h"
   
+ #define PR_SECOND_EMAIL_ADDRESS_A  0x8033001E
+ #define PR_SCREEN_NAME_A           0x805B001E
+  
+ 
+ // Small utility to ensure release of all MAPI interfaces
+ template <class tInterface> struct nsMapiInterfaceWrapper
+ {
+     tInterface mInterface ;
+ 
+     nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
+     ~nsMapiInterfaceWrapper(void) {
+         if (mInterface ) { mInterface->Release() ; }
+     }
+     operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
+     tInterface operator -> (void) const { return mInterface ; }
+     operator tInterface *(void) { return &mInterface ; }
+ } ;
+ 
  struct nsMapiEntry
  {
      ULONG     mByteCount ;
***************
*** 62,75 ****
  
  struct nsMapiEntryArray 
  {
-     nsMapiEntry *mEntries ;
-     ULONG      mNbEntries ;
  
      nsMapiEntryArray(void) ;
      ~nsMapiEntryArray(void) ;
  
!     const nsMapiEntry& operator [] (int aIndex) const { return mEntries [aIndex] ; }
      void CleanUp(void) ;
  } ;
  
  class nsAbWinHelper
--- 80,107 ----
  
  struct nsMapiEntryArray 
  {
  
      nsMapiEntryArray(void) ;
      ~nsMapiEntryArray(void) ;
  
!     void  AddItem(nsMapiEntry * aEntries);
!     void  AddItem(    ULONG     mByteCount , LPENTRYID mEntryId )
!     {
!         nsMapiEntry * aEntries=new nsMapiEntry();
!         aEntries->Assign(mByteCount,mEntryId);
!         AddItem(aEntries);
!     }
! 
!     ULONG        GetSize( void) { return( m_array.Count());}
!     nsMapiEntry& operator [] (int aIndex)  { return *(nsMapiEntry*)m_array.ElementAt(aIndex); }
!     nsMapiEntry* ElementAt(int aIndex)  { return (nsMapiEntry*)m_array.ElementAt(aIndex); }
      void CleanUp(void) ;
+     void Remove(nsMapiEntry * aEntries){ m_array.RemoveElement(aEntries); }
+     void Remove(int index){ m_array.RemoveElementAt(index); }
+     ULONG IndexOf(nsMapiEntry * aEntries){return m_array.IndexOf(aEntries);};
+ private:
+     nsVoidArray        m_array;
+ 
  } ;
  
  class nsAbWinHelper
***************
*** 79,85 ****
      virtual ~nsAbWinHelper(void) ;
  
      // Get the top address books
!     BOOL GetFolders(nsMapiEntryArray& aFolders) ;
      // Get a list of entries for cards/mailing lists in a folder/mailing list
      BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                    nsMapiEntryArray& aCards) ;
--- 111,117 ----
      virtual ~nsAbWinHelper(void) ;
  
      // Get the top address books
!     virtual BOOL GetFolders(nsMapiEntryArray& aFolders) =0;
      // Get a list of entries for cards/mailing lists in a folder/mailing list
      BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                    nsMapiEntryArray& aCards) ;
***************
*** 97,114 ****
      BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                                ULONG aNbProperties, nsStringArray& aValues) ;
      // Get the value of a MAPI property of type SYSTIME
!     BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD& aYear, WORD& aMonth, WORD& aDay) ;
-     // Get the value of a MAPI property of type LONG
-     BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
      // Get the value of a MAPI property of type BIN
      BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
      // Tests if a container contains an entry
      BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
-     // Delete an entry in the address book
-     BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Set the value of a MAPI property of type string in unicode
!     BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                               const PRUnichar *aValue) ;
      // Same as previous, but with a bunch of properties in one call
      BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
--- 129,142 ----
      BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                                ULONG aNbProperties, nsStringArray& aValues) ;
      // Get the value of a MAPI property of type SYSTIME
!     virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD& aYear, WORD& aMonth, WORD& aDay) ;
      // Get the value of a MAPI property of type BIN
      BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
      // Tests if a container contains an entry
      BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Set the value of a MAPI property of type string in unicode
!     virtual BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                               const PRUnichar *aValue) ;
      // Same as previous, but with a bunch of properties in one call
      BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
***************
*** 117,148 ****
      BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD aYear, WORD aMonth, WORD aDay) ;
      // Create entry in the address book
!     BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Create a distribution list in the address book
!     BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Copy an existing entry in the address book
!     BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
      // Get a default address book container
!     BOOL GetDefaultContainer(nsMapiEntry& aContainer) ;
      // Is the helper correctly initialised?
!     BOOL IsOK(void) const { return mAddressBook != NULL ; }
  
  protected:
      HRESULT mLastError ;
-     LPADRBOOK mAddressBook ;
      static PRUint32 mEntryCounter ;
      static PRLock *mMutex ;
  
      // Retrieve the contents of a container, with an optional restriction
!     BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
!                      nsMapiEntry **aList, ULONG &aNbElements, ULONG aMapiType) ;
      // Retrieve the values of a set of properties on a MAPI object
!     BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                             ULONG aNbProperties,
!                            LPSPropValue& aValues, ULONG& aValueCount) ;
      // Set the values of a set of properties on a MAPI object
!     BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                            const LPSPropValue& aValues) ;
      // Clean-up a rowset returned by QueryRows
      void MyFreeProws(LPSRowSet aSet) ;
      // Allocation of a buffer for transmission to interfaces
--- 145,188 ----
      BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD aYear, WORD aMonth, WORD aDay) ;
      // Create entry in the address book
!     virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
!     // Delete an entry in the address book
!     virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Create a distribution list in the address book
!     virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Copy an existing entry in the address book
!     virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
      // Get a default address book container
!     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer) =0;
      // Is the helper correctly initialised?
!     virtual BOOL IsOK(void) =0;/*const { return mAddressBook != NULL ; }*/
! 
!     // Get the value of a MAPI property of type LONG
!     virtual BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
  
  protected:
      HRESULT mLastError ;
      static PRUint32 mEntryCounter ;
      static PRLock *mMutex ;
  
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     ) = 0;
+ 
      // Retrieve the contents of a container, with an optional restriction
!     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
!                      nsMapiEntryArray *aList, ULONG aMapiType) =0;
      // Retrieve the values of a set of properties on a MAPI object
!     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                             ULONG aNbProperties,
!                            LPSPropValue& aValues, ULONG& aValueCount) =0;
      // Set the values of a set of properties on a MAPI object
!     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                            LPSPropValue& aValues) =0;
      // Clean-up a rowset returned by QueryRows
      void MyFreeProws(LPSRowSet aSet) ;
      // Allocation of a buffer for transmission to interfaces
***************
*** 150,156 ****
--- 190,205 ----
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) = 0 ;
  
+     static void            CStrToUnicode( const char *pStr, nsString& result);
+     static void            UnicodeToCStr( const PRUnichar *pStr, nsCString& result);
+ 
  private:
+     static int                m_clients;
+     static PRUnichar *        m_pUniBuff;
+     static int                m_uniBuffLen;
+     static char *             m_pCStrBuff;
+     static int                m_cstrBuffLen;
+ 
  } ;
  
  enum nsAbWinType 
***************
*** 168,173 ****
--- 217,223 ----
  
      nsAbWinHelper *operator ->(void) { return mHelper ; }
  
+     static void FreeWinAbLibrarys();
  private:
      nsAbWinHelper *mHelper ;
  } ;
*** misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	Wed Dec 24 12:18:08 2003
--- misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	Thu Mar 29 14:27:08 2007
***************
*** 97,102 ****
--- 97,105 ----
  
  static const char kMailListAddressFormat[] = "Address%d";
  
+ extern int getMD5sum(const char * fileName,char * sum);
+ extern int testMD5sum(const char * fileName,char * sum);
+ 
  static NS_DEFINE_CID(kCMorkFactory, NS_MORK_CID);
  
  nsAddrDatabase::nsAddrDatabase()
***************
*** 166,171 ****
--- 169,175 ----
        m_LastRecordKey(0),
        m_dbDirectory(nsnull)
  {
+ 	memset(m_dbMd5Sum,0,33);
  }
  
  nsAddrDatabase::~nsAddrDatabase()
***************
*** 720,726 ****
            NS_RELEASE(oldFile); // always release our file ref, store has own
          }
        }
!       
        nsCRT::free(nativeFileName);
        
        if (NS_SUCCEEDED(ret) && thumb)
--- 724,734 ----
            NS_RELEASE(oldFile); // always release our file ref, store has own
          }
        }
! 
! 	  ret = getMD5sum(nativeFileName,m_dbMd5Sum);
! 	  if (ret == 1)
! 		ret = NS_ERROR_FAILURE;
! 
        nsCRT::free(nativeFileName);
        
        if (NS_SUCCEEDED(ret) && thumb)
***************
*** 817,822 ****
--- 825,841 ----
      nsresult    err = NS_OK;
      nsIMdbThumb    *commitThumb = nsnull;
  
+     const char *pFilename = m_dbName.GetCString(); /* do not free */
+     char    *nativeFileName = nsCRT::strdup(pFilename);
+ #if defined(XP_PC) || defined(XP_MAC)
+       UnixToNative(nativeFileName);
+ #endif
+ 	if (testMD5sum(nativeFileName,m_dbMd5Sum))
+     {
+         nsCRT::free(nativeFileName);
+         return NS_ERROR_FILE_ACCESS_DENIED;
+     }
+ 
    if (commitType == nsAddrDBCommitType::kLargeCommit || commitType == nsAddrDBCommitType::kSessionCommit)
    {
      mdb_percent outActualWaste = 0;
***************
*** 867,872 ****
--- 886,895 ----
      // ### do something with error, but clear it now because mork errors out on commits.
      if (GetEnv())
          GetEnv()->ClearErrors();
+ 	if (NS_SUCCEEDED(err) && getMD5sum(nativeFileName,m_dbMd5Sum))
+ 		err = NS_ERROR_FAILURE;
+     nsCRT::free(nativeFileName);
+ 
      return err;
  }
  
*** misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	Wed Jan 28 12:22:13 2004
--- misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	Thu Mar 29 14:27:08 2007
***************
*** 396,401 ****
--- 396,402 ----
  	nsIMdbTable		    *m_mdbPabTable;
  	nsIMdbTable                 *m_mdbDeletedCardsTable;
  	nsFileSpec		    m_dbName;
+ 	char				m_dbMd5Sum[33];
  	PRBool				m_mdbTokensInitialized;
      nsVoidArray /*<nsIAddrDBListener>*/ *m_ChangeListeners;
  
*** misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	Tue Oct 30 03:59:16 2001
--- misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	Thu Mar 29 14:27:08 2007
***************
*** 41,46 ****
--- 41,62 ----
  
  #include "prlog.h"
  
+ static char * stristr(const char *big, const char *little)
+ {
+     PRUint32 len;
+ 
+     if (!big || !little || !*big || !*little)
+       return 0;
+     len = strlen(little);
+ 
+     for( ; *big; big++ )
+        if(!_strnicmp (big, little, 1) && ! _strnicmp (big, little, len) )
+           return (char *)big;
+ 
+     return (char *)0;
+ 
+ }
+ 
  #ifdef PR_LOGGING
  static PRLogModuleInfo* gMapiAddressBookLog
      = PR_NewLogModule("nsMapiAddressBookLog");
***************
*** 48,53 ****
--- 64,123 ----
  
  #define PRINTF(args) PR_LOG(gMapiAddressBookLog, PR_LOG_DEBUG, args)
  
+ #define    OUTLOOK_EMAIL_DIAPLAY_MAPI_ID    0x00008005  //use to get and set display
+ #define    OUTLOOK_EMAIL1_MAPI_ID           0x00008084  //use to get and set primary email address
+ #define    OUTLOOK_EMAIL2_MAPI_ID           0x00008094  //use to get and set second  email address
+ #define    OUTLOOK_EMAIL_SCREEN_NAME        0x8061001E  //use to get and set screen name
+ #define    OUTLOOK_EMAIL_ORGID              0x00008085  //use to get orginal entryid to add to distlist
+ #define    OUTLOOK_EMAIL_LIST1              0x00008054  //use to get distlist table
+ #define    OUTLOOK_EMAIL_LIST2              0x00008055  //use to set distlist table
+ 
+ static const TagMap TagMaps[]={
+     {PR_DISPLAY_NAME_A,         OUTLOOK_EMAIL_DIAPLAY_MAPI_ID,    PT_STRING8},
+     {PR_EMAIL_ADDRESS_A,        OUTLOOK_EMAIL1_MAPI_ID,           PT_STRING8},
+     {PR_SECOND_EMAIL_ADDRESS_A, OUTLOOK_EMAIL2_MAPI_ID,           PT_STRING8},
+     {PR_SCREEN_NAME_A,          OUTLOOK_EMAIL_SCREEN_NAME,        PT_STRING8}};
+ 
+ enum {
+     ieidPR_ENTRYID = 0,
+     ieidPR_OBJECT_TYPE,
+     ieidPR_DISPLAY_NAME,
+     ieidPR_MESSAGE_CLASS,
+     ieidPR_STORE_ENTRYID,
+     ieidPR_MESSAGE_RECIPIENTS,
+     ieidMax
+ };
+ 
+ static const SizedSPropTagArray(ieidMax, ptaEid)=
+ {
+     ieidMax,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE,
+         PR_DISPLAY_NAME,
+         PR_MESSAGE_CLASS,
+         PR_STORE_ENTRYID,
+         PR_MESSAGE_RECIPIENTS
+     }
+ };
+ 
+ enum
+ {
+     ContentsColumnEntryId = 0,
+     ContentsColumnObjectType,
+     ContentsColumnMessageClass,
+     ContentsColumnsSize
+ } ;
+ 
+ static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+ {
+     ContentsColumnsSize,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE,
+         PR_MESSAGE_CLASS
+     }
+ } ;
  
  HMODULE nsMapiAddressBook::mLibrary = NULL ;
  PRInt32 nsMapiAddressBook::mLibUsage = 0 ;
***************
*** 60,66 ****
  BOOL nsMapiAddressBook::mInitialized = FALSE ;
  BOOL nsMapiAddressBook::mLogonDone = FALSE ;
  LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
! LPADRBOOK nsMapiAddressBook::mRootBook = NULL ;
  
  BOOL nsMapiAddressBook::LoadMapiLibrary(void)
  {
--- 130,136 ----
  BOOL nsMapiAddressBook::mInitialized = FALSE ;
  BOOL nsMapiAddressBook::mLogonDone = FALSE ;
  LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
! #define MAPI_NO_COINIT 8
  
  BOOL nsMapiAddressBook::LoadMapiLibrary(void)
  {
***************
*** 92,98 ****
      mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
          GetProcAddress(mLibrary, "MAPILogonEx")) ;
      if (!mMAPILogonEx) { return FALSE ; }
!     MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS } ;
      HRESULT retCode = mMAPIInitialize(&mapiInit) ;
  
      if (HR_FAILED(retCode)) { 
--- 162,168 ----
      mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
          GetProcAddress(mLibrary, "MAPILogonEx")) ;
      if (!mMAPILogonEx) { return FALSE ; }
!     MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS | MAPI_NO_COINIT } ;
      HRESULT retCode = mMAPIInitialize(&mapiInit) ;
  
      if (HR_FAILED(retCode)) { 
***************
*** 106,127 ****
                             MAPI_NEW_SESSION,
                             &mRootSession) ;
      if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ; return FALSE ;
      }
      mLogonDone = TRUE ;
!     retCode = mRootSession->OpenAddressBook(0, NULL, 0, &mRootBook) ;
!     if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot open MAPI address book %08x.\n", retCode)) ;
!     }
      return HR_SUCCEEDED(retCode) ;
  }
  
  void nsMapiAddressBook::FreeMapiLibrary(void)
  {
      if (mLibrary) {
!         if (-- mLibUsage == 0) {
              {
-                 if (mRootBook) { mRootBook->Release() ; }
                  if (mRootSession) {
                      if (mLogonDone) { 
                          mRootSession->Logoff(NULL, 0, 0) ; 
--- 176,194 ----
                             MAPI_NEW_SESSION,
                             &mRootSession) ;
      if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ;
!         return FALSE ;
      }
      mLogonDone = TRUE ;
! 
      return HR_SUCCEEDED(retCode) ;
  }
  
  void nsMapiAddressBook::FreeMapiLibrary(void)
  {
      if (mLibrary) {
!         if (--mLibUsage < 0) {
              {
                  if (mRootSession) {
                      if (mLogonDone) { 
                          mRootSession->Logoff(NULL, 0, 0) ; 
***************
*** 135,140 ****
--- 202,208 ----
                  }
              }  
              FreeLibrary(mLibrary) ;
+             mRootSession = NULL;
              mLibrary = NULL ; 
          }
      }
***************
*** 146,152 ****
  : nsAbWinHelper()
  {
      BOOL result = Initialize() ;
- 
      NS_ASSERTION(result == TRUE, "Couldn't initialize Mapi Helper") ;
      MOZ_COUNT_CTOR(nsMapiAddressBook) ;
  }
--- 214,219 ----
***************
*** 154,175 ****
  nsMapiAddressBook::~nsMapiAddressBook(void)
  {
      nsAutoLock guard(mMutex) ;
! 
      FreeMapiLibrary() ;
      MOZ_COUNT_DTOR(nsMapiAddressBook) ;
  }
  
  BOOL nsMapiAddressBook::Initialize(void)
  {
!     if (mAddressBook) { return TRUE ; }
      nsAutoLock guard(mMutex) ;
  
      if (!LoadMapiLibrary()) {
          PRINTF(("Cannot load library.\n")) ;
          return FALSE ;
      }
!     mAddressBook = mRootBook ; 
!     return TRUE ;
  }
  
  void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
--- 221,1102 ----
  nsMapiAddressBook::~nsMapiAddressBook(void)
  {
      nsAutoLock guard(mMutex) ;
!     CleanUpMDB();
      FreeMapiLibrary() ;
      MOZ_COUNT_DTOR(nsMapiAddressBook) ;
  }
  
+ LPSPropValue nsMapiAddressBook::GetMapiProperty( LPMAPIPROP pProp, ULONG tag)
+ {
+     if (!pProp)
+         return( NULL);
+ 
+     int    sz = CbNewSPropTagArray( 1);
+     SPropTagArray *pTag = (SPropTagArray *) new char[sz];
+     pTag->cValues = 1;
+     pTag->aulPropTag[0] = tag;
+     LPSPropValue    lpProp = NULL;
+     ULONG    cValues = 0;
+     HRESULT hr = pProp->GetProps( pTag, 0, &cValues, &lpProp);
+     delete pTag;
+     if (HR_FAILED( hr) || (cValues != 1)) {
+         if (lpProp)
+             mMAPIFreeBuffer( lpProp);
+         return( NULL);
+     }
+     else {
+         if (PROP_TYPE( lpProp->ulPropTag) == PT_ERROR) {
+             if (lpProp->Value.l == MAPI_E_NOT_FOUND) {
+                 mMAPIFreeBuffer( lpProp);
+                 lpProp = NULL;
+             }
+         }
+     }
+ 
+     return( lpProp);
+ }
+ BOOL nsMapiAddressBook::GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal)
+ {
+     if (!pVal)
+         return( FALSE);
+     
+     BOOL bResult = TRUE;
+     switch (PROP_TYPE(pVal->ulPropTag))
+     {
+         case PT_BINARY:
+             cbEntryId = pVal->Value.bin.cb;
+             mMAPIAllocateBuffer( cbEntryId, (LPVOID *) &lpEntryId);
+             memcpy( lpEntryId, pVal->Value.bin.lpb, cbEntryId);
+         break;
+ 
+         default:
+             PRINTF(( "EntryId not in BINARY prop value\n"));
+             bResult = FALSE;
+         break;
+     }
+ 
+     if (pVal && delVal)
+         mMAPIFreeBuffer( pVal);
+ 
+     return( bResult);
+ }
+ 
+ BOOL nsMapiAddressBook::HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+ {
+     LPMDB  lpMsgStore;
+     ULONG objType=0;
+     HRESULT             hr;
+ 
+     if (oType == MAPI_MESSAGE)
+         return FALSE;
+     if (oType == MAPI_STORE)
+     {
+         hr=mRootSession->OpenEntry(
+                     cb,
+                     pEntry,
+                     &IID_IMsgStore,
+                     MAPI_BEST_ACCESS,
+                     &objType,
+                     (IUnknown**)&lpMsgStore);
+         if (FAILED(hr))
+         return FALSE ;
+         //Add MDB to a list to make it can be released when class  destroyed.
+         //We must leave it openned or else we can't open address store in it.
+         AddToMDBArray(lpMsgStore);
+ 
+         LPSPropValue    pVal;
+         pVal=GetMapiProperty(lpMsgStore,PR_IPM_SUBTREE_ENTRYID);
+         
+         
+         if (pVal) {
+             ULONG            cbEntry;
+             LPENTRYID        pEntry;
+             nsMapiInterfaceWrapper<LPMAPICONTAINER> lpSubTree;
+ 
+             if (GetEntryIdFromProp( pVal, cbEntry, pEntry)) {
+                 // Open up the folder!
+                 BOOL bResult = TRUE;
+                 bResult = lpMsgStore->OpenEntry(
+                                 cbEntry,
+                                 pEntry,
+                                 NULL,
+                                 MAPI_BEST_ACCESS,
+                                 &objType,
+                                 lpSubTree);
+                 mMAPIFreeBuffer( pEntry);
+                 if (!bResult && *(LPMAPICONTAINER*)&lpSubTree) {
+                     // Iterate the subtree with the results going into the folder list
+                     bResult = IterateHierarchy(*(LPMAPICONTAINER*)&lpSubTree,aFolders);
+     }
+                 else {
+                     PRINTF(( "GetStoreFolders: Error opening sub tree.\n"));
+                 }
+             }
+             else {
+                 PRINTF(( "GetStoreFolders: Error getting entryID from sub tree property val.\n"));
+     }
+         }
+         else {
+             PRINTF(( "GetStoreFolders: Error getting sub tree property.\n"));
+         }
+     }
+     else
+     {
+         PRINTF(("Type:%d\n",oType));
+     }
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::IterateHierarchy(LPMAPICONTAINER pFolder,nsMapiEntryArray& aFolders, ULONG flags)
+ {
+     // flags can be CONVENIENT_DEPTH or 0
+     // CONVENIENT_DEPTH will return all depths I believe instead
+     // of just children
+     HRESULT        hr;
+     nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+     hr = pFolder->GetHierarchyTable( CONVENIENT_DEPTH , lpTable);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: GetContentsTable failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+ }
+ 
+     ULONG rowCount;
+     hr = lpTable->GetRowCount( 0, &rowCount);
+     if (!rowCount) {
+         return( TRUE);
+     }
+ 
+     hr = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: SetColumns failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+     }
+ 
+     hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: SeekRow failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+     }
+ 
+     int            cNumRows = 0;
+     LPSRowSet    lpRow;
+     BOOL        keepGoing = TRUE;
+     BOOL        bResult = TRUE;
+     do {
+         
+         lpRow = NULL;
+         hr = lpTable->QueryRows( 1, 0, &lpRow);
+ 
+         if (HR_FAILED(hr))
+ {
+             PRINTF(( "QueryRows failed: 0x%lx, %d\n", (long)hr, (int)hr));
+             bResult = FALSE;
+             break;
+         }
+ 
+         if (lpRow){
+             cNumRows = lpRow->cRows;
+ 
+             if (cNumRows) {
+                 LPENTRYID    lpEntry = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                 ULONG        cb = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                 ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+                 
+                 keepGoing = HandleHierarchyItem( oType, cb, lpEntry,aFolders);
+ 
+             }
+             MyFreeProws(lpRow);
+         }
+ 
+     } while ( SUCCEEDED(hr) && cNumRows && lpRow && keepGoing);
+ 
+     
+     if (bResult && !keepGoing)
+         bResult = FALSE;
+ 
+     return( bResult);
+ }
+ BOOL nsMapiAddressBook::HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+ {
+     ULONG objType=0;
+     if (oType == MAPI_FOLDER)
+     {
+         nsMapiInterfaceWrapper<LPMAPICONTAINER> pFolder ;
+         if (!mRootSession->OpenEntry(
+                         cb,
+                         pEntry,
+                         0,
+                         MAPI_BEST_ACCESS,
+                         &objType,
+                         pFolder))
+         {
+             LPSPropValue        pVal;
+ 
+ 
+             pVal = GetMapiProperty(*(LPMAPICONTAINER*)&pFolder, PR_CONTAINER_CLASS);
+             if (pVal)
+             {
+                 if (strcmp("IPF.Contact",pVal->Value.lpszA) == 0)
+                 {
+                     SPropValue *currentValue=GetMapiProperty( *(LPMAPICONTAINER*)&pFolder, PR_ENTRYID);
+                     
+                     aFolders.AddItem(currentValue->Value.bin.cb,
+                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue->Value.bin.lpb)) ;
+ 
+                 }
+             }
+         }
+     }
+     else
+     {
+         PRINTF(( "GetStoreFolders - HandleHierarchyItem: Unhandled ObjectType: %ld\n", oType));
+     }
+ 
+     return( TRUE);
+ }
+ 
+ 
+ BOOL nsMapiAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+ {
+     aFolders.CleanUp() ;
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> rootFolder ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+     nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+ 
+     mLastError = mRootSession->GetMsgStoresTable( 0, lpTable);
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open MAPI MsgStores %08x.\n", mLastError));
+         return mLastError;
+     }
+ 
+     mLastError = lpTable->GetRowCount( 0, &rowCount);
+ 
+     mLastError = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+     if (FAILED(mLastError))
+         return( mLastError);
+     mLastError = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+     if (FAILED(mLastError))
+         return mLastError;
+     
+     int            cNumRows = 0;
+     LPSRowSet    lpRow;
+     BOOL        keepGoing = TRUE;
+     BOOL        bResult = TRUE;
+     do {
+         
+         lpRow = NULL;
+         mLastError = lpTable->QueryRows( 1, 0, &lpRow);
+ 
+         if (HR_FAILED(mLastError)){
+             bResult = FALSE;
+             break;
+         }
+ 
+         if (lpRow){
+             cNumRows = lpRow->cRows;
+ 
+             if (cNumRows) {
+                 LPENTRYID    lpEID = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                 ULONG        cbEID = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                 ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+ 
+ 
+                 keepGoing = HandleContentsItem( oType, cbEID, lpEID,aFolders);
+             }
+             MyFreeProws( lpRow);
+         }
+ 
+     } while ( SUCCEEDED(mLastError) && cNumRows && lpRow && keepGoing);
+ 
+     
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ BOOL nsMapiAddressBook::CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction)
+ {
+     ULONG conditionType = 0 ;
+     ULONG ulResIndex;
+     if (!aRestriction)
+         return FALSE;
+     for (ulResIndex=0;ulResIndex < aRestrictionNum;ulResIndex++)
+     {
+         conditionType = aRestriction[ulResIndex].rt;
+         switch (conditionType) 
+         {
+         case RES_EXIST  :
+             aRestriction[ulResIndex].res.resExist.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resExist.ulPropTag);
+             break ;
+         case RES_BITMASK  :
+             aRestriction[ulResIndex].res.resBitMask.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resBitMask.ulPropTag);
+             break ;
+         case RES_CONTENT :
+             aRestriction[ulResIndex].res.resContent.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.ulPropTag);
+             aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag);
+             break ;
+         case RES_PROPERTY :
+             aRestriction[ulResIndex].res.resProperty.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.ulPropTag);
+             aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag);
+             break ;
+         case RES_SIZE :
+             aRestriction[ulResIndex].res.resSize.ulPropTag = 
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resSize.ulPropTag);
+             break ;
+         case RES_COMPAREPROPS :
+             aRestriction[ulResIndex].res.resCompareProps.ulPropTag1 =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag1);
+             aRestriction[ulResIndex].res.resCompareProps.ulPropTag2 =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag2);
+             break ;
+         case RES_NOT :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resNot.lpRes);
+             break;
+         case RES_AND :
+             CorrectRestriction(aMapiProp,
+                                 aRestriction[ulResIndex].res.resAnd.cRes,
+                                 aRestriction[ulResIndex].res.resAnd.lpRes);
+             break;
+         case RES_OR :
+             CorrectRestriction(aMapiProp,
+                                 aRestriction[ulResIndex].res.resOr.cRes,
+                                 aRestriction[ulResIndex].res.resOr.lpRes);
+             break;
+ 
+         case RES_COMMENT :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resComment.lpRes);
+             aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag);
+             break;
+         case RES_SUBRESTRICTION :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resSub.lpRes);
+             break;
+         default:
+             return FALSE;
+         }
+     }
+     return TRUE;
+ }
+ BOOL nsMapiAddressBook::Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList)
+ {
+     if (!aRestriction)
+         return FALSE;
+ 
+     ULONG conditionType = 0 ;
+ 
+     nsMapiEntryArray listOut;
+     ULONG listindex=0;
+     
+     nsMapiEntryArray listDel;
+     ULONG delindex=0;
+ 
+     ULONG listsize;
+     ULONG resCount = 0;
+     ULONG resIndex = 0;
+ 
+     listsize = aList->GetSize();
+     conditionType = aRestriction->rt;
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+     case RES_BITMASK  :
+     case RES_CONTENT :
+     case RES_PROPERTY :
+     case RES_SIZE :
+     case RES_COMPAREPROPS :
+     case RES_COMMENT :
+     case RES_SUBRESTRICTION :
+         {
+             while(listindex < aList->GetSize())
+             {
+                 if (!FilterOnOneRow(aList->ElementAt(listindex),aRestriction))
+                     aList->Remove(listindex);
+                 else
+                     listindex++;
+             }
+         }
+         break;
+     case RES_NOT :
+         aRestriction->res.resNot.ulReserved = 1;
+     case RES_AND :
+     case RES_OR :
+         {
+             if (conditionType == RES_OR)
+             {
+                 for(listindex=0;listindex<aList->GetSize();listindex++)
+                 {
+                     listDel.AddItem(aList->ElementAt(listindex));
+                 }
+             }
+ 
+             resCount = aRestriction->res.resAnd.cRes;
+             //notice that SAndRestriction ,SNotRestriction ,SOrRestriction
+             //use the same struct
+             for (resIndex = 0;resIndex < resCount;resIndex++)
+             {
+                 //can't call listOut.CleanUp() here
+                 //because it will destroy all Element too
+                 while(listOut.GetSize())
+                 {
+                     listOut.Remove(0);
+                 }
+ 
+                 for(listindex=0;listindex<aList->GetSize();listindex++)
+                 {
+                     listOut.AddItem(aList->ElementAt(listindex));
+                 }
+ 
+                 Filter(&aRestriction->res.resAnd.lpRes[resIndex],&listOut);
+                 if (conditionType == RES_NOT)
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         aList->Remove(listOut.ElementAt(listindex));
+                     }
+                 }
+                 else if (conditionType == RES_AND )
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         if (!aList->IndexOf(listOut.ElementAt(listindex)))
+                         {
+                             aList->Remove(listOut.ElementAt(listindex));
+                         }
+                     }
+                 }
+                 else if (conditionType == RES_OR )
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         listDel.Remove(listOut.ElementAt(listindex));
+                     }
+                     if (listDel.GetSize() == 0)
+                     {
+                         break;
+                     }
+                 }
+             }
+             if (conditionType == RES_OR)
+             {
+                 for(listindex=0;listindex<listDel.GetSize();listindex++)
+                 {
+                     aList->Remove(listDel.ElementAt(listindex));
+                 }
+             }
+         }
+ 
+     }
+     while(listDel.GetSize())
+     {
+         listDel.Remove(0);
+     }
+     while(listOut.GetSize())
+     {
+         listOut.Remove(0);
+     }
+ 
+ 
+     return TRUE;
+ }
+ 
+ BOOL nsMapiAddressBook::FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction)
+ {
+     LPMAPIPROP object ;
+     ULONG objType = 0 ;
+     LPSPropValue realValue = NULL ;
+     LPSPropValue resValue  = NULL ;
+      ULONG valueCount = 0 ;
+    
+     mLastError = OpenEntry(aEntry->mByteCount, aEntry->mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                          (IUnknown **)&object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     
+     ULONG conditionType = 0 ;
+     conditionType = aRestriction->rt;
+ 
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resExist.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = NULL;
+         break ;
+     case RES_CONTENT :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resContent.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = aRestriction->res.resContent.lpProp;
+         break ;
+     case RES_PROPERTY :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resProperty.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = aRestriction->res.resProperty.lpProp;
+         break ;
+     case RES_BITMASK  :
+         return FALSE; //not support
+         break ;
+     case RES_SIZE :
+         return FALSE;//not been used now
+         break ;
+     case RES_COMPAREPROPS :
+         return FALSE;//not been used now
+         break ;
+     case RES_NOT :
+         return FALSE;//not need care here
+         break;
+     case RES_AND :
+         return FALSE;//not need care here
+         break;
+     case RES_OR :
+         return FALSE;//not need care here
+         break;
+     case RES_COMMENT :
+         return TRUE;//comment
+         break;
+     case RES_SUBRESTRICTION :
+         return FALSE;//not been used now
+         break ;
+ }
+     return AtomyFilter(aRestriction,realValue,resValue);
+ 
+ }
+ 
+ BOOL nsMapiAddressBook::AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue)
+ {
+     ULONG conditionType = 0 ;
+     conditionType = aRestriction->rt;
+ 
+     BOOL bTagEq=(aRealValue &&
+                 PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) && 
+                 aFilterValue;
+                 // PROP_TYPE( aRealValue->ulPropTag ) == PROP_TYPE( aFilterValue->ulPropTag ));
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+         return (aRealValue && PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) ;
+         break ;
+     case RES_CONTENT :
+         if (bTagEq)
+         {
+             switch(aRestriction->res.resContent.ulFuzzyLevel)
+             {
+             case FL_FULLSTRING :
+                 return !stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA);
+                 break;
+             case FL_PREFIX :
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == aRealValue->Value.lpszA;
+                 break;
+             case FL_SUBSTRING :
+             default:
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                 break;
+             }
+         }
+         return FALSE;
+         break ;
+     case RES_PROPERTY :
+         if (bTagEq)
+         {
+             switch(aRestriction->res.resProperty.relop)
+             {
+             case RELOP_GE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) >= 0;
+                 break;
+             case RELOP_GT :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) > 0;
+                 break;
+             case RELOP_LE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) <= 0;
+                 break;
+             case RELOP_LT :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) < 0;
+                 break;
+             case RELOP_EQ :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == 0;
+                 break;
+             case RELOP_NE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != 0;
+                 break;
+             case RELOP_RE :
+             default:
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                 break;
+ 
+             }
+         }
+         return FALSE;
+         break ;
+     case RES_BITMASK  :
+         return FALSE; //not support
+         break ;
+     case RES_SIZE :
+         return FALSE;//not been used now
+         break ;
+     case RES_COMPAREPROPS :
+         return FALSE;//not been used now
+         break ;
+     case RES_NOT :
+         return FALSE;//not need care here
+         break;
+     case RES_AND :
+         return FALSE;//not need care here
+         break;
+     case RES_OR :
+         return FALSE;//not need care here
+         break;
+     case RES_COMMENT :
+         return TRUE;//comment
+         break;
+     case RES_SUBRESTRICTION :
+         return FALSE;//not been used now
+         break ;
+     }
+     return TRUE;
+ }
+ 
+ BOOL nsMapiAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                 nsMapiEntryArray *aList, ULONG aMapiType)
+ {
+     if (aList)
+         aList->CleanUp();
+ 
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> pFolder;
+     nsCString cs;
+     aParent.ToString(cs);
+     
+     mLastError = OpenEntry(aParent.mByteCount,     aParent.mEntryId,
+                     0, MAPI_BEST_ACCESS, &objType, pFolder);
+     if (HR_FAILED(mLastError))
+     {
+         PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+ 
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&pFolder,PR_MESSAGE_CLASS);
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+     {
+         HRESULT             hr;
+         LPSPropValue aValue = NULL ;
+         ULONG aValueCount = 0 ;
+ 
+         LPSPropTagArray properties = NULL ;
+         mMAPIAllocateBuffer(CbNewSPropTagArray(1),
+                            (void **)&properties);
+         properties->cValues = 1;
+         properties->aulPropTag [0] = GetEmailPropertyTag(*(LPMAPIPROP*)&pFolder,OUTLOOK_EMAIL_LIST1);
+         hr = pFolder->GetProps(properties, 0, &aValueCount, &aValue) ;
+ 
+         SBinaryArray *sa=&aValue->Value.MVbin;
+ 
+         LPENTRYID    lpEID;
+         ULONG        cbEID;
+         
+         ULONG idx;
+         nsMapiEntry testEntry;
+         nsCString sClass;
+         for (idx=0;sa->lpbin && idx<sa->cValues ;idx++)
+         {
+             lpEID= (LPENTRYID) sa->lpbin[idx].lpb;
+             cbEID = sa->lpbin[idx].cb;
+             testEntry.Assign(sa->lpbin[idx].cb,NS_REINTERPRET_CAST(LPENTRYID,sa->lpbin[idx].lpb));
+             
+             if (GetPropertyString(testEntry,PR_MESSAGE_CLASS,sClass)) //Error get property
+             {
+                 aList->AddItem(cbEID,lpEID);
+             }
+         }
+         Filter(aRestriction,aList);
+     }
+     else
+     {
+         if (aRestriction && !CorrectRestriction(*(LPMAPICONTAINER*)&pFolder,1,aRestriction))
+             return FALSE;
+         mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIContainer, MAPI_BEST_ACCESS, &objType,
+                                          parent) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+ 
+         mLastError = parent->GetContentsTable(0, contents) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+             return FALSE;
+         }
+         if (aRestriction) {
+             mLastError = contents->Restrict(aRestriction, TBL_BATCH) ;
+             if (HR_FAILED(mLastError)) {
+                 PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+                 return FALSE ;
+             }
+         }
+         mLastError = contents->SetColumns((LPSPropTagArray)&ContentsColumns, 0);
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         mLastError = contents->GetRowCount(0, &rowCount) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         do {
+             LPSRowSet rowSet = NULL ;
+ 
+             rowCount = 0 ;
+             mLastError = contents->QueryRows(1, 0, &rowSet) ;
+             if (HR_FAILED(mLastError)) {
+                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+                 return FALSE ;
+             }
+             rowCount = rowSet->cRows ;
+             if (rowCount > 0 && aList)
+             {
+                 if (aMapiType == 0 || rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)
+                 {
+                     SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                     aList->AddItem(currentValue.Value.bin.cb,
+                         NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 }
+                 else if (aMapiType == MAPI_DISTLIST)
+                 {
+                     if (strcmp("IPM.DistList",rowSet->aRow->lpProps[ContentsColumnMessageClass].Value.lpszA)==0)
+                     {
+                         SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                         aList->AddItem(currentValue.Value.bin.cb,
+                             NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+ 
+                     }
+ }
+ 
+             }
+             MyFreeProws(rowSet) ;
+         } while (rowCount > 0) ;
+     }
+ 
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags,
+                                       ULONG aNbProperties, LPSPropValue& aValue,
+                                       ULONG& aValueCount)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     LPSPropTagArray properties = NULL ;
+     ULONG i = 0 ;
+     
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                    NS_REINTERPRET_CAST(void **, &properties));
+     properties->cValues = aNbProperties ;
+     for (i = 0 ; i < aNbProperties ; ++ i)
+     {
+         properties->aulPropTag [i] = GetRealMapiPropertyTag(*(LPMAPIPROP*)&object,aPropertyTags [i],TRUE);
+     }
+     mLastError = object->GetProps(properties, 0 , &aValueCount, &aValue) ;
+     FreeBuffer(properties) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Error get props %08x.\n", mLastError)) ;
+     }
+     return HR_SUCCEEDED(mLastError);
+ }
+ 
+ BOOL nsMapiAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                       LPSPropValue& aValues)
+ {
+     nsMapiInterfaceWrapper<LPMESSAGE> object;
+     ULONG objType = 0 ;
+     LPSPropProblemArray problems = NULL ;
+     ULONG i = 0 ;
+ 
+     LPMDB lpMsgStore=GetMsgStore(aObject);
+     
+     if (!lpMsgStore)
+     {
+         return FALSE;
+     }
+     mLastError = lpMsgStore->OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                          object) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     for (i = 0 ; i < aNbProperties ; ++ i)
+     {
+         aValues[i].ulPropTag = GetRealMapiPropertyTag(*(LPMESSAGE*)&object,aValues[i].ulPropTag,TRUE);
+     }
+     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (problems) {
+         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+             PRINTF(("Problem %d: index %d code %08x.\n", i,
+                 problems->aProblem [i].ulIndex,
+                 problems->aProblem [i].scode)) ;
+         }
+     }
+     mLastError = object->SaveChanges(0) ;
+     if (MAPI_E_OBJECT_CHANGED == mLastError)
+     {
+         mLastError = object->SaveChanges(FORCE_SAVE ) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+ {
+     return FALSE ;
+ }
+ 
+ BOOL nsMapiAddressBook::IsOK(void)
+ {
+     return mRootSession && mLibUsage;
+ }
+ 
  BOOL nsMapiAddressBook::Initialize(void)
  {
! 
      nsAutoLock guard(mMutex) ;
  
      if (!LoadMapiLibrary()) {
          PRINTF(("Cannot load library.\n")) ;
          return FALSE ;
      }
!     return TRUE;
  }
  
  void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
***************
*** 182,188 ****
--- 1109,1911 ----
      mMAPIFreeBuffer(aBuffer) ;
  }
  
+ ULONG nsMapiAddressBook::GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID)
+ {
+     static GUID emailGUID =
+     {
+        0x00062004, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
+     };
+ 
+ 
+   MAPINAMEID mapiNameID;
+   mapiNameID.lpguid = &emailGUID;
+   mapiNameID.ulKind = MNID_ID;
+   mapiNameID.Kind.lID = nameID;
+ 
+   LPMAPINAMEID lpMapiNames = &mapiNameID;
+   LPSPropTagArray lpMailTagArray = NULL;
+ 
+   HRESULT result = lpProp->GetIDsFromNames(1L, &lpMapiNames, 0, &lpMailTagArray);
+   if (result == S_OK)
+   {
+     ULONG lTag = lpMailTagArray->aulPropTag[0];
+     mMAPIFreeBuffer(lpMailTagArray);
+     return lTag;
+   }
+   return 0L;
+ }
+ ULONG nsMapiAddressBook::GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest)
+ {
+     LPSPropValue addr;
+     ULONG        upRealTag=aPropertyTag;
+     ULONG        lSize=sizeof(TagMaps) / sizeof(TagMap);
+     
+     for(int i=0; i<lSize; i++)
+     {
+         if (TagMaps[i].AddressTag == aPropertyTag)
+         {
+ 
+             ULONG kPriEmailColumn=GetEmailPropertyTag(lpProp,TagMaps[i].NameID);
+             if (aTest)
+             {
+                 if (PR_DISPLAY_NAME_A == aPropertyTag)
+                 {
+                     //We need not change PR_DISPLAY_NAME_A tag if we are not using an address
+                     LPSPropValue msgClass=GetMapiProperty(lpProp,PR_MESSAGE_CLASS);
+                     if (msgClass && !strcmp("IPM.Contact",msgClass->Value.lpszA))
+                     {
+                         if (kPriEmailColumn)
+                             upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                     }
+                     else
+                     {
+                         FreeBuffer(msgClass);
+                         upRealTag = aPropertyTag;
+                     }
+                 }
+                 else //PR_DISPLAY_NAME_A == aPropertyTag
+                 {
+                     addr=GetMapiProperty(lpProp,aPropertyTag);
+                     if (!addr || PROP_TYPE( addr->ulPropTag) == PT_ERROR ||
+                         addr->Value.l == MAPI_E_NOT_FOUND)
+                     {
+                         if (kPriEmailColumn)
+                             upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                     }
+                 }
+             }
+             else //aTest
+             {
+                 if (kPriEmailColumn)
+                     upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+             }
+       
+             break; //we find it,exit
+         }
+     }
+ 
+     return upRealTag;
+ }
+ 
+ BOOL nsMapiAddressBook::GetPropertyLong(const nsMapiEntry& aObject,
+                                     ULONG aPropertyTag,
+                                     ULONG& aValue)
+ {
+     aValue = 0 ;
+     LPSPropValue values = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (PR_OBJECT_TYPE == aPropertyTag)
+     {
+         nsMapiInterfaceWrapper<LPMAPIFOLDER> pFolder ;
+         ULONG objType=0;
+         mLastError = OpenEntry(aObject.mByteCount,aObject.mEntryId,
+                          NULL,MAPI_BEST_ACCESS,&objType, pFolder);
+         if (HR_FAILED(mLastError))
+         {
+             PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+             return FALSE;
+         }
+         LPSPropValue msgClass=GetMapiProperty(*(LPMAPIFOLDER*)&pFolder,PR_MESSAGE_CLASS);
+         if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         {
+             FreeBuffer(msgClass);
+             aValue = MAPI_DISTLIST;
+             return TRUE;
+         }
+     }
  
+     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) 
+         return FALSE ;
  
+     if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_LONG) {
+         aValue = values->Value.ul ;
+     }
+     FreeBuffer(values) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                                     WORD& aYear, WORD& aMonth, WORD& aDay)
+ {
+     aYear = 0;
+     aMonth = 0;
+     aDay = 0;
+     LPSPropValue values = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount))
+         return FALSE ;
+ 
+     if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
+         SYSTEMTIME readableTime ;
+         FILETIME   localTime ;
+         FileTimeToLocalFileTime(&values->Value.ft,&localTime);
+         if (FileTimeToSystemTime(&localTime, &readableTime)) {
+             aYear = readableTime.wYear ;
+             aMonth = readableTime.wMonth ;
+             aDay = readableTime.wDay ;
+         }
+     }
+     FreeBuffer(values) ;
+     return TRUE ;
+ }
+ 
+ HRESULT     nsMapiAddressBook::OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     )
+ {
+ 
+     int err;
+     HRESULT rv;
+     __try
+     {
+         rv=mRootSession->OpenEntry(cbEntryID,
+                     lpEntryID,
+                     lpInterface,
+                     ulFlags ,
+                     lpulObjType,
+                     lppUnk
+                     );
+     }__except(err)
+     {
+         return (-1);
+     }
+ 
+     if (HR_FAILED(rv) && !m_MDBArray.Count())
+     {
+         //There are no openned Message store,so we have to open them all
+         nsMapiEntryArray aFolders;
+         if (GetFolders(aFolders))
+         {
+             __try
+             {
+                 rv=mRootSession->OpenEntry(cbEntryID,
+                             lpEntryID,
+                             lpInterface,
+                             ulFlags ,
+                             lpulObjType,
+                             lppUnk
+                             );
+             }__except(err)
+             {
+                 return (-1);
+             }
+         }
+     }
+     return rv;
+ 
+ }
+ 
+ BOOL nsMapiAddressBook::AddEntryToList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+         return FALSE;
+     
+     LPMDB lpMsgStore=GetMsgStore(parentEntry);
+     
+     if (!lpMsgStore)
+         return FALSE;
+     mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))       
+         return FALSE ;
+     
+ 
+     /*
+     When add mail address to distlist,Mapi need update 2 tag.
+     */
+     //update OUTLOOK_EMAIL_LIST1
+     ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+     SBinaryArray oldChilds;
+     LPSBinary    bins=NULL;
+     SBinaryArray newChilds;
+     LPSPropValue oldChildValue = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues + 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (ULONG i=0;i<oldChilds.cValues;i++)
+         {
+             newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+             newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
+ 
+     nsMapiEntry orgEntryID;
+     if (!GetPropertyBin(aNewEntry,
+         GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_ORGID) | PT_BINARY,
+         orgEntryID))
+     {
+         return FALSE;
+     }
+     newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+     newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+ 
+     SPropValue childs;
+     childs.ulPropTag = listTag;
+     childs.Value.MVbin = newChilds;
+ 
+     LPSPropProblemArray problems = NULL ;
+     mLastError = container->SetProps(1, &childs, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     //update OUTLOOK_EMAIL_LIST2
+     listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+     
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues + 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (ULONG i=0;i<oldChilds.cValues;i++)
+         {
+             newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+             newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
+ 
+     /*
+     Need more work here.
+     There are two kind of mail address in outlook DistList.
+     One is sample,not include in parent folder.
+     The other is a link to a unattached address in parents folders.
+     Currently we can only add first kind of address to a outlook distlist.
+     */
+     
+     newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+     newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+ 
+     childs.ulPropTag = listTag;
+     childs.Value.MVbin = newChilds;
+ 
+     mLastError = container->SetProps(1, &childs, &problems) ;
+     if (HR_FAILED(mLastError))
+     {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mMAPIFreeBuffer(bins);
+ 
+     mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     return TRUE ;
+ }
+ BOOL nsMapiAddressBook::DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+         return FALSE;
+ 
+     LPMDB lpMsgStore=GetMsgStore(parentEntry);
+     if (!lpMsgStore)
+         return FALSE;
+ 
+     mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))
+         return FALSE ;
+     /*
+     When delete mail address from distlist,Mapi need update 2 tag.
+     */
+     //update OUTLOOK_EMAIL_LIST1
+     ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+ 
+     SBinaryArray oldChilds;
+     LPSBinary    bins=NULL;
+     SBinaryArray newChilds;
+     LPSPropValue oldChildValue = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     newChilds.lpbin=NULL;
+ 
+     ULONG lDeleteEntry=0;
+     ULONG newIndex=0;
+     ULONG oldIndex=0;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+     
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues - 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+         {
+             if ( oldChilds.lpbin[oldIndex].cb == aNewEntry.mByteCount &&
+                 !memcmp((void*)(oldChilds.lpbin[oldIndex].lpb+4),
+                         (void*)(aNewEntry.mEntryId->ab),
+                         oldChilds.lpbin[oldIndex].cb-4))
+             {
+                 lDeleteEntry=oldIndex;
+             }
+             else
+             {
+                 newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                 newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                 newIndex++;
+             }
+         }
+     }
+     else
+         return FALSE;
+ 
+ 
+     SPropValue childs;
+     LPSPropProblemArray problems = NULL ;
+     
+     if (newChilds.cValues == 0)
+     {
+         SPropTagArray delTags;
+         delTags.cValues = 1;
+         delTags.aulPropTag[0] = listTag;
+ 
+         mLastError = container->DeleteProps(&delTags, &problems) ;
+     }
+     else
+     {
+         childs.ulPropTag = listTag;
+         childs.Value.MVbin = newChilds;
+         mLastError = container->SetProps(1, &childs, &problems) ;
+     }
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     //update OUTLOOK_EMAIL_LIST2
+     listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+     newIndex=0;
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues - 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+         {
+             if (oldIndex != lDeleteEntry)
+             {
+                 newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                 newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                 newIndex++;
+             }
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
  
  
+     
+     if (newChilds.cValues == 0)
+     {
+         SPropTagArray delTags;
+         delTags.cValues = 1;
+         delTags.aulPropTag[0] = listTag;
+ 
+         mLastError = container->DeleteProps(&delTags, &problems) ;
+     }
+     else
+     {
+         childs.ulPropTag = listTag;
+         childs.Value.MVbin = newChilds;
+         mLastError = container->SetProps(1, &childs, &problems) ;
+     }
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mMAPIFreeBuffer(bins);
+ 
+     mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          (IUnknown **)&object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue *parentID=GetMapiProperty(*(LPMAPIPROP*)&object, PR_PARENT_ENTRYID);
+ 
+     if (parentID->Value.l == MAPI_E_NOT_FOUND)
+         return FALSE;
+     aParentEntry.Assign(parentID->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, parentID->Value.bin.lpb));
+     return TRUE;
+ }
+ BOOL nsMapiAddressBook::CreateEntryInList(const nsMapiEntry& aDistlist, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+     {
+         return FALSE;
+     }
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+     if (!CreateEntry(parentEntry,aNewEntry)) //Create a entry in parent folder
+         return FALSE;
+ 
+     return AddEntryToList(aDistlist,aNewEntry);
+ }
+ 
+ BOOL nsMapiAddressBook::CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         return CreateEntryInList(aParent,aNewEntry);        //Create entry in DistList
+     
+     LPMDB lpMsgStore=GetMsgStore(aParent);
+     
+     if (!lpMsgStore)
+         return FALSE;
+     
+     mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))
+         return FALSE;
+     
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+ 
+     mLastError = container->CreateMessage(&IID_IMessage,
+                                         0,
+                                         newEntry) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue messageclass ;
+     LPSPropProblemArray problems = NULL ;
+     nsCString tempName ;
+ 
+     messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+     tempName.Assign("IPM.Contact") ;
+     messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+     mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set temporary name %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     SPropTagArray property ;
+     LPSPropValue value = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     property.cValues = 1 ;
+     property.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+     if (HR_FAILED(mLastError) || valueCount != 1) {
+         PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+     FreeBuffer(value) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+ 
+     LPMDB lpMsgStore=GetMsgStore(aParent);
+     if (!lpMsgStore)
+         return FALSE;
+     mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+     mLastError = container->CreateMessage(&IID_IMAPIProp,
+                                         0,
+                                         newEntry) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue messageclass ;
+     LPSPropProblemArray problems = NULL ;
+     nsCString tempName ;
+ 
+     messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+     tempName.Assign("IPM.DistList") ;
+     messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+     mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set PR_MESSAGE_CLASS_A %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     ULONG valueCount = 0 ;
+     SPropTagArray property ;
+     LPSPropValue value = NULL ;
+ 
+     property.cValues = 1 ;
+     property.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+     if (HR_FAILED(mLastError) || valueCount != 1) {
+         PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+ 
+     FreeBuffer(value) ;
+     return TRUE ;
+ }
+ 
+ 
+ BOOL nsMapiAddressBook::CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource,
+                               nsMapiEntry& aTarget)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> targetFolder ;
+     ULONG objType = 0 ;
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+     {
+         //Add Entry To DistList
+         if (!AddEntryToList(aContainer,aSource))
+             return FALSE;
+         aTarget.Assign(aSource.mByteCount,aSource.mEntryId);
+         return TRUE;
+     }
+ 
+     SBinary entry ;
+     SBinaryArray entryArray ;
+ 
+     entry.cb = aSource.mByteCount ;
+     entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aSource.mEntryId) ;
+     entryArray.cValues = 1 ;
+     entryArray.lpbin = &entry ;
+  
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mLastError = OpenEntry(aTarget.mByteCount, aTarget.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          targetFolder) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open Target folder %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> newEntry ;
+ 
+     mLastError = container->CopyMessages(&entryArray,
+                                         &IID_IMessage,
+                                         (void*)&targetFolder,
+                                         0,
+                                         NULL,
+                                         NULL) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+     SBinary entry ;
+     SBinaryArray entryArray ;
+ 
+     
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         return DeleteEntryFromList(aContainer,aEntry);      //Delete Entry from DistList
+ 
+     LPMDB lpMsgStore=GetMsgStore(aContainer);
+     if (!lpMsgStore)
+         return FALSE;
+ 
+     mLastError = lpMsgStore->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType, 
+                                          container) ;
+     lpMsgStore->Release();
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     entry.cb = aEntry.mByteCount ;
+     entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aEntry.mEntryId) ;
+     entryArray.cValues = 1 ;
+     entryArray.lpbin = &entry ;
+     mLastError = container->DeleteMessages(&entryArray, 0,0,0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot delete entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     return TRUE ;
+ }
+ 
+ //Use to open message store in write mode
+ LPMDB nsMapiAddressBook::GetMsgStore(const nsMapiEntry& aEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     ULONG objType=0;
+ 
+     mLastError = OpenEntry(aEntry.mByteCount, aEntry.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                          object) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     SPropValue *svMsgSore=GetMapiProperty( *(LPMAPIPROP*)&object, PR_STORE_ENTRYID);;
+ 
+     LPMDB  lpMsgStore=NULL;
+     mLastError=mRootSession->OpenMsgStore(0,
+                               svMsgSore->Value.bin.cb,
+                               (ENTRYID*)svMsgSore->Value.bin.lpb,
+                               &IID_IMsgStore,
+                               MAPI_BEST_ACCESS  ,
+                               &lpMsgStore);
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open MsgStore %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     
+     return lpMsgStore;
+ }
*** misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	Fri Sep 28 16:06:25 2001
--- misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	Thu Mar 29 14:27:08 2007
***************
*** 40,51 ****
--- 40,81 ----
  
  #include "nsAbWinHelper.h"
   
+ struct TagMap
+ {
+     ULONG AddressTag;
+     ULONG NameID;
+     ULONG TypeMask;
+ };
  class nsMapiAddressBook : public nsAbWinHelper
  {
  public :
      nsMapiAddressBook(void) ;
      virtual ~nsMapiAddressBook(void) ;
  
+     // Get the top address books
+     virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+ 
+     // Get a default address book container
+     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+     // Is the helper correctly initialised?
+     virtual BOOL IsOK(void);
+     virtual BOOL GetPropertyLong(const nsMapiEntry& aObject,
+                                     ULONG aPropertyTag,
+                                     ULONG& aValue);
+     // Get the value of a MAPI property of type SYSTIME
+     virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                          WORD& aYear, WORD& aMonth, WORD& aDay);
+     // Create entry in the address book
+     virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+     // Delete an entry in the address book
+     virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
+     // Create a distribution list in the address book
+     virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+     // Copy an existing entry in the address book
+     virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+ 
+     static void FreeMapiLibrary(void) ;
+ 
  protected :
      // Class members to handle the library/entry points
      static HMODULE mLibrary ;
***************
*** 67,85 ****
      static BOOL mInitialized ;
      static BOOL mLogonDone ;
      static LPMAPISESSION mRootSession ;
!     static LPADRBOOK mRootBook ;
  
      // Load the MAPI environment
      BOOL Initialize(void) ;
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Library management 
      static BOOL LoadMapiLibrary(void) ;
!     static void FreeMapiLibrary(void) ;
  
  private :
  } ;
  
  #endif // nsMapiAddressBook_h___
--- 97,173 ----
      static BOOL mInitialized ;
      static BOOL mLogonDone ;
      static LPMAPISESSION mRootSession ;
! 
  
      // Load the MAPI environment
      BOOL Initialize(void) ;
+ 
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     );
+  
+ 
+     // Retrieve the contents of a container, with an optional restriction
+     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                      nsMapiEntryArray *aList, ULONG aMapiType) ;
+     // Retrieve the values of a set of properties on a MAPI object
+     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                            ULONG aNbProperties,
+                            LPSPropValue& aValues, ULONG& aValueCount) ;
+     // Set the values of a set of properties on a MAPI object
+     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                            LPSPropValue& aValues);
+ 
+ 
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Library management 
      static BOOL LoadMapiLibrary(void) ;
! 
!     BOOL HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
!     LPSPropValue GetMapiProperty( LPMAPIPROP pProp, ULONG tag);
!     BOOL GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal=FALSE);
!     BOOL HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
!     BOOL IterateHierarchy(IMAPIContainer * pFolder, nsMapiEntryArray& aFolders,ULONG flags=0);
!     ULONG GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID);
!     ULONG GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest=FALSE);
!     LPMDB GetMsgStore(const nsMapiEntry& aEntry);
!     BOOL CreateEntryInList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry);
!     BOOL AddEntryToList(const nsMapiEntry& aParent,const nsMapiEntry& aNewEntry);
!     BOOL DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry);
!     BOOL GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry);
!     BOOL CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction);
! 
!     //filter
!     BOOL Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList);
!     BOOL FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction);
!     BOOL AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue);
! 
!     void AddToMDBArray(LPMDB aMDB)
!     {
!         m_MDBArray.AppendElement(aMDB);
!     }
!     void CleanUpMDB()
!     {
!         LPMDB mdb;
!         for (int i = 0; i < m_MDBArray.Count(); i++)
!         {
!             mdb = (LPMDB)m_MDBArray.ElementAt(i);
!             mdb->Release();
!         }
!         m_MDBArray.Clear();
!     }
  
  private :
+     //use to keep all openned MsgStore,if we not open a message store,we can't open any thing on it
+     //so we have to kill message stores openned
+     nsVoidArray        m_MDBArray; 
  } ;
  
  #endif // nsMapiAddressBook_h___
*** misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	Tue Oct 30 03:59:16 2001
--- misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	Thu Mar 29 14:27:08 2007
***************
*** 47,52 ****
--- 47,68 ----
  
  #define PRINTF(args) PR_LOG(gWabAddressBookLog, PR_LOG_DEBUG, args)
  
+ enum
+ {
+     ContentsColumnEntryId = 0,
+     ContentsColumnObjectType,
+     ContentsColumnsSize
+ } ;
+ 
+ static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+ {
+     ContentsColumnsSize,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE
+     }
+ } ;
+ 
  HMODULE nsWabAddressBook::mLibrary = NULL ;
  PRInt32 nsWabAddressBook::mLibUsage = 0 ;
  LPWABOPEN nsWabAddressBook::mWABOpen = NULL ;
***************
*** 95,101 ****
  MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
  
  nsWabAddressBook::nsWabAddressBook(void)
! : nsAbWinHelper()
  {
      BOOL result = Initialize() ;
  
--- 111,117 ----
  MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
  
  nsWabAddressBook::nsWabAddressBook(void)
! : nsAbWinHelper(),mAddressBook(NULL)
  {
      BOOL result = Initialize() ;
  
***************
*** 110,118 ****
      MOZ_COUNT_DTOR(nsWabAddressBook) ;
  }
  
  BOOL nsWabAddressBook::Initialize(void)
  {
-     if (mAddressBook) { return TRUE ; }
      nsAutoLock guard(mMutex) ;
  
      if (!LoadWabLibrary()) {
--- 126,379 ----
      MOZ_COUNT_DTOR(nsWabAddressBook) ;
  }
  
+ BOOL nsWabAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+ {
+     aFolders.CleanUp() ;
+     nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+     SRestriction restriction ;
+     SPropTagArray folderColumns ;
+ 
+     mLastError = OpenEntry(0, NULL, NULL, 0, &objType,
+                                          rootFolder);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot open root %08x.\n", mLastError));
+         return FALSE;
+     }
+     mLastError = rootFolder->GetHierarchyTable(0, folders);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get hierarchy %08x.\n", mLastError));
+         return FALSE;
+     }
+     // We only take into account modifiable containers,
+     // otherwise, we end up with all the directory services...
+     restriction.rt = RES_BITMASK ;
+     restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
+     restriction.res.resBitMask.relBMR = BMR_NEZ ;
+     restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
+     mLastError = folders->Restrict(&restriction, 0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
+     }
+     folderColumns.cValues = 1 ;
+     folderColumns.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = folders->SetColumns(&folderColumns, 0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = folders->GetRowCount(0, &rowCount) ;
+     if (HR_SUCCEEDED(mLastError)) {
+         do {
+             LPSRowSet rowSet = NULL ;
+ 
+             rowCount = 0 ;
+             mLastError = folders->QueryRows(1, 0, &rowSet) ;
+             if (HR_SUCCEEDED(mLastError)) {
+                 rowCount = rowSet->cRows ;
+                 if (rowCount > 0) {
+                     SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
+                     
+                     aFolders.AddItem(currentValue.Value.bin.cb,
+                                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 }
+                 MyFreeProws(rowSet) ;
+             }
+             else {
+                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+             }
+         } while (rowCount > 0) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ BOOL nsWabAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                 nsMapiEntryArray *aList, ULONG aMapiType)
+ {
+     if (aList) { aList->CleanUp(); }
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIContainer, 0, &objType,
+                                          parent) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     // Here, flags for WAB and MAPI could be different, so this works
+     // only as long as we don't want to use any flag in GetContentsTable
+     mLastError = parent->GetContentsTable(0, contents) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (aRestriction) {
+         mLastError = contents->Restrict(aRestriction, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+     }
+     int entryId = ContentsColumnEntryId ;
+     int objectType = ContentsColumnObjectType ;
+ 
+     if (aRestriction) 
+     {
+         LPSPropTagArray allColumns = NULL ;
+ 
+         mLastError = contents->QueryColumns(TBL_ALL_COLUMNS, &allColumns) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot query columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+ 
+         for (unsigned int j = 0 ; j < allColumns->cValues ; ++ j) {
+             if (allColumns->aulPropTag [j] == PR_ENTRYID) { 
+                 entryId = j ; 
+             }
+             else if (allColumns->aulPropTag [j] == PR_OBJECT_TYPE) { 
+                 objectType = j ; 
+             }
+         }
+         mLastError = contents->SetColumns(allColumns, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         FreeBuffer(allColumns) ;
+     }
+     else
+     {
+ 
+         mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+      }    
+     
+     mLastError = contents->GetRowCount(0, &rowCount) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     do {
+         LPSRowSet rowSet = NULL ;
+         
+         rowCount = 0 ;
+         mLastError = contents->QueryRows(1, 0, &rowSet) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         rowCount = rowSet->cRows ;
+         if (rowCount > 0 &&
+             (aMapiType == 0 ||
+             rowSet->aRow->lpProps[objectType].Value.ul == aMapiType)) {
+             if (aList) {
+                 SPropValue& currentValue = rowSet->aRow->lpProps[entryId] ;
+                 
+                 aList->AddItem(currentValue.Value.bin.cb,
+                     NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 
+             }
+         }
+         MyFreeProws(rowSet) ;
+     } while (rowCount > 0) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsWabAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                                       ULONG aNbProperties, LPSPropValue& aValue, 
+                                       ULONG& aValueCount)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     IMsgStore * mdb=NULL;
+     ULONG objType = 0 ;
+     LPSPropTagArray properties = NULL ;
+     ULONG i = 0 ;
+     
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, 0, &objType, 
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot open entry %08x.\n", mLastError));
+         return FALSE;
+     }
+     AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                    NS_REINTERPRET_CAST(void **, &properties));
+     properties->cValues = aNbProperties;
+     for (i = 0 ; i < aNbProperties ; ++ i) {
+         properties->aulPropTag [i] = aPropertyTags [i];
+     }
+     mLastError = object->GetProps(properties, 0, &aValueCount, &aValue);
+     FreeBuffer(properties);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get props %08x.\n", mLastError));
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsWabAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                       LPSPropValue& aValues)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     LPSPropProblemArray problems = NULL ;
+ 
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_MODIFY, &objType, 
+                                          object) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (problems) {
+         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+             PRINTF(("Problem %d: index %d code %08x.\n", i,
+                 problems->aProblem [i].ulIndex,
+                 problems->aProblem [i].scode));
+         }
+     }
+     mLastError = object->SaveChanges(0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsWabAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+ {
+     LPENTRYID entryId = NULL;
+     ULONG byteCount = 0;
+ 
+     mLastError = mAddressBook->GetPAB(&byteCount, &entryId);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get PAB %08x.\n", mLastError));
+         return FALSE;
+     }
+     aContainer.Assign(byteCount, entryId);
+     FreeBuffer(entryId) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsWabAddressBook::IsOK(void)
+ {
+     return mAddressBook != NULL ;
+ }
+ 
  BOOL nsWabAddressBook::Initialize(void)
  {
      nsAutoLock guard(mMutex) ;
  
      if (!LoadWabLibrary()) {
*** misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	Fri Sep 28 16:06:25 2001
--- misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	Thu Mar 29 14:27:08 2007
***************
*** 47,52 ****
--- 47,61 ----
      nsWabAddressBook(void) ;
      virtual ~nsWabAddressBook(void) ;
  
+     // Get the top address books
+     virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+ 
+     // Get a default address book container
+     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+     // Is the helper correctly initialised?
+     virtual BOOL IsOK(void);
+     static void FreeWabLibrary(void) ;
+ 
  protected :
      // Session and address book that will be shared by all instances
      // (see nsMapiAddressBook.h for details)
***************
*** 57,71 ****
      static HMODULE mLibrary ;
      static LPWABOPEN mWABOpen ;
  
      // Load the WAB environment
      BOOL Initialize(void) ;
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Manage the library
      static BOOL LoadWabLibrary(void) ;
-     static void FreeWabLibrary(void) ;
  
  private :
  } ;
--- 66,111 ----
      static HMODULE mLibrary ;
      static LPWABOPEN mWABOpen ;
  
+     LPADRBOOK mAddressBook ;
+ 
      // Load the WAB environment
      BOOL Initialize(void) ;
+ 
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     )
+     {
+         return mAddressBook->OpenEntry(cbEntryID,
+                     lpEntryID,
+                     lpInterface,
+                     ulFlags,
+                     lpulObjType,
+                     lppUnk
+                     );
+     }
+  
+ 
+     // Retrieve the contents of a container, with an optional restriction
+     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                      nsMapiEntryArray *aList, ULONG aMapiType) ;
+     // Retrieve the values of a set of properties on a MAPI object
+     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                            ULONG aNbProperties,
+                            LPSPropValue& aValues, ULONG& aValueCount) ;
+     // Set the values of a set of properties on a MAPI object
+     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                            LPSPropValue& aValues) ;
+ 
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Manage the library
      static BOOL LoadWabLibrary(void) ;
  
  private :
  } ;
*** misc/mozilla/mailnews/base/src/nsMessengerWinIntegration.cpp	Mon Feb  9 17:48:47 2004
--- misc/build/mozilla/mailnews/base/src/nsMessengerWinIntegration.cpp	Thu Mar 29 14:27:08 2007
***************
*** 713,720 ****
--- 713,725 ----
    
    if (mUseWideCharBiffIcon)
    {
+ #ifdef __MINGW32__
+     ::wcsncpy( mWideBiffIconData.szTip, NS_REINTERPRET_CAST(LPCWSTR, aToolTipString), toolTipBufSize);
+     if (wcslen(NS_REINTERPRET_CAST(LPCWSTR, aToolTipString)) >= toolTipBufSize)
+ #else
      ::wcsncpy( mWideBiffIconData.szTip, aToolTipString, toolTipBufSize);
      if (wcslen(aToolTipString) >= toolTipBufSize)
+ #endif
        mWideBiffIconData.szTip[toolTipBufSize - 1] = 0;
    }
    else
***************
*** 754,760 ****
--- 759,769 ----
    // now we need to copy over any left over tool tip strings
    if (mWideBiffIconData.szTip)
    {
+ #ifdef __MINGW32__
+     const PRUnichar * oldTooltipString = reinterpret_cast<PRUnichar*>(mWideBiffIconData.szTip);
+ #else
      const PRUnichar * oldTooltipString = mWideBiffIconData.szTip;
+ #endif
      SetToolTipStringOnIconData(oldTooltipString);
    }
  }
***************
*** 954,960 ****
--- 963,973 ----
                                                    registryUnreadMailCountKey, 
                                                    sizeof(registryUnreadMailCountKey))))
    {
+ #ifdef __MINGW32__
+     if (wcscmp(registryUnreadMailCountKey, NS_REINTERPRET_CAST(LPCWSTR, currentUnreadMailCountKey.get()))==0) {
+ #else
      if (wcscmp(registryUnreadMailCountKey, currentUnreadMailCountKey.get())==0) {
+ #endif
        nsAutoString deleteKey;
        deleteKey.Assign(NS_LITERAL_STRING(UNREADMAILNODEKEY).get());
        deleteKey.Append(currentUnreadMailCountKey.get());
***************
*** 1016,1024 ****
--- 1029,1043 ----
      }
  
      // Write the info into the registry
+ #ifdef __MINGW32__
+     HRESULT hr = mSHSetUnreadMailCount(NS_REINTERPRET_CAST(LPCWSTR, pBuffer.get()), 
+                                        mCurrentUnreadCount, 
+                                        NS_REINTERPRET_CAST(LPCWSTR, commandLinerForAppLaunch.get()));
+ #else
      HRESULT hr = mSHSetUnreadMailCount(pBuffer.get(), 
                                         mCurrentUnreadCount, 
                                         commandLinerForAppLaunch.get());
+ #endif
    }
  
    // do this last
*** misc/mozilla/mailnews/mime/src/mimeeobj.h	Fri Sep 28 16:07:42 2001
--- misc/build/mozilla/mailnews/mime/src/mimeeobj.h	Thu Mar 29 14:27:08 2007
***************
*** 54,60 ****
    MimeLeafClass leaf;
  };
  
! extern MimeExternalObjectClass mimeExternalObjectClass;
  
  struct MimeExternalObject {
    MimeLeaf leaf;
--- 54,60 ----
    MimeLeafClass leaf;
  };
  
! extern "C" MimeExternalObjectClass mimeExternalObjectClass;
  
  struct MimeExternalObject {
    MimeLeaf leaf;
*** misc/mozilla/modules/libpref/src/Makefile.in	Fri Jan 16 14:22:37 2004
--- misc/build/mozilla/modules/libpref/src/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 78,84 ****
  PREF_JS_EXPORTS	+= $(srcdir)/init/non-shared.txt
  endif
  
! EXTRA_DSO_LDOPTS = \
  		$(LIBS_DIR) \
  		$(MOZ_JS_LIBS) \
  		$(MOZ_COMPONENT_LIBS) \
--- 78,84 ----
  PREF_JS_EXPORTS	+= $(srcdir)/init/non-shared.txt
  endif
  
! EXTRA_DSO_LDOPTS += \
  		$(LIBS_DIR) \
  		$(MOZ_JS_LIBS) \
  		$(MOZ_COMPONENT_LIBS) \
***************
*** 89,91 ****
--- 89,92 ----
  GARBAGE		+= $(addprefix $(DIST)/bin/defaults/pref/, \
  			all.js mailnews.js editor.js \
  			aix.js beos.js unix.js winpref.js os2prefs.js openvms.js photon.js)
+ 
*** misc/mozilla/netwerk/protocol/http/src/nsHttpConnectionMgr.cpp	Wed Sep  1 19:45:24 2004
--- misc/build/mozilla/netwerk/protocol/http/src/nsHttpConnectionMgr.cpp	Thu Mar 29 14:27:08 2007
***************
*** 834,841 ****
  void
  nsHttpConnectionMgr::OnMsgUpdateParam(nsresult status, void *param)
  {
!     PRUint16 name  = (PRUint32(param) & 0xFFFF0000) >> 16;
!     PRUint16 value =  PRUint32(param) & 0x0000FFFF;
  
      switch (name) {
      case MAX_CONNECTIONS:
--- 834,841 ----
  void
  nsHttpConnectionMgr::OnMsgUpdateParam(nsresult status, void *param)
  {
!     PRUint16 name  = (NS_PTR_TO_INT32(param) & 0xFFFF0000) >> 16;
!     PRUint16 value =  NS_PTR_TO_INT32(param) & 0x0000FFFF;
  
      switch (name) {
      case MAX_CONNECTIONS:
*** misc/mozilla/nsprpub/configure	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/nsprpub/configure	Wed Apr  4 20:56:33 2007
***************
*** 3407,3413 ****
  EOF
  
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
--- 3407,3413 ----
  EOF
  
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
*** misc/mozilla/nsprpub/configure.in	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/nsprpub/configure.in	Wed Apr  4 20:56:40 2007
***************
*** 922,928 ****
      AC_DEFINE(HAVE_BSD_FLOCK)
      AC_DEFINE(HAVE_SOCKLEN_T)
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
--- 922,928 ----
      AC_DEFINE(HAVE_BSD_FLOCK)
      AC_DEFINE(HAVE_SOCKLEN_T)
      CFLAGS="$CFLAGS $(DSO_CFLAGS) -ansi -Wall"
!     MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
      if test "$MOZ_OBJFORMAT" = "elf"; then
          DLL_SUFFIX=so
      else
*** misc/mozilla/nsprpub/build/cygwin-wrapper	Wed Apr  2 19:22:38 2003
--- misc/build/mozilla/nsprpub/build/cygwin-wrapper	Thu Mar 29 14:27:08 2007
***************
*** 1,4 ****
! #!/bin/sh
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
--- 1,4 ----
! #!/bin/bash
  #
  # Stupid wrapper to avoid win32 dospath/cygdrive issues
  #
***************
*** 18,23 ****
     shift
     args=`echo $* | sed -e "s|-I\([a-zA-Z]\):/|-I${mountpoint}/\1/|g;"`
  else
!    args=`echo $* | sed -e "s|${mountpoint}/\([a-zA-Z]\)/|\1:/|g;"`
  fi
  exec $prog $args
--- 18,57 ----
     shift
     args=`echo $* | sed -e "s|-I\([a-zA-Z]\):/|-I${mountpoint}/\1/|g;"`
  else
!    for i in "${@}"
!    do
!       # The original version missed mounted paths, the new version below
!       # doesn't transform /para as this is most likely a parameter.
!       eval 'notinpath=${i%%'${mountpoint}'/[a-zA-Z]/*}'
!       if ! test "$notinpath" = "$i"; then
!          # found  $mountpoint
!          eval 'restpath=${i#'${notinpath}${mountpoint}'/[a-zA-Z]/}'
!          eval 'withdrive=${i#'${notinpath}${mountpoint}'/}'
!          driveletter=${withdrive%%/*}
!          i=${notinpath}${driveletter}:/${restpath}
!       else
!          # check for potential path. Precheck using shell methods
!          doconvert=""
!          # Shortcut -X<path> when path does not begin with '/'
!          noswitch=${i#-[a-zA-Z]}
!          if test "$noswitch" != "$i"; then
!             test "${noswitch#/}" != "$noswitch" && doconvert="1"
!          fi
!          # Precheck for possible path. Consider only absolute paths that contain at least
!          # a second / to prevent converting of /abc parameters.
!          test -z "$doconvert" -a "${i#/[a-zA-Z0-9_.-]*/}" != "$i" && doconvert="1"
!          if test -n "$doconvert"; then
!             # Can be a path. If forking grep would be faster or we could require bash 3
!             # this regexp would be all that's needed to find pathnames that need converting
!             pathname=`echo $i | grep -oE '^(-[a-zA-Z])?/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_./-]+$'`
!             eval 'notinpath=${i%'${pathname}'}'
!             if test "$notinpath" != "$i" -a "$pathname" != "${pathname#/}"; then
!                pathname=`cygpath -am "$pathname"`
!                i=${notinpath}${pathname}
!             fi
!          fi
!       fi
!       args="${args} ${i}"
!    done
  fi
  exec $prog $args
*** misc/mozilla/nsprpub/config/autoconf.mk.in	Sat Mar 22 11:28:52 2003
--- misc/build/mozilla/nsprpub/config/autoconf.mk.in	Thu Mar 29 14:27:08 2007
***************
*** 22,27 ****
--- 22,28 ----
  RELEASE_OBJDIR_NAME = @RELEASE_OBJDIR_NAME@
  OBJDIR_NAME	= @OBJDIR_NAME@
  OBJDIR		= @OBJDIR@
+ LIB_PREFIX	= @LIB_PREFIX@
  OBJ_SUFFIX	= @OBJ_SUFFIX@
  LIB_SUFFIX	= @LIB_SUFFIX@
  DLL_SUFFIX	= @DLL_SUFFIX@
*** misc/mozilla/nsprpub/config/rules.mk	Mon Sep 15 22:00:28 2003
--- misc/build/mozilla/nsprpub/config/rules.mk	Thu Mar 29 14:27:08 2007
***************
*** 101,119 ****
  ifdef LIBRARY_NAME
  ifeq (,$(filter-out WINNT OS2,$(OS_ARCH)))
  
! #
! # Win95, Win16, and OS/2 require library names conforming to the 8.3 rule.
! # other platforms do not.
! #
! ifeq (,$(filter-out WIN95 OS2,$(OS_TARGET)))
! LIBRARY		= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
  SHARED_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
! IMPORT_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
! else
! LIBRARY		= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
! SHARED_LIBRARY	= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
! IMPORT_LIBRARY	= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
! endif
  
  else
  
--- 101,109 ----
  ifdef LIBRARY_NAME
  ifeq (,$(filter-out WINNT OS2,$(OS_ARCH)))
  
! LIBRARY		= $(OBJDIR)/$(LIB_PREFIX)$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
  SHARED_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
! IMPORT_LIBRARY	= $(OBJDIR)/$(LIB_PREFIX)$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
  
  else
  
*** misc/mozilla/nsprpub/configure	Tue Sep 14 17:14:38 2004
--- misc/build/mozilla/nsprpub/configure	Thu Mar 29 14:27:08 2007
***************
*** 2724,2729 ****
--- 2724,2730 ----
  LIB_SUFFIX=a
  DLL_SUFFIX=so
  ASM_SUFFIX=s
+ LIB_PREFIX=lib
  MKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'
  PR_MD_ASFILES=
  PR_MD_CSRCS=
***************
*** 3861,3867 ****
          CC="$CC -mno-cygwin"
          CXX="$CXX -mno-cygwin"
          DLL_SUFFIX=dll
!         MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'
          RC=$WINDRES
          # Use temp file for windres (bug 213281)
          RCFLAGS='-O coff --use-temp-file'
--- 3862,3868 ----
          CC="$CC -mno-cygwin"
          CXX="$CXX -mno-cygwin"
          DLL_SUFFIX=dll
!         MKSHLIB='$(CC) -shared -Wl,--enable-runtime-pseudo-reloc -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'
          RC=$WINDRES
          # Use temp file for windres (bug 213281)
          RCFLAGS='-O coff --use-temp-file'
***************
*** 3878,3883 ****
--- 3879,3885 ----
          OBJ_SUFFIX=obj
          LIB_SUFFIX=lib
          DLL_SUFFIX=dll
+         LIB_PREFIX=
          
          CFLAGS="$CFLAGS -W3 -nologo -GF -Gy"
  
***************
*** 6004,6009 ****
--- 6006,6012 ----
  s%@LIB_SUFFIX@%$LIB_SUFFIX%g
  s%@DLL_SUFFIX@%$DLL_SUFFIX%g
  s%@ASM_SUFFIX@%$ASM_SUFFIX%g
+ s%@LIB_PREFIX@%$LIB_PREFIX%g
  s%@MKSHLIB@%$MKSHLIB%g
  s%@DSO_CFLAGS@%$DSO_CFLAGS%g
  s%@DSO_LDOPTS@%$DSO_LDOPTS%g
*** misc/mozilla/nsprpub/lib/ds/Makefile.in	Wed Apr  9 17:49:32 2003
--- misc/build/mozilla/nsprpub/lib/ds/Makefile.in	Thu Mar 29 14:27:08 2007
***************
*** 80,97 ****
  OS_LIBS = -lc
  endif
  
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/pldsmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE)
  else
! MKSHLIB += -Wl,-M,$(MAPFILE)
  endif
  else
! MKSHLIB += -M $(MAPFILE)
  endif
  endif
  
--- 80,101 ----
  OS_LIBS = -lc
  endif
  
+ ifeq ($(OS_ARCH),Linux)
+ MKSHLIB += -Wl,-rpath,\$$ORIGIN
+ endif
+ 
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/pldsmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN
  else
! MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  else
! MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  endif
  
*** misc/mozilla/nsprpub/lib/libc/src/Makefile.in	Wed Apr  9 17:49:35 2003
--- misc/build/mozilla/nsprpub/lib/libc/src/Makefile.in	Thu Mar 29 14:27:09 2007
***************
*** 90,107 ****
  OS_LIBS = -lc
  endif
  
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/plcmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE)
  else
! MKSHLIB += -Wl,-M,$(MAPFILE)
  endif
  else
! MKSHLIB += -M $(MAPFILE)
  endif
  endif
  
--- 90,111 ----
  OS_LIBS = -lc
  endif
  
+ ifeq ($(OS_ARCH),Linux)
+ MKSHLIB += -Wl,-rpath,\$$ORIGIN
+ endif
+ 
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/plcmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN
  else
! MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  else
! MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  endif
  
*** misc/mozilla/nsprpub/pr/include/prtypes.h	Tue Sep 16 16:30:38 2003
--- misc/build/mozilla/nsprpub/pr/include/prtypes.h	Thu Mar 29 14:27:09 2007
***************
*** 450,456 ****
   */
  #ifndef __PRUNICHAR__
  #define __PRUNICHAR__
! #if defined(WIN32) || defined(XP_MAC)
  typedef wchar_t PRUnichar;
  #else
  typedef PRUint16 PRUnichar;
--- 450,456 ----
   */
  #ifndef __PRUNICHAR__
  #define __PRUNICHAR__
! #if !defined(__MINGW32__) && (defined(WIN32) || defined(XP_MAC))
  typedef wchar_t PRUnichar;
  #else
  typedef PRUint16 PRUnichar;
*** misc/mozilla/nsprpub/pr/src/misc/prnetdb.c	Wed Sep  1 19:44:37 2004
--- misc/build/mozilla/nsprpub/pr/src/misc/prnetdb.c	Thu Mar 29 14:27:09 2007
***************
*** 105,111 ****
  #define _PR_HAVE_GETPROTO_R_INT
  #endif
  
! #if (defined(LINUX) && defined(__GLIBC__) && __GLIBC__ >= 2)
  #define _PR_HAVE_GETPROTO_R
  #define _PR_HAVE_5_ARG_GETPROTO_R
  #endif
--- 105,112 ----
  #define _PR_HAVE_GETPROTO_R_INT
  #endif
  
! #if (defined(LINUX) && defined(__GLIBC__) && __GLIBC__ >= 2) || \
! 	(defined(__FreeBSD__) && __FreeBSD_version > 601103)
  #define _PR_HAVE_GETPROTO_R
  #define _PR_HAVE_5_ARG_GETPROTO_R
  #endif
*** misc/mozilla/profile/src/nsProfile.cpp	Sat Apr 24 13:15:40 2004
--- misc/build/mozilla/profile/src/nsProfile.cpp	Thu Mar 29 14:27:09 2007
***************
*** 37,43 ****
--- 37,45 ----
  
  #include "nscore.h" 
  #include "nsProfile.h"
+ #ifdef MOZ_PROFILELOCKING
  #include "nsProfileLock.h"
+ #endif
  #include "nsIPrefService.h"
  #include "nsIPrefBranch.h"
  
***************
*** 499,510 ****
--- 501,514 ----
                  profileURLStr = PROFILE_MANAGER_URL; 
              if (exists)
              {
+ #ifdef MOZ_PROFILELOCKING
                  // If the profile is locked, we need the UI
                  nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(curProfileDir));
                  nsProfileLock tempLock;
                  rv = tempLock.Lock(localFile);
                  if (NS_FAILED(rv))
                      profileURLStr = PROFILE_MANAGER_URL;
+ #endif
              } 
          }
          else
***************
*** 1173,1179 ****
      }
      else
          isSwitch = PR_FALSE;
!     
      nsProfileLock localLock;
      nsCOMPtr<nsILocalFile> localProfileDir(do_QueryInterface(profileDir, &rv));
      if (NS_FAILED(rv)) return rv;
--- 1177,1183 ----
      }
      else
          isSwitch = PR_FALSE;
! #ifdef MOZ_PROFILELOCKING    
      nsProfileLock localLock;
      nsCOMPtr<nsILocalFile> localProfileDir(do_QueryInterface(profileDir, &rv));
      if (NS_FAILED(rv)) return rv;
***************
*** 1183,1189 ****
          NS_ERROR("Could not get profile directory lock.");
          return rv;
      }
! 
      nsCOMPtr<nsIObserverService> observerService = 
               do_GetService("@mozilla.org/observer-service;1", &rv);
      NS_ENSURE_TRUE(observerService, NS_ERROR_FAILURE);
--- 1187,1193 ----
          NS_ERROR("Could not get profile directory lock.");
          return rv;
      }
! #endif
      nsCOMPtr<nsIObserverService> observerService = 
               do_GetService("@mozilla.org/observer-service;1", &rv);
      NS_ENSURE_TRUE(observerService, NS_ERROR_FAILURE);
***************
*** 1237,1244 ****
--- 1241,1250 ----
          UpdateCurrentProfileModTime(PR_FALSE);        
      }
  
+ #ifdef MOZ_PROFILELOCKING    
      // Do the profile switch
      localLock.Unlock(); // gDirServiceProvider will get and hold its own lock
+ #endif
      gDirServiceProvider->SetProfileDir(profileDir);  
      mCurrentProfileName.Assign(aCurrentProfile);    
      gProfileDataAccess->SetCurrentProfile(aCurrentProfile);
*** misc/mozilla/security/coreconf/Linux.mk	Tue Feb 10 21:33:51 2004
--- misc/build/mozilla/security/coreconf/Linux.mk	Thu Mar 29 14:27:09 2007
***************
*** 123,129 ****
  
  ifeq ($(OS_RELEASE),2.0)
  	OS_REL_CFLAGS	+= -DLINUX2_0
! 	MKSHLIB		= $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  	ifdef BUILD_OPT
  		OPTIMIZER	= -O2
  	endif
--- 123,129 ----
  
  ifeq ($(OS_RELEASE),2.0)
  	OS_REL_CFLAGS	+= -DLINUX2_0
! 	MKSHLIB		= $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  	ifdef BUILD_OPT
  		OPTIMIZER	= -O2
  	endif
***************
*** 149,154 ****
--- 149,155 ----
  
  DSO_CFLAGS		= -fPIC
  DSO_LDOPTS		= -shared
+ DSO_LDOPTS		+= -Wl,-rpath,\$$ORIGIN
  DSO_LDFLAGS		=
  
  # INCLUDES += -I/usr/include -Y/usr/include/linux
*** misc/mozilla/security/coreconf/Linux2.1.mk	Wed Nov  7 15:58:09 2001
--- misc/build/mozilla/security/coreconf/Linux2.1.mk	Thu Mar 29 14:27:09 2007
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  ifeq ($(OS_RELEASE),2.1)
          OS_REL_CFLAGS   += -DLINUX2_1
!         MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
          ifdef BUILD_OPT
                  OPTIMIZER       = -O2
          endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  ifeq ($(OS_RELEASE),2.1)
          OS_REL_CFLAGS   += -DLINUX2_1
!         MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
          ifdef BUILD_OPT
                  OPTIMIZER       = -O2
          endif
*** misc/mozilla/security/coreconf/Linux2.2.mk	Wed Nov  7 15:56:18 2001
--- misc/build/mozilla/security/coreconf/Linux2.2.mk	Thu Mar 29 14:27:09 2007
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.4.mk	Wed Nov  7 15:56:18 2001
--- misc/build/mozilla/security/coreconf/Linux2.4.mk	Thu Mar 29 14:27:09 2007
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.5.mk	Sat Jan 26 19:45:37 2002
--- misc/build/mozilla/security/coreconf/Linux2.5.mk	Thu Mar 29 14:27:09 2007
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.6.mk	Sat Jul 19 17:21:50 2003
--- misc/build/mozilla/security/coreconf/Linux2.6.mk	Thu Mar 29 14:27:09 2007
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/SunOS5.mk	Fri Oct 15 19:52:29 2004
--- misc/build/mozilla/security/coreconf/SunOS5.mk	Thu Mar 29 14:27:09 2007
***************
*** 164,175 ****
--- 164,177 ----
  
  # ld options:
  # -G: produce a shared object
+ # -R '$ORIGIN': search for dependencies in same directory
  # -z defs: no unresolved symbols allowed
  ifdef NS_USE_GCC
  ifeq ($(USE_64), 1)
  	DSO_LDOPTS += -m64
  endif
  	DSO_LDOPTS += -shared -h $(notdir $@)
+     DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN
  else
  ifeq ($(USE_64), 1)
  	ifeq ($(OS_TEST),i86pc)
***************
*** 179,184 ****
--- 181,187 ----
  	endif
  endif
  	DSO_LDOPTS += -G -h $(notdir $@)
+     DSO_LDOPTS += -R '\$$ORIGIN'
  endif
  
  # -KPIC generates position independent code for use in shared libraries.
*** misc/mozilla/security/coreconf/WIN954.0.mk	Fri Oct 15 19:52:29 2004
--- misc/build/mozilla/security/coreconf/WIN954.0.mk	Thu Mar 29 14:27:09 2007
***************
*** 64,66 ****
--- 64,70 ----
  endif
  endif
  DEFINES += -DWIN95
+ 
+ ifdef NS_USE_GCC
+ NSPR31_LIB_PREFIX = lib
+ endif
*** misc/mozilla/security/coreconf/FreeBSD.mk	Wed Mar 26 20:17:25 2003
--- misc/build/mozilla/security/coreconf/FreeBSD.mk	Wed Apr  4 20:56:48 2007
***************
*** 63,69 ****
  
  ARCH			= freebsd
  
! MOZ_OBJFORMAT		:= $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo aout)
  
  ifeq ($(MOZ_OBJFORMAT),elf)
  DLL_SUFFIX		= so
--- 63,69 ----
  
  ARCH			= freebsd
  
! MOZ_OBJFORMAT		:= $(shell test -x /usr/bin/objformat && /usr/bin/objformat || echo elf)
  
  ifeq ($(MOZ_OBJFORMAT),elf)
  DLL_SUFFIX		= so
*** misc/mozilla/security/coreconf/command.mk	Fri Feb 15 17:53:12 2002
--- misc/build/mozilla/security/coreconf/command.mk	Thu Mar 29 14:27:09 2007
***************
*** 42,48 ****
  LINK_DLL      = $(LINK) $(OS_DLLFLAGS) $(DLLFLAGS)
  LINK_EXE      = $(LINK) $(OS_LFLAGS) $(LFLAGS)
  NFSPWD        = $(NSINSTALL_DIR)/nfspwd
! CFLAGS        = $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
  		$(XCFLAGS)
  RANLIB        = echo
  TAR           = /bin/tar
--- 42,48 ----
  LINK_DLL      = $(LINK) $(OS_DLLFLAGS) $(DLLFLAGS)
  LINK_EXE      = $(LINK) $(OS_LFLAGS) $(LFLAGS)
  NFSPWD        = $(NSINSTALL_DIR)/nfspwd
! CFLAGS        += $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
  		$(XCFLAGS)
  RANLIB        = echo
  TAR           = /bin/tar
*** misc/mozilla/security/coreconf/rules.mk	Mon Mar 22 20:56:47 2004
--- misc/build/mozilla/security/coreconf/rules.mk	Thu Mar 29 14:32:45 2007
***************
*** 406,423 ****
  endif
  
  ifdef NEED_ABSOLUTE_PATH
! abspath = $(if $(findstring :,$(1)),$(1),$(if $(filter /%,$(1)),$(1),$(PWD)/$(1)))
  else
! abspath = $(1)
  endif
  
  $(OBJDIR)/$(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
  	@$(MAKE_OBJDIR)
  ifdef USE_NT_C_SYNTAX
! 	$(CC) -Fo$@ -c $(CFLAGS) $(call abspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CC) -o $@ -c $(CFLAGS) $(call abspath,$<)
  else
  	$(CC) -o $@ -c $(CFLAGS) $<
  endif
--- 406,423 ----
  endif
  
  ifdef NEED_ABSOLUTE_PATH
! mozabspath = $(if $(findstring :,$(1)),$(1),$(if $(filter /%,$(1)),$(1),$(PWD)/$(1)))
  else
! mozabspath = $(1)
  endif
  
  $(OBJDIR)/$(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
  	@$(MAKE_OBJDIR)
  ifdef USE_NT_C_SYNTAX
! 	$(CC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  	$(CC) -o $@ -c $(CFLAGS) $<
  endif
***************
*** 425,434 ****
  
  $(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
  ifdef USE_NT_C_SYNTAX
! 	$(CC) -Fo$@ -c $(CFLAGS) $(call abspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CC) -o $@ -c $(CFLAGS) $(call abspath,$<)
  else
  	$(CC) -o $@ -c $(CFLAGS) $<
  endif
--- 425,434 ----
  
  $(PROG_PREFIX)%$(OBJ_SUFFIX): %.c
  ifdef USE_NT_C_SYNTAX
! 	$(CC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  	$(CC) -o $@ -c $(CFLAGS) $<
  endif
***************
*** 457,466 ****
  $(OBJDIR)/$(PROG_PREFIX)%: %.cpp
  	@$(MAKE_OBJDIR)
  ifdef USE_NT_C_SYNTAX
! 	$(CCC) -Fo$@ -c $(CFLAGS) $(call abspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CCC) -o $@ -c $(CFLAGS) $(call abspath,$<)
  else
  	$(CCC) -o $@ -c $(CFLAGS) $<
  endif
--- 457,466 ----
  $(OBJDIR)/$(PROG_PREFIX)%: %.cpp
  	@$(MAKE_OBJDIR)
  ifdef USE_NT_C_SYNTAX
! 	$(CCC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CCC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  	$(CCC) -o $@ -c $(CFLAGS) $<
  endif
***************
*** 481,490 ****
  	rm -f $(OBJDIR)/t_$*.cc
  else
  ifdef USE_NT_C_SYNTAX
! 	$(CCC) -Fo$@ -c $(CFLAGS) $(call abspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CCC) -o $@ -c $(CFLAGS) $(call abspath,$<)
  else
  	$(CCC) -o $@ -c $(CFLAGS) $<
  endif
--- 481,490 ----
  	rm -f $(OBJDIR)/t_$*.cc
  else
  ifdef USE_NT_C_SYNTAX
! 	$(CCC) -Fo$@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  ifdef NEED_ABSOLUTE_PATH
! 	$(CCC) -o $@ -c $(CFLAGS) $(call mozabspath,$<)
  else
  	$(CCC) -o $@ -c $(CFLAGS) $<
  endif
*** misc/mozilla/security/nss/lib/ckfw/builtins/config.mk	Fri Oct 15 19:52:32 2004
--- misc/build/mozilla/security/nss/lib/ckfw/builtins/config.mk	Thu Mar 29 14:27:09 2007
***************
*** 59,67 ****
  DSO_LDOPTS = -bundle
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
  
--- 59,62 ----
*** misc/mozilla/security/nss/lib/freebl/Makefile	Fri Oct 15 19:52:33 2004
--- misc/build/mozilla/security/nss/lib/freebl/Makefile	Thu Mar 29 14:27:09 2007
***************
*** 179,189 ****
  
  # Note: -xarch=v8 or v9 is now done in coreconf
  ifeq ($(OS_TARGET),SunOS)
- 
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- 
  ifeq ($(CPU_ARCH),sparc)
  ifndef NS_USE_GCC
  ifdef USE_HYBRID
--- 179,184 ----
***************
*** 199,205 ****
  MKSHLIB += -Wl,-B,symbolic,-z,defs,-z,now,-z,text,-M,mapfile.Solaris
  endif # GCC_USE_GNU_LD
  else
! MKSHLIB += -B symbolic -z defs -z now -z text -M mapfile.Solaris
  endif # NS_USE_GCC
  ifdef USE_PURE_32
  # this builds for Sparc v8 pure 32-bit architecture
--- 194,200 ----
  MKSHLIB += -Wl,-B,symbolic,-z,defs,-z,now,-z,text,-M,mapfile.Solaris
  endif # GCC_USE_GNU_LD
  else
! MKSHLIB += -z defs -z now -z text -M mapfile.Solaris
  endif # NS_USE_GCC
  ifdef USE_PURE_32
  # this builds for Sparc v8 pure 32-bit architecture
*** misc/mozilla/security/nss/lib/nss/config.mk	Fri Oct 15 19:52:33 2004
--- misc/build/mozilla/security/nss/lib/nss/config.mk	Thu Mar 29 14:27:09 2007
***************
*** 107,120 ****
  # The -R '$ORIGIN' linker option instructs this library to search for its
  # dependencies in the same directory where it resides.
  ifeq ($(USE_64), 1)
! MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1/sparcv9:/usr/lib/mps/sparcv9'
  else
! MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1:/usr/lib/mps'
! endif
! else
! MKSHLIB += -R '$$ORIGIN'
! endif
! endif
  
  
  ifeq (,$(filter-out WINNT WIN95,$(OS_TARGET)))
--- 107,118 ----
  # The -R '$ORIGIN' linker option instructs this library to search for its
  # dependencies in the same directory where it resides.
  ifeq ($(USE_64), 1)
! DSO_LDOPTS += -R /usr/lib/mps/secv1/sparcv9:/usr/lib/mps/sparcv9
  else
! DSO_LDOPTS += -R /usr/lib/mps/secv1:/usr/lib/mps
! endif # USE_64
! endif # BUILD_SUN_PKG
! endif # SunOS
  
  
  ifeq (,$(filter-out WINNT WIN95,$(OS_TARGET)))
*** misc/mozilla/security/nss/lib/nss/nss.def	Fri Oct 15 19:52:33 2004
--- misc/build/mozilla/security/nss/lib/nss/nss.def	Thu Mar 29 14:27:09 2007
***************
*** 60,65 ****
--- 60,66 ----
  CERT_CheckCertValidTimes;
  CERT_CreateCertificateRequest;
  CERT_ChangeCertTrust;
+ CERT_DecodeDERCertificate;
  CERT_DecodeDERCrl;
  CERT_DestroyCertificateRequest;
  CERT_DestroyCertList;
*** misc/mozilla/security/nss/lib/pki1/oiddata.h	Fri Jan  4 00:22:07 2002
--- misc/build/mozilla/security/nss/lib/pki1/oiddata.h	Thu Mar 29 14:27:09 2007
***************
*** 39,49 ****
  static const char OIDDATA_CVS_ID[] = "@(#) $RCSfile$ $Revision$ $Date$ $Name$ ; @(#) $RCSfile$ $Revision$ $Date$ $Name$";
  #endif /* DEBUG */
  
  #ifndef NSSPKI1T_H
  #include "nsspki1t.h"
  #endif /* NSSPKI1T_H */
  
! extern const NSSOID nss_builtin_oids[];
  extern const PRUint32 nss_builtin_oid_count;
  
  /*extern const nssAttributeTypeAliasTable nss_attribute_type_aliases[];*/
--- 39,50 ----
  static const char OIDDATA_CVS_ID[] = "@(#) $RCSfile$ $Revision$ $Date$ $Name$ ; @(#) $RCSfile$ $Revision$ $Date$ $Name$";
  #endif /* DEBUG */
  
+ #include "pki1t.h"
  #ifndef NSSPKI1T_H
  #include "nsspki1t.h"
  #endif /* NSSPKI1T_H */
  
! extern const NSSOID *nss_builtin_oids;
  extern const PRUint32 nss_builtin_oid_count;
  
  /*extern const nssAttributeTypeAliasTable nss_attribute_type_aliases[];*/
*** misc/mozilla/security/nss/lib/smime/config.mk	Fri Oct 15 19:52:34 2004
--- misc/build/mozilla/security/nss/lib/smime/config.mk	Thu Mar 29 14:27:09 2007
***************
*** 85,94 ****
  	../pkcs12 \
  	../pkcs7 \
  	$(NULL)
- 
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
--- 85,87 ----
*** misc/mozilla/security/nss/lib/softoken/config.mk	Fri Oct 15 19:52:35 2004
--- misc/build/mozilla/security/nss/lib/softoken/config.mk	Thu Mar 29 14:27:09 2007
***************
*** 83,94 ****
  	$(NULL)
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
  ifeq ($(OS_TARGET),WINCE)
  DEFINES += -DDBM_USING_NSPR
  endif
--- 83,88 ----
*** misc/mozilla/security/nss/lib/ssl/config.mk	Fri Oct 15 19:52:35 2004
--- misc/build/mozilla/security/nss/lib/ssl/config.mk	Thu Mar 29 14:27:09 2007
***************
*** 78,87 ****
  EXTRA_SHARED_LIBS += -dylib_file @executable_path/libsoftokn3.dylib:$(DIST)/lib/libsoftokn3.dylib
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
  endif
--- 78,81 ----
*** misc/mozilla/uriloader/exthandler/win/nsOSHelperAppService.cpp	Wed Oct 20 12:26:10 2004
--- misc/build/mozilla/uriloader/exthandler/win/nsOSHelperAppService.cpp	Thu Mar 29 14:27:09 2007
***************
*** 171,183 ****
--- 171,191 ----
    }
  
    DWORD bufSz;
+ #ifdef __MINGW32__
+   LONG err = ::RegQueryValueExW( hKey, NS_REINTERPRET_CAST(LPCWSTR, pValueName), NULL, NULL, NULL, &bufSz); 
+ #else
    LONG err = ::RegQueryValueExW( hKey, pValueName, NULL, NULL, NULL, &bufSz); 
+ #endif
    if (err == ERROR_SUCCESS) {
      PRUnichar* pBytes = new PRUnichar[bufSz];
      if (!pBytes)
        return PR_FALSE;
  
+ #ifdef __MINGW32__
+     err = ::RegQueryValueExW( hKey, NS_REINTERPRET_CAST(LPCWSTR, pValueName), NULL, NULL, (BYTE*)pBytes, &bufSz);
+ #else
      err = ::RegQueryValueExW( hKey, pValueName, NULL, NULL, (BYTE*)pBytes, &bufSz);
+ #endif
      if (err != ERROR_SUCCESS) {
        delete [] pBytes;
        return PR_FALSE;
***************
*** 263,269 ****
--- 271,281 ----
      HKEY fileTypeKey = 0;
      LONG rc;
      if (mIsNT) {
+ #ifdef __MINGW32__
+       rc = ::RegOpenKeyExW( HKEY_CLASSES_ROOT, NS_REINTERPRET_CAST(LPCWSTR, fileType.get()), 0, KEY_QUERY_VALUE, &fileTypeKey );
+ #else
        rc = ::RegOpenKeyExW( HKEY_CLASSES_ROOT, fileType.get(), 0, KEY_QUERY_VALUE, &fileTypeKey );
+ #endif
      }
      else {
        nsCAutoString ansiKey;
*** misc/mozilla/webshell/tests/viewer/Makefile.in	Thu Apr  8 04:06:32 2004
--- misc/build/mozilla/webshell/tests/viewer/Makefile.in	Thu Mar 29 14:27:09 2007
***************
*** 163,169 ****
  GTK_LIBS		= unix/gtk/libviewer_gtk_s.a -lgtksuperwin $(XP_LIBS) $(MOZ_GTK_LDFLAGS)
  
  XP_DIST_DEP_LIBS	:= $(filter-out -L$(DIST)/bin -L$(DIST)/lib, $(XP_DIST_LIBS))
! XP_DIST_DEP_LIBS	:= $(wildcard $(addprefix $(DIST)/,$(patsubst -l%,bin/$(LIB_PREFIX)%$(DLL_SUFFIX),$(XP_DIST_DEP_LIBS:-l%_s=lib/lib%_s)))*)
  
  EXTRA_DEPS		= \
  			$(XP_DIST_DEP_LIBS) \
--- 163,169 ----
  GTK_LIBS		= unix/gtk/libviewer_gtk_s.a -lgtksuperwin $(XP_LIBS) $(MOZ_GTK_LDFLAGS)
  
  XP_DIST_DEP_LIBS	:= $(filter-out -L$(DIST)/bin -L$(DIST)/lib, $(XP_DIST_LIBS))
! XP_DIST_DEP_LIBS	:= $(wildcard $(addprefix $(DIST)/,$(patsubst -l%,bin/$(DLL_PREFIX)%$(DLL_SUFFIX),$(XP_DIST_DEP_LIBS:-l%_s=lib/lib%_s)))*)
  
  EXTRA_DEPS		= \
  			$(XP_DIST_DEP_LIBS) \
*** misc/mozilla/widget/src/gtk2/nsDragService.cpp	Wed Oct 29 21:48:41 2003
--- misc/build/mozilla/widget/src/gtk2/nsDragService.cpp	Thu Mar 29 14:27:09 2007
***************
*** 838,844 ****
              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
          listTarget->target = g_strdup(gMimeListType);
          listTarget->flags = 0;
!         listTarget->info = (guint)listAtom;
          PR_LOG(sDragLm, PR_LOG_DEBUG,
                 ("automatically adding target %s with id %ld\n",
                 listTarget->target, listAtom));
--- 838,844 ----
              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
          listTarget->target = g_strdup(gMimeListType);
          listTarget->flags = 0;
!         listTarget->info = GPOINTER_TO_UINT(listAtom);
          PR_LOG(sDragLm, PR_LOG_DEBUG,
                 ("automatically adding target %s with id %ld\n",
                 listTarget->target, listAtom));
***************
*** 877,883 ****
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              listTarget->target = g_strdup(gTextUriListType);
                              listTarget->flags = 0;
!                             listTarget->info = (guint)listAtom;
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", listTarget->target, listAtom));
--- 877,883 ----
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              listTarget->target = g_strdup(gTextUriListType);
                              listTarget->flags = 0;
!                             listTarget->info = GPOINTER_TO_UINT(listAtom);
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", listTarget->target, listAtom));
***************
*** 914,920 ****
                            (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                          target->target = g_strdup(flavorStr);
                          target->flags = 0;
!                         target->info = (guint)atom;
                          PR_LOG(sDragLm, PR_LOG_DEBUG,
                                 ("adding target %s with id %ld\n",
                                 target->target, atom));
--- 914,920 ----
                            (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                          target->target = g_strdup(flavorStr);
                          target->flags = 0;
!                         target->info = GPOINTER_TO_UINT(atom);
                          PR_LOG(sDragLm, PR_LOG_DEBUG,
                                 ("adding target %s with id %ld\n",
                                 target->target, atom));
***************
*** 931,937 ****
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              plainTarget->target = g_strdup(kTextMime);
                              plainTarget->flags = 0;
!                             plainTarget->info = (guint)plainAtom;
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", plainTarget->target, plainAtom));
--- 931,937 ----
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              plainTarget->target = g_strdup(kTextMime);
                              plainTarget->flags = 0;
!                             plainTarget->info = GPOINTER_TO_UINT(plainAtom);
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", plainTarget->target, plainAtom));
***************
*** 948,954 ****
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              urlTarget->target = g_strdup(gMozUrlType);
                              urlTarget->flags = 0;
!                             urlTarget->info = (guint)urlAtom;
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", urlTarget->target, urlAtom));
--- 948,954 ----
                               (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
                              urlTarget->target = g_strdup(gMozUrlType);
                              urlTarget->flags = 0;
!                             urlTarget->info = GPOINTER_TO_UINT(urlAtom);
                              PR_LOG(sDragLm, PR_LOG_DEBUG,
                                     ("automatically adding target %s with \
                                     id %ld\n", urlTarget->target, urlAtom));
*** misc/mozilla/widget/src/windows/nsDataObj.cpp	Wed Oct 27 01:50:31 2004
--- misc/build/mozilla/widget/src/windows/nsDataObj.cpp	Thu Mar 29 14:27:09 2007
***************
*** 504,515 ****
--- 504,523 ----
        return E_OUTOFMEMORY;
  
      char titleStr[MAX_PATH+1];
+ #ifdef __MINGW32__
+     int lenTitleStr = WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, title.get()), title.Length(), titleStr, MAX_PATH, NULL, NULL);
+ #else
      int lenTitleStr = WideCharToMultiByte(CP_ACP, 0, title.get(), title.Length(), titleStr, MAX_PATH, NULL, NULL);
+ #endif
      if (!lenTitleStr && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // this is a very rare situation
        int len = title.Length() - 1;
        while ((len > 0) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
+ #ifdef __MINGW32__
+         lenTitleStr = WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, title.get()), len--, titleStr, MAX_PATH, NULL, NULL);  
+ #else
          lenTitleStr = WideCharToMultiByte(CP_ACP, 0, title.get(), len--, titleStr, MAX_PATH, NULL, NULL);  
+ #endif
        } 
      }
      titleStr[lenTitleStr] = '\0';
*** misc/mozilla/widget/src/windows/nsFilePicker.cpp	Wed Dec  8 16:58:30 2004
--- misc/build/mozilla/widget/src/windows/nsFilePicker.cpp	Thu Mar 29 14:27:09 2007
***************
*** 117,123 ****
--- 117,127 ----
  
    PRBool result = PR_FALSE;
    PRUnichar fileBuffer[FILE_BUFFER_SIZE+1];
+ #ifdef __MINGW32__
+   wcsncpy(NS_REINTERPRET_CAST(LPWSTR, fileBuffer),  NS_REINTERPRET_CAST(LPCWSTR, mDefault.get()), FILE_BUFFER_SIZE);
+ #else
    wcsncpy(fileBuffer,  mDefault.get(), FILE_BUFFER_SIZE);
+ #endif
  
    NS_NAMED_LITERAL_STRING(htmExt, "html");
    nsAutoString initialDir;
***************
*** 133,146 ****
--- 137,158 ----
  
    if (mMode == modeGetFolder) {
      PRUnichar dirBuffer[MAX_PATH+1];
+ #ifdef __MINGW32__
+     wcsncpy(NS_REINTERPRET_CAST(LPWSTR, dirBuffer), NS_REINTERPRET_CAST(LPCWSTR, initialDir.get()), MAX_PATH);
+ #else
      wcsncpy(dirBuffer, initialDir.get(), MAX_PATH);
+ #endif
  
      BROWSEINFOW browserInfo;
      browserInfo.hwndOwner      = (HWND)
        (mParentWidget.get() ? mParentWidget->GetNativeData(NS_NATIVE_WINDOW) : 0); 
      browserInfo.pidlRoot       = nsnull;
      browserInfo.pszDisplayName = (LPWSTR)dirBuffer;
+ #ifdef __MINGW32__
+     browserInfo.lpszTitle      = NS_REINTERPRET_CAST(LPCWSTR, mTitle.get());
+ #else
      browserInfo.lpszTitle      = mTitle.get();
+ #endif
      browserInfo.ulFlags        = BIF_USENEWUI | BIF_RETURNONLYFSDIRS;
      if (initialDir.Length()) // convert folder path to native, the strdup copy will be released in BrowseCallbackProc
      {
***************
*** 183,189 ****
--- 195,205 ----
      nsString filterBuffer = mFilterList;
                                    
      if (!initialDir.IsEmpty()) {
+ #ifdef __MINGW32__
+       ofn.lpstrInitialDir = NS_REINTERPRET_CAST(LPCWSTR, initialDir.get());
+ #else
        ofn.lpstrInitialDir = initialDir.get();
+ #endif
      }
      
      ofn.lpstrTitle   = (LPCWSTR)mTitle.get();
***************
*** 191,203 ****
--- 207,227 ----
      ofn.nFilterIndex = mSelectedType;
      ofn.hwndOwner    = (HWND)
        (mParentWidget.get() ? mParentWidget->GetNativeData(NS_NATIVE_WINDOW) : 0); 
+ #ifdef __MINGW32__
+     ofn.lpstrFile    = NS_REINTERPRET_CAST(LPWSTR, fileBuffer);
+ #else
      ofn.lpstrFile    = fileBuffer;
+ #endif
      ofn.nMaxFile     = FILE_BUFFER_SIZE;
  
      ofn.Flags = OFN_NOCHANGEDIR | OFN_SHAREAWARE | OFN_LONGNAMES | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
  
      if (!mDefaultExtension.IsEmpty()) {
+ #ifdef __MINGW32__
+       ofn.lpstrDefExt = NS_REINTERPRET_CAST(LPCWSTR, mDefaultExtension.get());
+ #else
        ofn.lpstrDefExt = mDefaultExtension.get();
+ #endif
      }
      else {
        // Get file extension from suggested filename
***************
*** 217,223 ****
--- 241,251 ----
            //XXX Actually, behavior is sort of weird:
            //    often appends ".html" even if you have an extension
            //    It obeys your extension if you put quotes around name
+ #ifdef __MINGW32__
+           ofn.lpstrDefExt = NS_REINTERPRET_CAST(LPCWSTR, htmExt.get());
+ #else
            ofn.lpstrDefExt = htmExt.get();
+ #endif
          }
        }
      }
*** misc/mozilla/widget/src/windows/nsWindow.cpp	Sat May 29 16:27:51 2004
--- misc/build/mozilla/widget/src/windows/nsWindow.cpp	Thu Mar 29 14:27:09 2007
***************
*** 444,449 ****
--- 444,452 ----
  
  // VC++5.0 header doesn't have reconvertion structure and message.
  #ifndef WM_IME_REQUEST
+ #define WM_IME_REQUEST                  0x0288
+ #endif
+ #ifndef IMR_RECONVERTSTRING
  typedef struct tagRECONVERTSTRING {
      DWORD dwSize;
      DWORD dwVersion;
***************
*** 456,462 ****
  } RECONVERTSTRING, FAR * LPRECONVERTSTRING;
  
  #define IMR_RECONVERTSTRING             0x0004
- #define WM_IME_REQUEST                  0x0288
  #endif
  
  // from http://msdn.microsoft.com/library/specs/msime.h
--- 459,464 ----
***************
*** 480,486 ****
--- 482,490 ----
  //
  #ifndef WM_APPCOMMAND
  #define WM_APPCOMMAND  0x0319
+ #endif
  
+ #ifndef APPCOMMAND_BROWSER_BACKWARD
  #define APPCOMMAND_BROWSER_BACKWARD       1
  #define APPCOMMAND_BROWSER_FORWARD        2
  #define APPCOMMAND_BROWSER_REFRESH        3
***************
*** 517,523 ****
  //#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
  //#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)
  
! #endif  // #ifndef WM_APPCOMMAND
  
  static PRBool LangIDToCP(WORD aLangID, UINT& oCP)
  {
--- 521,527 ----
  //#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
  //#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)
  
! #endif  // #ifndef APPCOMMAND_BROWSER_BACKWARD
  
  static PRBool LangIDToCP(WORD aLangID, UINT& oCP)
  {
***************
*** 5529,5535 ****
--- 5533,5543 ----
     if(acp)
     {
        int outlen = ::WideCharToMultiByte( CP_ACP, 0, 
+ #ifdef __MINGW32__
+                       NS_REINTERPRET_CAST(LPCWSTR, aStr.get()), aStr.Length(),
+ #else
                        aStr.get(), aStr.Length(),
+ #endif
                        acp, acplen, NULL, NULL);
        if ( outlen >= 0)
           acp[outlen] = '\0';  // null terminate
***************
*** 5696,5702 ****
--- 5704,5714 ----
      unicharSize = ::MultiByteToWideChar(gCurrentKeyboardCP,MB_PRECOMPOSED,
        mIMECompString->get(),
        mIMECompString->Length(),
+ #ifdef __MINGW32__
+       NS_REINTERPRET_CAST(LPWSTR, mIMECompUnicode->BeginWriting()),
+ #else
        mIMECompUnicode->BeginWriting(),
+ #endif
        unicharSize+1);
      mIMECompUnicode->SetLength(unicharSize);
    }
***************
*** 6472,6478 ****
--- 6484,6494 ----
          *oResult = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
        } else {
          len = ::WideCharToMultiByte(gCurrentKeyboardCP, 0,
+ #ifdef __MINGW32__
+                                     NS_REINTERPRET_CAST(LPCWSTR, mIMEReconvertUnicode),
+ #else
                                      mIMEReconvertUnicode,
+ #endif
                                      nsCRT::strlen(mIMEReconvertUnicode),
                                      NULL, 0, NULL, NULL);
          *oResult = sizeof(RECONVERTSTRING) + len;
***************
*** 6491,6497 ****
--- 6507,6517 ----
        *oResult = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
      } else {
        len = ::WideCharToMultiByte(gCurrentKeyboardCP, 0,
+ #ifdef __MINGW32__
+                                   NS_REINTERPRET_CAST(LPCWSTR, mIMEReconvertUnicode),
+ #else
                                    mIMEReconvertUnicode,
+ #endif
                                    nsCRT::strlen(mIMEReconvertUnicode),
                                    NULL, 0, NULL, NULL);
        *oResult = sizeof(RECONVERTSTRING) + len;
***************
*** 6512,6518 ****
--- 6532,6542 ----
                     mIMEReconvertUnicode, len * sizeof(WCHAR));
      } else {
        ::WideCharToMultiByte(gCurrentKeyboardCP, 0,
+ #ifdef __MINGW32__
+                             NS_REINTERPRET_CAST(LPCWSTR, mIMEReconvertUnicode),
+ #else
                              mIMEReconvertUnicode,
+ #endif
                              nsCRT::strlen(mIMEReconvertUnicode),
                              (LPSTR) (aData + sizeof(RECONVERTSTRING)),
                              len,
*** misc/mozilla/xpcom/base/nsStackFrameUnix.cpp	Mon Mar  8 02:47:44 2004
--- misc/build/mozilla/xpcom/base/nsStackFrameUnix.cpp	Thu Mar 29 14:27:09 2007
***************
*** 78,102 ****
  }
  
  
! #if defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC)) // i386 or PPC Linux stackwalking code
  
- #include <setjmp.h>
- //
  
  void DumpStackToFile(FILE* aStream)
  {
-   jmp_buf jb;
-   setjmp(jb);
- 
    // Stack walking code courtesy Kipp's "leaky".
  
!   // Get the frame pointer out of the jmp_buf
!   void **bp = (void**)
! #if defined(__i386) 
!     (jb[0].__jmpbuf[JB_BP]);
! #elif defined(PPC)
!     (jb[0].__jmpbuf[JB_GPR1]);
! #endif
  
    int skip = 2;
    for ( ; (void**)*bp > bp; bp = (void**)*bp) {
--- 78,92 ----
  }
  
  
! #if defined(linux) && defined(__GNUC__) && (defined(__i386) || defined(PPC)) // i386 or PPC Linux stackwalking code
  
  
  void DumpStackToFile(FILE* aStream)
  {
    // Stack walking code courtesy Kipp's "leaky".
  
!   // Get the frame pointer
!   void **bp = (void**) __builtin_frame_address(0);
  
    int skip = 2;
    for ( ; (void**)*bp > bp; bp = (void**)*bp) {
*** misc/mozilla/xpcom/base/nsTraceRefcntImpl.cpp	Wed Feb 11 02:16:10 2004
--- misc/build/mozilla/xpcom/base/nsTraceRefcntImpl.cpp	Thu Mar 29 14:27:09 2007
***************
*** 50,68 ****
  
  #if defined(_WIN32)
  #include <windows.h>
- #elif defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC))
- #include <setjmp.h>
- 
- //
- // On glibc 2.1, the Dl_info api defined in <dlfcn.h> is only exposed
- // if __USE_GNU is defined.  I suppose its some kind of standards
- // adherence thing.
- //
- #if (__GLIBC_MINOR__ >= 1) && !defined(__USE_GNU)
- #define __USE_GNU
- #endif
- 
- #include <dlfcn.h>
  #endif
  
  #ifdef HAVE_LIBDL
--- 50,55 ----
***************
*** 484,490 ****
  
  #endif /* NS_BUILD_REFCNT_LOGGING */
  
! nsresult
  nsTraceRefcntImpl::DumpStatistics(StatisticsType type, FILE* out)
  {
    nsresult rv = NS_OK;
--- 471,477 ----
  
  #endif /* NS_BUILD_REFCNT_LOGGING */
  
! NS_COM nsresult
  nsTraceRefcntImpl::DumpStatistics(StatisticsType type, FILE* out)
  {
    nsresult rv = NS_OK;
***************
*** 561,567 ****
    return rv;
  }
  
! void
  nsTraceRefcntImpl::ResetStatistics()
  {
  #ifdef NS_BUILD_REFCNT_LOGGING
--- 548,554 ----
    return rv;
  }
  
! NS_COM void
  nsTraceRefcntImpl::ResetStatistics()
  {
  #ifdef NS_BUILD_REFCNT_LOGGING
***************
*** 850,856 ****
  
  #if defined(_WIN32) && defined(_M_IX86) // WIN32 x86 stack walking code
  #include "nsStackFrameWin.h"
! void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
    DumpStackToFile(aStream);
--- 837,843 ----
  
  #if defined(_WIN32) && defined(_M_IX86) // WIN32 x86 stack walking code
  #include "nsStackFrameWin.h"
! NS_COM void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
    DumpStackToFile(aStream);
***************
*** 858,866 ****
  
  // WIN32 x86 stack walking code
  // i386 or PPC Linux stackwalking code or Solaris
! #elif (defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC))) || (defined(__sun) && (defined(__sparc) || defined(sparc) || defined(__i386) || defined(i386)))
  #include "nsStackFrameUnix.h"
! void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
    DumpStackToFile(aStream);
--- 845,853 ----
  
  // WIN32 x86 stack walking code
  // i386 or PPC Linux stackwalking code or Solaris
! #elif (defined(linux) && defined(__GNUC__) && (defined(__i386) || defined(PPC))) || (defined(__sun) && (defined(__sparc) || defined(sparc) || defined(__i386) || defined(i386)))
  #include "nsStackFrameUnix.h"
! NS_COM void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
    DumpStackToFile(aStream);
***************
*** 960,966 ****
  
  #else // unsupported platform.
  
! void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
  	fprintf(aStream, "write me, dammit!\n");
--- 947,953 ----
  
  #else // unsupported platform.
  
! NS_COM void
  nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
  {
  	fprintf(aStream, "write me, dammit!\n");
*** misc/mozilla/xpcom/base/nscore.h	Thu Mar 25 15:55:16 2004
--- misc/build/mozilla/xpcom/base/nscore.h	Thu Mar 29 14:27:09 2007
***************
*** 282,288 ****
     * commercial build.  When this is fixed there will be no need for the
     * |NS_REINTERPRET_CAST| in nsLiteralString.h either.
     */
!   #if defined(HAVE_CPP_2BYTE_WCHAR_T) && (defined(NS_WIN32) || defined(XP_MAC))
      typedef wchar_t PRUnichar;
    #else
      typedef PRUint16 PRUnichar;
--- 282,288 ----
     * commercial build.  When this is fixed there will be no need for the
     * |NS_REINTERPRET_CAST| in nsLiteralString.h either.
     */
!   #if defined(HAVE_CPP_2BYTE_WCHAR_T) && !defined(__MINGW32__) && (defined(NS_WIN32) || defined(XP_MAC))
      typedef wchar_t PRUnichar;
    #else
      typedef PRUint16 PRUnichar;
*** misc/mozilla/xpcom/io/nsLocalFileWin.cpp	Thu May 13 16:59:45 2004
--- misc/build/mozilla/xpcom/io/nsLocalFileWin.cpp	Thu Mar 29 14:27:09 2007
***************
*** 552,558 ****
--- 552,562 ----
              }
  
              if (gResolver)
+ #ifdef __MINGW32__
+                 rv = gResolver->Resolve(NS_REINTERPRET_CAST(LPCWSTR, ucsBuf.get()), temp);
+ #else
                  rv = gResolver->Resolve(ucsBuf.get(), temp);
+ #endif
              else
                  rv = NS_ERROR_FAILURE;
  
*** misc/mozilla/xpcom/io/nsNativeCharsetUtils.cpp	Mon Nov  8 09:44:27 2004
--- misc/build/mozilla/xpcom/io/nsNativeCharsetUtils.cpp	Thu Mar 29 14:27:09 2007
***************
*** 890,896 ****
--- 890,900 ----
  
          PRUnichar *result = out_iter.get();
  
+ #ifdef __MINGW32__
+         ::MultiByteToWideChar(CP_ACP, 0, buf, inputLen, NS_REINTERPRET_CAST(LPWSTR, result), resultLen);
+ #else
          ::MultiByteToWideChar(CP_ACP, 0, buf, inputLen, result, resultLen);
+ #endif
      }
      return NS_OK;
  }
***************
*** 908,914 ****
--- 912,922 ----
      // determine length of result
      PRUint32 resultLen = 0;
  
+ #ifdef __MINGW32__
+     int n = ::WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, buf), inputLen, NULL, 0, NULL, NULL);
+ #else
      int n = ::WideCharToMultiByte(CP_ACP, 0, buf, inputLen, NULL, 0, NULL, NULL);
+ #endif
      if (n > 0)
          resultLen += n;
  
***************
*** 924,930 ****
--- 932,942 ----
  
          char *result = out_iter.get();
  
+ #ifdef __MINGW32__
+         ::WideCharToMultiByte(CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, buf), inputLen, result, resultLen,
+ #else
          ::WideCharToMultiByte(CP_ACP, 0, buf, inputLen, result, resultLen,
+ #endif
                                &defaultChar, NULL);
      }
      return NS_OK;
*** misc/mozilla/xpcom/reflect/xptinfo/public/xptinfo.h	Tue Jun 24 18:12:34 2003
--- misc/build/mozilla/xpcom/reflect/xptinfo/public/xptinfo.h	Thu Mar 29 14:27:09 2007
***************
*** 132,138 ****
          }
  
      PRBool IsArray() const
!         {return (PRBool) TagPart() == T_ARRAY;}
  
      // 'Dependent' means that params of this type are dependent upon other 
      // params. e.g. an T_INTERFACE_IS is dependent upon some other param at 
--- 132,138 ----
          }
  
      PRBool IsArray() const
!         {return (PRBool) (TagPart() == T_ARRAY);}
  
      // 'Dependent' means that params of this type are dependent upon other 
      // params. e.g. an T_INTERFACE_IS is dependent upon some other param at 
***************
*** 152,158 ****
      uint8 TagPart() const
          {return (uint8) (flags & XPT_TDP_TAGMASK);}
  
!     enum
      {
          T_I8                = TD_INT8             ,
          T_I16               = TD_INT16            ,
--- 152,158 ----
      uint8 TagPart() const
          {return (uint8) (flags & XPT_TDP_TAGMASK);}
  
!     enum _xpttype
      {
          T_I8                = TD_INT8             ,
          T_I16               = TD_INT16            ,
*** misc/mozilla/xpfe/bootstrap/Makefile.in	Thu Jun 24 14:58:48 2004
--- misc/build/mozilla/xpfe/bootstrap/Makefile.in	Thu Mar 29 14:27:09 2007
***************
*** 84,94 ****
--- 84,97 ----
  
  include $(topsrcdir)/config/config.mk
  
+ # reduce prerequisites by disabling mozilla binary
+ ifndef DISABLE_MOZ_EXECUTABLE
  ifeq ($(USE_SHORT_LIBNAME),1)
  PROGRAM		= mozilla$(BIN_SUFFIX)
  else
  PROGRAM		= mozilla-bin$(BIN_SUFFIX)
  endif
+ endif
  
  # Force applications to be built non-statically
  # when building the mozcomps meta component
*** misc/mozilla/xpfe/bootstrap/nsNativeAppSupportWin.cpp	Tue Dec 14 11:26:56 2004
--- misc/build/mozilla/xpfe/bootstrap/nsNativeAppSupportWin.cpp	Thu Mar 29 14:27:09 2007
***************
*** 113,119 ****
--- 113,123 ----
      int acplen = aStr.Length() * 2 + 1;
      char * acp = new char[ acplen ];
      if( acp ) {
+ #ifdef __MINGW32__
+         int outlen = ::WideCharToMultiByte( CP_ACP, 0, NS_REINTERPRET_CAST(LPCWSTR, aStr.get()), aStr.Length(),
+ #else
          int outlen = ::WideCharToMultiByte( CP_ACP, 0, aStr.get(), aStr.Length(),
+ #endif
                                              acp, acplen, NULL, NULL );
          if ( outlen >= 0)
              acp[ outlen ] = '\0';  // null terminate
***************
*** 2423,2429 ****
--- 2427,2437 ----
          }
          // Create menu and add item.
          mTrayIconMenu = ::CreatePopupMenu();
+ #ifdef __MINGW32__
+         ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_NAVIGATOR, NS_REINTERPRET_CAST(LPCWSTR, navigatorText.get()) );
+ #else
          ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_NAVIGATOR, navigatorText.get() );
+ #endif
          if ( ::GetLastError() == ERROR_CALL_NOT_IMPLEMENTED ) {
              AppendMenuItem( mTrayIconMenu, TURBO_NAVIGATOR, navigatorText );
              if ( isMail )
***************
*** 2437,2442 ****
--- 2445,2459 ----
          }
          else {
              if (isMail)
+ #ifdef __MINGW32__
+                 ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_MAIL, NS_REINTERPRET_CAST(LPCWSTR, mailText.get()) );
+             ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_EDITOR, NS_REINTERPRET_CAST(LPCWSTR, editorText.get()) );
+             if (isMail)
+                 ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_ADDRESSBOOK, NS_REINTERPRET_CAST(LPCWSTR, addressbookText.get()) );
+             ::AppendMenuW( mTrayIconMenu, MF_SEPARATOR, NULL, NULL );
+             ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_DISABLE, NS_REINTERPRET_CAST(LPCWSTR, disableText.get()) );
+             ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_EXIT, NS_REINTERPRET_CAST(LPCWSTR, exitText.get()) );
+ #else
                  ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_MAIL, mailText.get() );
              ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_EDITOR, editorText.get() );
              if (isMail)
***************
*** 2444,2449 ****
--- 2461,2467 ----
              ::AppendMenuW( mTrayIconMenu, MF_SEPARATOR, NULL, NULL );
              ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_DISABLE, disableText.get() );
              ::AppendMenuW( mTrayIconMenu, MF_STRING, TURBO_EXIT, exitText.get() );
+ #endif
          }
      }
  
