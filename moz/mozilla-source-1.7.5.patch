diff -ru misc/mozilla/gfx/idl/nsIFreeType2.idl misc/build/mozilla/gfx/idl/nsIFreeType2.idl
--- misc/mozilla/gfx/idl/nsIFreeType2.idl	2004-04-15 21:09:33.000000000 -0400
+++ misc/build/mozilla/gfx/idl/nsIFreeType2.idl	2005-01-09 13:23:32.968750000 -0500
@@ -76,10 +76,11 @@
 native FT_Sfnt_Tag(FT_Sfnt_Tag);
 native FT_Size(FT_Size);
 
-[ptr] native FTC_Image_Desc_p(FTC_Image_Desc);
+[ptr] native FTC_ImageType_p(FTC_ImageType);
 native FTC_Face_Requester(FTC_Face_Requester);
 native FTC_Font(FTC_Font);
-native FTC_Image_Cache(FTC_Image_Cache);
+native FTC_FaceID(FTC_FaceID);
+native FTC_ImageCache(FTC_ImageCache);
 native FTC_Manager(FTC_Manager);
 
 // #ifdef MOZ_SVG
@@ -99,7 +100,7 @@
 
     readonly attribute FT_Library library;
     readonly attribute FTC_Manager FTCacheManager;
-    readonly attribute FTC_Image_Cache ImageCache;
+    readonly attribute FTC_ImageCache ImageCache;
 
     void    doneFace(in FT_Face face);
     void    doneFreeType(in FT_Library lib);
@@ -115,16 +116,16 @@
     void    outlineDecompose(in FT_Outline_p outline,
                              in const_FT_Outline_Funcs_p funcs, in voidPtr p);
     void    setCharmap(in FT_Face face, in FT_CharMap charmap);
-    void    imageCacheLookup(in FTC_Image_Cache cache, in FTC_Image_Desc_p desc,
+    void    imageCacheLookup(in FTC_ImageCache cache, in FTC_ImageType_p desc,
                              in FT_UInt gindex, out FT_Glyph glyph);
-    void    managerLookupSize(in FTC_Manager manager, in FTC_Font font,
-                              out FT_Face face, out FT_Size size);
+    void    managerLookupFace(in FTC_Manager manager, in FTC_FaceID face_id,
+                              out FT_Face face);
     void    managerDone(in FTC_Manager manager);
     void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                        in FT_UInt max_sizes, in FT_ULong max_bytes,
                        in FTC_Face_Requester requester, in FT_Pointer req_data,
                        out FTC_Manager manager);
-    void    imageCacheNew(in FTC_Manager manager, out FTC_Image_Cache cache);
+    void    imageCacheNew(in FTC_Manager manager, out FTC_ImageCache cache);
 /* #ifdef MOZ_SVG */
     void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                         in FT_Vector_p delta);
diff -ru misc/mozilla/gfx/src/freetype/nsFreeType.cpp misc/build/mozilla/gfx/src/freetype/nsFreeType.cpp
--- misc/mozilla/gfx/src/freetype/nsFreeType.cpp	2004-02-07 10:22:30.000000000 -0500
+++ misc/build/mozilla/gfx/src/freetype/nsFreeType.cpp	2005-01-09 13:23:33.015625000 -0500
@@ -111,7 +111,7 @@
   {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
   {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
   {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
-  {"FTC_Manager_Lookup_Size", NS_FT2_OFFSET(nsFTC_Manager_Lookup_Size), PR_TRUE},
+  {"FTC_Manager_LookupFace",  NS_FT2_OFFSET(nsFTC_Manager_LookupFace),  PR_TRUE},
   {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
   {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
   {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
@@ -282,7 +282,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ImageCacheLookup(FTC_Image_Cache cache, FTC_Image_Desc *desc,
+nsFreeType2::ImageCacheLookup(FTC_ImageCache cache, FTC_ImageType *desc,
                               FT_UInt glyphID, FT_Glyph *glyph)
 { 
   // call the FreeType2 function via the function pointer
@@ -291,11 +291,11 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ManagerLookupSize(FTC_Manager manager, FTC_Font font,
-                               FT_Face *face, FT_Size *size)
+nsFreeType2::ManagerLookupFace(FTC_Manager manager, FTC_FaceID font,
+                               FT_Face *face)
 { 
   // call the FreeType2 function via the function pointer
-  FT_Error error = nsFTC_Manager_Lookup_Size(manager, font, face, size);
+  FT_Error error = nsFTC_Manager_LookupFace(manager, font, face);
   return error ? NS_ERROR_FAILURE : NS_OK;
 } 
  
@@ -320,7 +320,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_Image_Cache *cache)
+nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_ImageCache *cache)
 { 
   // call the FreeType2 function via the function pointer
   FT_Error error = nsFTC_Image_Cache_New(manager, cache);
@@ -389,7 +389,7 @@
 } 
  
 NS_IMETHODIMP
-nsFreeType2::GetImageCache(FTC_Image_Cache *aCache)
+nsFreeType2::GetImageCache(FTC_ImageCache *aCache)
 {
   *aCache = mImageCache;
   return NS_OK;
diff -ru misc/mozilla/gfx/src/freetype/nsFreeType.h misc/build/mozilla/gfx/src/freetype/nsFreeType.h
--- misc/mozilla/gfx/src/freetype/nsFreeType.h	2004-04-16 17:31:42.000000000 -0400
+++ misc/build/mozilla/gfx/src/freetype/nsFreeType.h	2005-01-09 13:23:33.015625000 -0500
@@ -104,13 +104,13 @@
 typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
 typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
 typedef FT_Error (*FTC_Image_Cache_Lookup_t)
-                      (FTC_Image_Cache, FTC_Image_Desc*, FT_UInt, FT_Glyph*);
-typedef FT_Error (*FTC_Manager_Lookup_Size_t)
-                      (FTC_Manager, FTC_Font, FT_Face*, FT_Size*);
+                       (FTC_ImageCache, FTC_ImageType*, FT_UInt, FT_Glyph*);
+typedef FT_Error (*FTC_Manager_LookupFace_t)
+                       (FTC_Manager, FTC_FaceID, FT_Face*);
 typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
 typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                        FTC_Face_Requester, FT_Pointer, FTC_Manager*);
-typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_Image_Cache*);
+typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_ImageCache*);
 // #ifdef MOZ_SVG
 typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
 typedef FT_Error (*FT_Get_Kerning_t)
@@ -165,7 +165,7 @@
   FT_Outline_Decompose_t    nsFT_Outline_Decompose;
   FT_Set_Charmap_t          nsFT_Set_Charmap;
   FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
-  FTC_Manager_Lookup_Size_t nsFTC_Manager_Lookup_Size;
+  FTC_Manager_LookupFace_t  nsFTC_Manager_LookupFace;
   FTC_Manager_Done_t        nsFTC_Manager_Done;
   FTC_Manager_New_t         nsFTC_Manager_New;
   FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
@@ -213,7 +213,7 @@
   PRLibrary      *mSharedLib;
   FT_Library      mFreeTypeLibrary;
   FTC_Manager     mFTCacheManager;
-  FTC_Image_Cache mImageCache;
+  FTC_ImageCache  mImageCache;
 
   static nsHashtable   *sFontFamilies;
   static nsHashtable   *sRange1CharSetNames;
diff -ru misc/mozilla/gfx/src/ps/nsFontMetricsPS.cpp misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.cpp
--- misc/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2004-02-04 20:57:05.000000000 -0500
+++ misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2005-01-09 13:23:33.031250000 -0500
@@ -1141,10 +1141,10 @@
   
   mPixelSize = NSToIntRound(app2dev * mFont->size);
 
-  mImageDesc.font.face_id    = (void*)mEntry;
-  mImageDesc.font.pix_width  = mPixelSize;
-  mImageDesc.font.pix_height = mPixelSize;
-  mImageDesc.image_type = 0;
+  mImageDesc->face_id = (FTC_FaceID)&mEntry;
+  mImageDesc->width  = mPixelSize;
+  mImageDesc->height = mPixelSize;
+  mImageDesc->flags = 0;
 
   nsresult rv;
   mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
@@ -1190,7 +1190,7 @@
   if (!face)
     return 0;
 
-  FTC_Image_Cache iCache;
+  FTC_ImageCache iCache;
   nsresult rv = mFt2->GetImageCache(&iCache);
   if (NS_FAILED(rv)) {
     NS_ERROR("Failed to get Image Cache");
@@ -1228,8 +1228,8 @@
   
   FTC_Manager cManager;
   mFt2->GetFTCacheManager(&cManager);
-  nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
-                                        &face, nsnull);
+  nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
+                                        &face);
   NS_ASSERTION(rv==0, "failed to get face/size");
   if (rv)
     return nsnull;
@@ -1622,16 +1622,16 @@
   mEntry->GetFamilyName(fontName);
   mEntry->GetStyleName(styleName);
   
-  mImageDesc.font.face_id    = (void*)mEntry;
+  mImageDesc->face_id = (FTC_FaceID)&mEntry;
   // TT glyph has no relation to size
-  mImageDesc.font.pix_width  = 16;
-  mImageDesc.font.pix_height = 16;
-  mImageDesc.image_type = 0;
+  mImageDesc->width  = 16;
+  mImageDesc->height = 16;
+  mImageDesc->flags = 0;
   FT_Face face = nsnull;
   FTC_Manager cManager;
   mFt2->GetFTCacheManager(&cManager);
-  nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
-                                        &face, nsnull);
+  nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
+                                        &face);
   if (NS_FAILED(rv))
     return;
  
diff -ru misc/mozilla/gfx/src/ps/nsFontMetricsPS.h misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.h
--- misc/mozilla/gfx/src/ps/nsFontMetricsPS.h	2003-04-22 12:25:09.000000000 -0400
+++ misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.h	2005-01-09 13:23:33.046875000 -0500
@@ -320,7 +320,7 @@
   nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
   nsCOMPtr<nsIFreeType2> mFt2;
   PRUint16        mPixelSize;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
 
 
   static PRBool AddUserPref(nsIAtom *aLang, const nsFont& aFont,
@@ -363,7 +363,7 @@
 protected:
   nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
   nsCOMPtr<nsIFreeType2> mFt2;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
 };
 #endif
 
diff -ru misc/mozilla/gfx/src/x11shared/nsFontFreeType.cpp misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.cpp
--- misc/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2003-12-25 03:24:52.000000000 -0500
+++ misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2005-01-09 13:23:33.062500000 -0500
@@ -177,7 +177,7 @@
   FTC_Manager mgr;
   nsresult rv;
   mFt2->GetFTCacheManager(&mgr);
-  rv = mFt2->ManagerLookupSize(mgr, &mImageDesc.font, &face, nsnull);
+  rv = mFt2->ManagerLookupFace(mgr, mImageDesc->face_id, &face);
   NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
   if (NS_FAILED(rv))
     return nsnull;
@@ -191,22 +191,15 @@
   PRBool embedded_bimap = PR_FALSE;
   mFaceID = aFaceID;
   mPixelSize = aPixelSize;
-  mImageDesc.font.face_id    = (void*)mFaceID;
-  mImageDesc.font.pix_width  = aPixelSize;
-  mImageDesc.font.pix_height = aPixelSize;
-  mImageDesc.image_type = 0;
+  mImageDesc->face_id = (FTC_FaceID)&mFaceID;
+  mImageDesc->width  = aPixelSize;
+  mImageDesc->height = aPixelSize;
+  mImageDesc->flags = 0;
 
   if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
-    mImageDesc.image_type |= ftc_image_mono;
     anti_alias = PR_FALSE;
   }
 
-  if (nsFreeType2::gFreeType2Autohinted)
-    mImageDesc.image_type |= ftc_image_flag_autohinted;
-
-  if (nsFreeType2::gFreeType2Unhinted)
-    mImageDesc.image_type |= ftc_image_flag_unhinted;
-
   PRUint32  num_embedded_bitmaps, i;
   PRInt32*  embedded_bitmapheights;
   mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
@@ -218,7 +211,6 @@
         if (embedded_bitmapheights[i] == aPixelSize) {
           embedded_bimap = PR_TRUE;
           // unhinted must be set for embedded bitmaps to be used
-          mImageDesc.image_type |= ftc_image_flag_unhinted;
           break;
         }
       }
@@ -312,7 +304,7 @@
   if (!face)
     return NS_ERROR_FAILURE;
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return NS_ERROR_FAILURE;
@@ -401,7 +393,7 @@
   if (!face)
     return 0;
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return 0;
@@ -723,7 +715,7 @@
     if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
 #endif
 
-  FTC_Image_Cache icache;
+  FTC_ImageCache icache;
   mFt2->GetImageCache(&icache);
   if (!icache)
     return 0;
diff -ru misc/mozilla/gfx/src/x11shared/nsFontFreeType.h misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.h
--- misc/mozilla/gfx/src/x11shared/nsFontFreeType.h	2003-04-22 12:25:13.000000000 -0400
+++ misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.h	2005-01-09 13:23:33.078125000 -0500
@@ -110,7 +110,7 @@
   XImage *GetXImage(PRUint32 width, PRUint32 height);
   nsITrueTypeFontCatalogEntry *mFaceID;
   PRUint16        mPixelSize;
-  FTC_Image_Desc  mImageDesc;
+  FTC_ImageType   mImageDesc;
   nsCOMPtr<nsIFreeType2> mFt2;
 };
 
diff -ru misc/mozilla/jpeg/jmorecfg.h misc/build/mozilla/jpeg/jmorecfg.h
--- misc/mozilla/jpeg/jmorecfg.h	2004-03-25 20:17:16.000000000 -0500
+++ misc/build/mozilla/jpeg/jmorecfg.h	2005-01-09 13:23:33.093750000 -0500
@@ -108,8 +108,8 @@
 /* Defines for MMX/SSE2 support. */
 
 #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
-#define HAVE_MMX_INTEL_MNEMONICS 
-#define HAVE_SSE2_INTEL_MNEMONICS 
+//#define HAVE_MMX_INTEL_MNEMONICS 
+//#define HAVE_SSE2_INTEL_MNEMONICS 
 #endif
 
 /* Compressed datastreams are represented as arrays of JOCTET.
diff -ru misc/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp misc/build/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp
--- misc/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2004-03-18 20:36:16.000000000 -0500
+++ misc/build/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2005-01-09 13:23:33.109375000 -0500
@@ -440,19 +440,19 @@
     return;
   }
 
-  FTC_Image_Desc imageDesc;
-  imageDesc.font.face_id=(void*)font_data.font_entry.get(); // XXX do we need to addref?
+  FTC_ImageType imageDesc;
+  imageDesc->face_id=(FTC_FaceID)font_data.font_entry.get(); // XXX do we need to addref?
   float twipstopixel = GetTwipsToPixels();
   float scale = GetPixelScale();
-  imageDesc.font.pix_width = (int)((float)(font_data.font.size)*twipstopixel/scale);
-  imageDesc.font.pix_height = (int)((float)(font_data.font.size)*twipstopixel/scale);
-  imageDesc.image_type |= ftc_image_grays;
+  imageDesc->width = (int)((float)(font_data.font.size)*twipstopixel/scale);
+  imageDesc->height = (int)((float)(font_data.font.size)*twipstopixel/scale);
+  imageDesc->flags |= /* ftc_image_grays */0;
 
   // get the face
   nsresult rv;
   FTC_Manager mgr;
   nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
-  rv = nsSVGLibartFreetype::ft2->ManagerLookupSize(mgr, &imageDesc.font, &mFace, nsnull);
+  rv = nsSVGLibartFreetype::ft2->ManagerLookupFace(mgr, imageDesc->face_id, &mFace);
   NS_ASSERTION(mFace, "failed to get face/size");
 }
 
diff -ru misc/mozilla/mailnews/addrbook/src/Makefile.in misc/build/mozilla/mailnews/addrbook/src/Makefile.in
--- misc/mozilla/mailnews/addrbook/src/Makefile.in	2003-10-06 13:48:56.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/Makefile.in	2005-01-09 13:23:33.125000000 -0500
@@ -86,6 +86,7 @@
                 nsVCard.cpp \
                 nsVCardObj.cpp \
                 nsMsgVCardService.cpp \
+                nsAbMD5sum.cpp	\
 		$(NULL)
 
 EXPORTS		= \
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	2002-10-11 04:17:13.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	2005-01-09 13:23:33.125000000 -0500
@@ -39,6 +39,7 @@
 #include "nsAbBoolExprToLDAPFilter.h"
 #include "nsAbLDAPProperties.h"
 #include "nsXPIDLString.h"
+#include "nsAbUtils.h"
 
 const int nsAbBoolExprToLDAPFilter::TRANSLATE_CARD_PROPERTY = 1 << 0 ;
 const int nsAbBoolExprToLDAPFilter::ALLOW_NON_CONVERTABLE_CARD_PROPERTY = 1 << 1 ;
@@ -186,13 +187,16 @@
     rv = condition->GetName (getter_Copies (name));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    const char* ldapProperty = name.get ();
+    CharPtrArrayGuard attrs;
     if (flags & TRANSLATE_CARD_PROPERTY)
     {
-        const MozillaLdapPropertyRelation* p =
-            MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ());
-        if (p)
-            ldapProperty = p->ldapProperty;
+        if(const MozillaLdapPropertyRelation* property =
+            MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ()))
+        {
+            // allow even single ldap attribute mapppings to go through this to simplify the filter creation later.
+            rv = MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (property->ldapProperty, attrs.GetSizeAddr(), attrs.GetArrayAddr() );
+            NS_ENSURE_SUCCESS(rv, rv);
+        }
         else if (!(flags & ALLOW_NON_CONVERTABLE_CARD_PROPERTY))
             return NS_OK;
     }
@@ -202,6 +206,37 @@
     NS_ENSURE_SUCCESS(rv, rv);
     NS_ConvertUCS2toUTF8 vUTF8 (value);
 
+    // check if using multiple ldap attributes
+    if(attrs.GetSize() == 1 ) 
+        GenerateSingleFilter(conditionType,filter,vUTF8,attrs.GetArray()[0]);
+    else
+    {
+        // add the opening brace if using multiple ldap attributes
+        switch (conditionType)
+        {
+            // 'NOT' conditionals use the 'AND' operator 
+            case nsIAbBooleanConditionTypes::DoesNotExist:
+            case nsIAbBooleanConditionTypes::DoesNotContain:
+            case nsIAbBooleanConditionTypes::IsNot:
+                filter += NS_LITERAL_CSTRING("(&");
+                break;
+            default:
+                filter += NS_LITERAL_CSTRING("(|");
+                break;
+        }
+        GenerateMultipleFilter(conditionType,filter,vUTF8,&attrs);
+        // add the closing brace if using multiple ldap attributes
+        filter += NS_LITERAL_CSTRING(")");
+    }
+
+    return rv;
+}
+void nsAbBoolExprToLDAPFilter:: GenerateSingleFilter(
+    nsAbBooleanConditionType conditionType,
+    nsCString& filter,
+    NS_ConvertUCS2toUTF8 &vUTF8,
+    const char *ldapProperty)
+{
     switch (conditionType)
     {
         case nsIAbBooleanConditionTypes::DoesNotExist:
@@ -282,7 +317,47 @@
         default:
             break;
     }
-
-    return rv;
 }
+void nsAbBoolExprToLDAPFilter:: GenerateMultipleFilter(
+    nsAbBooleanConditionType conditionType,
+    nsCString& filter,
+    NS_ConvertUCS2toUTF8 &vUTF8,
+    CharPtrArrayGuard *pAttrs)
+{
+    PRUint16 i = 0;
+    PRUint16 inner = 0;
+
+    /*
+     * This function is based on the fact that we are trying to generate support
+     * for multiple occurring ldap attributes. Consider the following query:
+     * (PagerNumber,=,123456) where PagerNumber = pager|pagerphone translates to: 
+     * (|(&(pager=*)(pager=123456))(&(!(pager=*))(pagerphone=123456)))
+     * This can be shortened to:
+     * (|(pager=123456)(&(!(pager=*))(pagerphone=123456)))
+     *
+     * i.e. use the first occurring attribute if it exists otherwise if first 
+     * does not exist use the second etc. The assumption is that the first
+     * always takes precedence.
+     * This translates to: 
+     *      GenerateSingleFilter(Is);
+     *          GenerateSingleFilter(DoesNotExists); 
+     *          GenerateSingleFilter(Is);
+    */
 
+    for (i = 0; i < pAttrs->GetSize(); i++)
+    {
+        if(i == 0)
+            GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+        else
+        {
+            filter += NS_LITERAL_CSTRING("(&");
+            nsAbBooleanConditionType doesNotExistsType = nsIAbBooleanConditionTypes::DoesNotExist; 
+            for(inner = 0; inner < i; ++inner)
+            {
+                GenerateSingleFilter(doesNotExistsType,filter,vUTF8,pAttrs->GetArray()[inner]); 
+            }
+            GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+            filter += NS_LITERAL_CSTRING(")");
+        }
+    }
+}
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h
--- misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2001-09-28 16:06:21.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2005-01-09 13:23:33.171875000 -0500
@@ -42,6 +42,7 @@
 #include "nsIAbBooleanExpression.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
+#include "nsAbUtils.h"
 
 class nsAbBoolExprToLDAPFilter
 {
@@ -67,6 +68,16 @@
         nsIAbBooleanConditionString* condition,
         nsCString& filter,
         int flags);
+    static void GenerateMultipleFilter(
+       nsAbBooleanConditionType conditionType,
+       nsCString& filter,
+       NS_ConvertUCS2toUTF8 &vUTF8,
+       CharPtrArrayGuard *pAttrs);
+    static void GenerateSingleFilter(
+       nsAbBooleanConditionType conditionType,
+       nsCString& filter,
+       NS_ConvertUCS2toUTF8 &vUTF8,
+       const char *ldapProperty);
 };
 
 #endif
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2004-02-13 21:09:27.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2005-01-09 13:23:33.187500000 -0500
@@ -118,11 +118,13 @@
 
     // use mURINoQuery to get a prefName
     nsCAutoString prefName;
-    prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) + NS_LITERAL_CSTRING(".uri");
+    prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) ;
 
     // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
     nsXPIDLCString URI;
-    rv = prefs->CopyCharPref(prefName.get(), getter_Copies(URI));
+    nsCAutoString uriPrefName;
+    uriPrefName = prefName + NS_LITERAL_CSTRING(".uri");
+    rv = prefs->CopyCharPref(uriPrefName.get(), getter_Copies(URI));
     if (NS_FAILED(rv))
     {
         /*
@@ -146,6 +148,27 @@
         nsCAutoString tempLDAPURL(mURINoQuery);
         tempLDAPURL.ReplaceSubstring("moz-abldapdirectory:", "ldap:");
         rv = mURL->SetSpec(tempLDAPURL);
+		NS_ENSURE_SUCCESS(rv,rv);
+    
+        nsCAutoString aHost;
+        mURL->GetHost(aHost);
+        aHost.ReplaceChar('.','_');
+        prefName = nsDependentCString("ldap_2.servers.") + aHost;
+        PRBool useSSL=0;
+        rv = prefs->GetBoolPref(
+                PromiseFlatCString(prefName
+                + NS_LITERAL_CSTRING(".UseSSL")).get(),
+                &useSSL
+            );
+        
+        // If use SSL,ldap url will look like this ldaps://host:port/.....
+        if (!NS_FAILED(rv) && useSSL)
+        {
+            tempLDAPURL.ReplaceSubstring("ldap:", "ldaps:"); 
+            rv = mURL->SetSpec(tempLDAPURL);
+        }
+        //NS_FAILED(rv) means ldap_2.servers.nscpphonebook.UseSSL not exist
+        rv = 0;
     }
     else
     {
@@ -156,24 +179,29 @@
     // get the login information, if there is any 
     //
     rv = prefs->GetCharPref(
-        PromiseFlatCString(
-            Substring(mURINoQuery, kLDAPDirectoryRootLen,
-                      mURINoQuery.Length() - kLDAPDirectoryRootLen)
+        PromiseFlatCString(prefName
             + NS_LITERAL_CSTRING(".auth.dn")).get(),
         getter_Copies(mLogin));
     if (NS_FAILED(rv)) {
         mLogin.Truncate();  // zero out mLogin
     }
 
+    // get the password information, if there is any 
+    //
+    rv = prefs->GetCharPref(
+        PromiseFlatCString(prefName
+            + NS_LITERAL_CSTRING(".auth.pwd")).get(),
+        getter_Copies(mPassword));
+    if (NS_FAILED(rv)) {
+        mPassword.Truncate();  // zero out mLogin
+    }
     // get the protocol version, if there is any.  using a string pref
     // here instead of an int, as protocol versions sometimes have names like
     // "4bis".
     //
     nsXPIDLCString protocolVersion;
     rv = prefs->GetCharPref(
-        PromiseFlatCString(
-            Substring(mURINoQuery, kLDAPDirectoryRootLen,
-                      mURINoQuery.Length() - kLDAPDirectoryRootLen)
+        PromiseFlatCString(prefName
             + NS_LITERAL_CSTRING(".protocolVersion")).get(),
         getter_Copies(protocolVersion));
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2004-02-13 21:09:27.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2005-01-09 13:23:33.187500000 -0500
@@ -74,7 +74,7 @@
         PRInt32 resultLimit = -1,
         PRInt32 timeOut = 0);
     virtual ~nsAbQueryLDAPMessageListener ();
-
+    void SetPassword(const nsAString& aPassword){m_sPassword = aPassword;};
 protected:
     nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
     nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
@@ -105,6 +105,8 @@
     PRBool mInitialized;
     PRBool mCanceled;
 
+    nsAutoString m_sPassword;
+
     nsCOMPtr<nsILDAPOperation> mSearchOperation;
 
     PRLock* mLock;
@@ -255,7 +257,7 @@
 
     // If mLogin is set, we're expected to use it to get a password.
     //
-    if (!mDirectoryQuery->mLogin.IsEmpty()) {
+    if (!mDirectoryQuery->mLogin.IsEmpty() && !m_sPassword.Length()) {
 // XXX hack until nsUTF8AutoString exists
 #define nsUTF8AutoString nsCAutoString
         nsUTF8AutoString spec;
@@ -398,10 +400,13 @@
     rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // Bind
-    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
+	
+	// Bind
+    if (m_sPassword.Length())
+		rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(m_sPassword));
+	else
+	    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
     NS_ENSURE_SUCCESS(rv, rv);
-
     return rv;
 }
 
@@ -685,7 +690,7 @@
     rv = getLdapReturnAttributes (arguments, returnAttributes);
     NS_ENSURE_SUCCESS(rv, rv);
 
-
+    
     // Get the filter
     nsCOMPtr<nsISupports> supportsExpression;
     rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
@@ -811,6 +816,11 @@
                 timeOut);
     if (_messageListener == NULL)
             return NS_ERROR_OUT_OF_MEMORY;
+    
+    nsAutoString wPassword;
+    wPassword.AssignWithConversion(mPassword.get());
+    _messageListener->SetPassword(wPassword);
+
     messageListener = _messageListener;
     nsVoidKey key (NS_REINTERPRET_CAST(void *,contextID));
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2004-02-13 21:09:27.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2005-01-09 13:23:33.203125000 -0500
@@ -74,6 +74,7 @@
     nsresult RemoveListener (PRInt32 contextID);
     nsresult Initiate ();
     nsXPIDLCString mLogin; // authenticate to the LDAP server as...
+    nsXPIDLCString mPassword; // password to the LDAP server as...
     nsCOMPtr<nsILDAPURL> mDirectoryUrl; // the URL for the server
     PRUint32 mProtocolVersion; // version of LDAP (see nsILDAPConnection.idl)
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	2003-03-22 10:43:29.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	2005-01-09 13:23:33.218750000 -0500
@@ -39,6 +39,7 @@
 #include "nsAbLDAPProperties.h"
 
 #include "nsAbUtils.h"
+#include "nsCRT.h"
 
 #include "nsCOMPtr.h"
 #include "nsString.h"
@@ -59,6 +60,21 @@
     If there are multiple entries for a mozilla
     property the first takes precedence.
 
+    But where we need to do a query against 
+    a multiple occurring ldap attribute we 
+    need to OR all the possible ldap entries e.g.
+
+    (CellularNumber=123456) translates to 
+    (|(mobile=123456)(&(!(mobile=*))(cellphone=123456))(&(!(mobile=*))(!(cellphone=*))(carphone=123456)))
+
+    i.e. use the first occurring attribute otherwise if 
+    first does not exist use the second etc.
+
+    [Multiple occurring ldap attributes do not
+    include aliases. We have also ignored the case 
+    for including 'displayname' as the first occurring
+    attribute 'cn' is a required attribute.] 
+
     This ensures that
     
         1) Generality is maintained when mapping from
@@ -101,52 +117,32 @@
     {MozillaProperty_String, "FaxNumber",        "fax"},
     // organizationalPerson
     {MozillaProperty_String, "FaxNumber",        "facsimiletelephonenumber"},
-    // inetOrgPerson
-    {MozillaProperty_String, "PagerNumber",        "pager"},
-    // ?
-    {MozillaProperty_String, "PagerNumber",        "pagerphone"},
-    // inetOrgPerson
-    {MozillaProperty_String, "CellularNumber",    "mobile"},
-    // ?
-    {MozillaProperty_String, "CellularNumber",    "cellphone"},
-    // ?
-    {MozillaProperty_String, "CellularNumber",    "carphone"},
+    // inetOrgPerson,?
+    {MozillaProperty_String, "PagerNumber",        "pager,pagerphone"},
+    // inetOrgPerson,?,?
+    {MozillaProperty_String, "CellularNumber",    "mobile,cellphone,carphone"},
 
     // No Home* properties defined yet
 
-    // organizationalPerson
-    {MozillaProperty_String, "WorkAddress",        "postofficebox"},
-    // ?
-    {MozillaProperty_String, "WorkAddress",        "streetaddress"},
+    // organizationalPerson,?
+    {MozillaProperty_String, "WorkAddress",        "postofficebox,streetaddress"},
     // ?
     {MozillaProperty_String, "WorkCity",        "l"},
     // ?
     {MozillaProperty_String, "WorkCity",        "locality"},
     // ?
-    {MozillaProperty_String, "WorkState",        "st"},
-    // ?
-    {MozillaProperty_String, "WorkState",        "region"},
-    // organizationalPerson
-    {MozillaProperty_String, "WorkZipCode",        "postalcode"},
-    // ?
-    {MozillaProperty_String, "WorkZipCode",        "zip"},
+    {MozillaProperty_String, "WorkState",        "st,region"},
+    // organizationalPerson,?
+    {MozillaProperty_String, "WorkZipCode",        "postalcode,zip"},
     // ?
     {MozillaProperty_String, "WorkCountry",        "countryname"},
 
     // organizationalPerson
     {MozillaProperty_String, "JobTitle",        "title"},
     // ?
-    {MozillaProperty_String, "Department",        "ou"},
-    // ?
-    {MozillaProperty_String, "Department",        "orgunit"},
-    // ?
-    {MozillaProperty_String, "Department",        "department"},
-    // ?
-    {MozillaProperty_String, "Department",        "departmentnumber"},
-    // inetOrgPerson
-    {MozillaProperty_String, "Company",        "o"},
-    // ?
-    {MozillaProperty_String, "Company",        "company"},
+    {MozillaProperty_String, "Department",      "ou,orgunit,department,departmentnumber"},
+   // inetOrgPerson,?
+    {MozillaProperty_String, "Company",        "o,company"},
     // ?
     {MozillaProperty_String, "WorkCountry",        "countryname"},
     // ?
@@ -168,10 +164,8 @@
     // ?
     {MozillaProperty_String, "Custom4",        "custom4"},
 
-    // ?
-    {MozillaProperty_String, "Notes",        "notes"},
-    // person
-    {MozillaProperty_String, "Notes",        "description"},
+    // ?,person
+    {MozillaProperty_String, "Notes",        "notes,description"},
 
     // mozilla specfic
     {MozillaProperty_Int, "PreferMailFormat",    "xmozillausehtmlmail"},
@@ -209,10 +203,22 @@
     if (IsInitialized) { return ; }
 
     for (int i = tableSize - 1 ; i >= 0 ; -- i) {
-        nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
-        nsCStringKey keyLdap (table [i].ldapProperty, -1, nsCStringKey::NEVER_OWN);
 
+        char *attrToken = nsnull;
+        char *LDAPProperty = nsCRT::strdup(table[i].ldapProperty);
+        char *tmpLDAPProperty;
+
+        attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+        while (attrToken != nsnull)
+        {
+            while ( ' ' == *attrToken) 
+                attrToken++;
+            nsCStringKey keyLdap (attrToken, -1, nsCStringKey::NEVER_OWN);
         mLdapToMozilla.Put(&keyLdap, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
+            attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+        }
+
+        nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
         mMozillaToLdap.Put(&keyMozilla, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
     }
     IsInitialized = PR_TRUE;
@@ -234,10 +240,13 @@
 const MozillaLdapPropertyRelation* MozillaLdapPropertyRelator::findMozillaPropertyFromLdap (const char* ldapProperty)
 {
     Initialize();
+    char *attrToken;
+    char *tmpLDAPProperty;
+    attrToken = nsCRT::strtok(NS_CONST_CAST(char *,ldapProperty), ",", &tmpLDAPProperty);
     // ensure that we always do a case insensitive comparison
     // against the incoming ldap attributes.
-    nsCAutoString lowercasedProp(ldapProperty);
-    ToLowerCase(nsDependentCString(ldapProperty), lowercasedProp);
+    nsCAutoString lowercasedProp (attrToken) ;
+    ToLowerCase(nsDependentCString(attrToken),lowercasedProp);
     nsCStringKey key(lowercasedProp);
 
     return NS_REINTERPRET_CAST(const MozillaLdapPropertyRelation *, mLdapToMozilla.Get(&key)) ;
@@ -289,3 +298,64 @@
 
     return rv;
 }
+
+// Parse the input string which may contain a single ldap attribute or multiple attributes in the form
+// "string" or "string1,string2,string3" respectively and assign to the array.
+nsresult MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes)
+{
+    NS_ENSURE_ARG_POINTER(aAttrCount);
+    NS_ENSURE_ARG_POINTER(aAttributes);
+
+    nsresult rv = NS_OK;
+
+    *aAttributes = 0;
+    // we must have at least one attribute 
+    *aAttrCount = 1;
+
+    // if no multiple ldap attributes then allocate our single entry and exit
+    if (!strchr(aLDAPProperty,','))
+    {
+        if (!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(sizeof(char *)))))
+            return NS_ERROR_OUT_OF_MEMORY;
+        if (!((*aAttributes)[0] = nsCRT::strdup(aLDAPProperty)))
+            return NS_ERROR_OUT_OF_MEMORY;
+
+        return rv;
+    }
+
+    char *attrToken = nsnull;
+    char *LDAPProperty = nsnull;
+    char *tmpLDAPProperty;
+
+    if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    // set our tokenizer to the start 
+    attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty); 
+
+    // Count up the attribute names 
+    while ((attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty)) != nsnull)
+        *aAttrCount += 1;
+
+    nsCRT::free (LDAPProperty);
+    if(!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(*aAttrCount * sizeof(char *)))))
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRInt32 j = 0;
+    attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+    while (nsnull != attrToken) {
+        if(((*aAttributes)[j++] = nsCRT::strdup(attrToken)) == nsnull)
+        {
+            nsCRT::free(LDAPProperty);
+            return NS_ERROR_OUT_OF_MEMORY;
+        }
+		
+        attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+    }
+
+    nsCRT::free(LDAPProperty);
+    return rv;
+}
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h
--- misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	2002-04-09 05:27:24.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	2005-01-09 13:23:33.234375000 -0500
@@ -85,6 +85,7 @@
     static nsresult createCardPropertyFromLDAPMessage (nsILDAPMessage* message,
             nsIAbCard* card,
             PRBool* hasSetCardProperty);
+    static nsresult getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes);
 };
 
 #endif
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2005-01-09 17:07:22.906250000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2005-01-09 13:23:33.250000000 -0500
@@ -1 +1,633 @@
-dummy
+/*
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ * 
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is the Netscape security libraries.
+ * 
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.	Portions created by Netscape are 
+ * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
+ * Rights Reserved.
+ * 
+ * Contributor(s):
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 or later (the
+ * "GPL"), in which case the provisions of the GPL are applicable 
+ * instead of those above.	If you wish to allow use of your 
+ * version of this file only under the terms of the GPL and not to
+ * allow others to use your version of this file under the MPL,
+ * indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by
+ * the GPL.  If you do not delete the provisions above, a recipient
+ * may use your version of this file under either the MPL or the
+ * GPL.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "prerr.h"
+
+#include "prtypes.h"
+#include "prlong.h"
+#include "plstr.h"
+#include "nsMemory.h"
+
+#define MD5_HASH_LEN 16
+#define MD5_BUFFER_SIZE 64
+#define MD5_END_BUFFER (MD5_BUFFER_SIZE - 8)
+
+#define CV0_1 0x67452301
+#define CV0_2 0xefcdab89
+#define CV0_3 0x98badcfe
+#define CV0_4 0x10325476
+
+#define T1_0  0xd76aa478
+#define T1_1  0xe8c7b756
+#define T1_2  0x242070db
+#define T1_3  0xc1bdceee
+#define T1_4  0xf57c0faf
+#define T1_5  0x4787c62a
+#define T1_6  0xa8304613
+#define T1_7  0xfd469501
+#define T1_8  0x698098d8
+#define T1_9  0x8b44f7af
+#define T1_10 0xffff5bb1
+#define T1_11 0x895cd7be
+#define T1_12 0x6b901122
+#define T1_13 0xfd987193
+#define T1_14 0xa679438e
+#define T1_15 0x49b40821
+
+#define T2_0  0xf61e2562
+#define T2_1  0xc040b340
+#define T2_2  0x265e5a51
+#define T2_3  0xe9b6c7aa
+#define T2_4  0xd62f105d
+#define T2_5  0x02441453
+#define T2_6  0xd8a1e681
+#define T2_7  0xe7d3fbc8
+#define T2_8  0x21e1cde6
+#define T2_9  0xc33707d6
+#define T2_10 0xf4d50d87
+#define T2_11 0x455a14ed
+#define T2_12 0xa9e3e905
+#define T2_13 0xfcefa3f8
+#define T2_14 0x676f02d9
+#define T2_15 0x8d2a4c8a
+
+#define T3_0  0xfffa3942
+#define T3_1  0x8771f681
+#define T3_2  0x6d9d6122
+#define T3_3  0xfde5380c
+#define T3_4  0xa4beea44
+#define T3_5  0x4bdecfa9
+#define T3_6  0xf6bb4b60
+#define T3_7  0xbebfbc70
+#define T3_8  0x289b7ec6
+#define T3_9  0xeaa127fa
+#define T3_10 0xd4ef3085
+#define T3_11 0x04881d05
+#define T3_12 0xd9d4d039
+#define T3_13 0xe6db99e5
+#define T3_14 0x1fa27cf8
+#define T3_15 0xc4ac5665
+
+#define T4_0  0xf4292244
+#define T4_1  0x432aff97
+#define T4_2  0xab9423a7
+#define T4_3  0xfc93a039
+#define T4_4  0x655b59c3
+#define T4_5  0x8f0ccc92
+#define T4_6  0xffeff47d
+#define T4_7  0x85845dd1
+#define T4_8  0x6fa87e4f
+#define T4_9  0xfe2ce6e0
+#define T4_10 0xa3014314
+#define T4_11 0x4e0811a1
+#define T4_12 0xf7537e82
+#define T4_13 0xbd3af235
+#define T4_14 0x2ad7d2bb
+#define T4_15 0xeb86d391
+
+#define R1B0  0
+#define R1B1  1
+#define R1B2  2
+#define R1B3  3
+#define R1B4  4
+#define R1B5  5
+#define R1B6  6
+#define R1B7  7
+#define R1B8  8
+#define R1B9  9
+#define R1B10 10
+#define R1B11 11
+#define R1B12 12
+#define R1B13 13
+#define R1B14 14
+#define R1B15 15
+
+#define R2B0  1
+#define R2B1  6
+#define R2B2  11
+#define R2B3  0
+#define R2B4  5
+#define R2B5  10
+#define R2B6  15
+#define R2B7  4
+#define R2B8  9
+#define R2B9  14
+#define R2B10 3 
+#define R2B11 8 
+#define R2B12 13
+#define R2B13 2 
+#define R2B14 7 
+#define R2B15 12
+
+#define R3B0  5
+#define R3B1  8
+#define R3B2  11
+#define R3B3  14
+#define R3B4  1
+#define R3B5  4
+#define R3B6  7
+#define R3B7  10
+#define R3B8  13
+#define R3B9  0
+#define R3B10 3 
+#define R3B11 6 
+#define R3B12 9 
+#define R3B13 12
+#define R3B14 15
+#define R3B15 2 
+
+#define R4B0  0
+#define R4B1  7
+#define R4B2  14
+#define R4B3  5
+#define R4B4  12
+#define R4B5  3
+#define R4B6  10
+#define R4B7  1
+#define R4B8  8
+#define R4B9  15
+#define R4B10 6 
+#define R4B11 13
+#define R4B12 4 
+#define R4B13 11
+#define R4B14 2 
+#define R4B15 9 
+
+#define S1_0 7
+#define S1_1 12
+#define S1_2 17
+#define S1_3 22
+
+#define S2_0 5
+#define S2_1 9
+#define S2_2 14
+#define S2_3 20
+
+#define S3_0 4
+#define S3_1 11
+#define S3_2 16
+#define S3_3 23
+
+#define S4_0 6
+#define S4_1 10
+#define S4_2 15
+#define S4_3 21
+
+struct MD5ContextStr {
+	PRUint32      lsbInput;
+	PRUint32      msbInput;
+	PRUint32      cv[4];
+	union {
+		PRUint8 b[64];
+		PRUint32 w[16];
+	} u;
+};
+typedef struct MD5ContextStr        MD5Context;
+
+#define inBuf u.b
+
+int MD5_Hash(unsigned char *dest, const char *src);
+int MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length);
+MD5Context * MD5_NewContext(void);
+void MD5_DestroyContext(MD5Context *cx, PRBool freeit);
+void MD5_Begin(MD5Context *cx);
+static void md5_compress(MD5Context *cx);
+void MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen);
+void MD5_End(MD5Context *cx, unsigned char *digest,
+        unsigned int *digestLen, unsigned int maxDigestLen);
+unsigned int MD5_FlattenSize(MD5Context *cx);
+int MD5_Flatten(MD5Context *cx, unsigned char *space);
+MD5Context * MD5_Resurrect(unsigned char *space, void *arg);
+void MD5_TraceState(MD5Context *cx);
+
+int 
+MD5_Hash(unsigned char *dest, const char *src)
+{
+	return MD5_HashBuf(dest, (unsigned char *)src, PL_strlen(src));
+}
+
+int 
+MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length)
+{
+	unsigned int len;
+	MD5Context *cx = MD5_NewContext();
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return -1;
+	}
+	MD5_Begin(cx);
+	MD5_Update(cx, src, src_length);
+	MD5_End(cx, dest, &len, MD5_HASH_LEN);
+	MD5_DestroyContext(cx, PR_TRUE);
+	return 0;
+}
+
+MD5Context *
+MD5_NewContext(void)
+{
+	MD5Context *cx = (MD5Context *)malloc(sizeof(MD5Context));
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return NULL;
+	}
+	return cx;
+}
+
+void 
+MD5_DestroyContext(MD5Context *cx, PRBool freeit)
+{
+	if (freeit) {
+		free(cx);
+	}
+}
+
+void 
+MD5_Begin(MD5Context *cx)
+{
+	cx->lsbInput = 0;
+	cx->msbInput = 0;
+	memset(cx->inBuf, 0, sizeof(cx->inBuf));
+	cx->cv[0] = CV0_1;
+	cx->cv[1] = CV0_2;
+	cx->cv[2] = CV0_3;
+	cx->cv[3] = CV0_4;
+}
+
+#define cls(i32, s) (tmp = i32, tmp << s | tmp >> (32 - s))
+
+#define MASK 0x00ff00ff
+#ifdef IS_LITTLE_ENDIAN
+#define lendian(i32) \
+	(i32)
+#else
+#define lendian(i32) \
+	(tmp = i32 >> 16 | i32 << 16, (tmp & MASK) << 8 | tmp >> 8 & MASK)
+#endif
+
+#if defined(SOLARIS) || defined(HPUX)
+#define addto64(sumhigh, sumlow, addend) \
+	sumlow += addend; sumhigh += (sumlow < addend);
+#else
+#define addto64(sumhigh, sumlow, addend) \
+	sumlow += addend; if (sumlow < addend) ++sumhigh;
+#endif
+
+#define F(X, Y, Z) \
+	((X & Y) | ((~X) & Z))
+
+#define G(X, Y, Z) \
+	((X & Z) | (Y & (~Z)))
+
+#define H(X, Y, Z) \
+	(X ^ Y ^ Z)
+
+#define I(X, Y, Z) \
+	(Y ^ (X | (~Z)))
+
+#define FF(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + F(b, c, d) + bufint + ti, s)
+
+#define GG(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + G(b, c, d) + bufint + ti, s)
+
+#define HH(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + H(b, c, d) + bufint + ti, s)
+
+#define II(a, b, c, d, bufint, s, ti) \
+	a = b + cls(a + I(b, c, d) + bufint + ti, s)
+
+static void
+md5_compress(MD5Context *cx)
+{
+	PRUint32 a, b, c, d;
+	PRUint32 tmp;
+	a = cx->cv[0];
+	b = cx->cv[1];
+	c = cx->cv[2];
+	d = cx->cv[3];
+#ifndef IS_LITTLE_ENDIAN
+	cx->u.w[0] = lendian(cx->u.w[0]);
+	cx->u.w[1] = lendian(cx->u.w[1]);
+	cx->u.w[2] = lendian(cx->u.w[2]);
+	cx->u.w[3] = lendian(cx->u.w[3]);
+	cx->u.w[4] = lendian(cx->u.w[4]);
+	cx->u.w[5] = lendian(cx->u.w[5]);
+	cx->u.w[6] = lendian(cx->u.w[6]);
+	cx->u.w[7] = lendian(cx->u.w[7]);
+	cx->u.w[8] = lendian(cx->u.w[8]);
+	cx->u.w[9] = lendian(cx->u.w[9]);
+	cx->u.w[10] = lendian(cx->u.w[10]);
+	cx->u.w[11] = lendian(cx->u.w[11]);
+	cx->u.w[12] = lendian(cx->u.w[12]);
+	cx->u.w[13] = lendian(cx->u.w[13]);
+	cx->u.w[14] = lendian(cx->u.w[14]);
+	cx->u.w[15] = lendian(cx->u.w[15]);
+#endif
+	FF(a, b, c, d, cx->u.w[R1B0 ], S1_0, T1_0);
+	FF(d, a, b, c, cx->u.w[R1B1 ], S1_1, T1_1);
+	FF(c, d, a, b, cx->u.w[R1B2 ], S1_2, T1_2);
+	FF(b, c, d, a, cx->u.w[R1B3 ], S1_3, T1_3);
+	FF(a, b, c, d, cx->u.w[R1B4 ], S1_0, T1_4);
+	FF(d, a, b, c, cx->u.w[R1B5 ], S1_1, T1_5);
+	FF(c, d, a, b, cx->u.w[R1B6 ], S1_2, T1_6);
+	FF(b, c, d, a, cx->u.w[R1B7 ], S1_3, T1_7);
+	FF(a, b, c, d, cx->u.w[R1B8 ], S1_0, T1_8);
+	FF(d, a, b, c, cx->u.w[R1B9 ], S1_1, T1_9);
+	FF(c, d, a, b, cx->u.w[R1B10], S1_2, T1_10);
+	FF(b, c, d, a, cx->u.w[R1B11], S1_3, T1_11);
+	FF(a, b, c, d, cx->u.w[R1B12], S1_0, T1_12);
+	FF(d, a, b, c, cx->u.w[R1B13], S1_1, T1_13);
+	FF(c, d, a, b, cx->u.w[R1B14], S1_2, T1_14);
+	FF(b, c, d, a, cx->u.w[R1B15], S1_3, T1_15);
+	GG(a, b, c, d, cx->u.w[R2B0 ], S2_0, T2_0);
+	GG(d, a, b, c, cx->u.w[R2B1 ], S2_1, T2_1);
+	GG(c, d, a, b, cx->u.w[R2B2 ], S2_2, T2_2);
+	GG(b, c, d, a, cx->u.w[R2B3 ], S2_3, T2_3);
+	GG(a, b, c, d, cx->u.w[R2B4 ], S2_0, T2_4);
+	GG(d, a, b, c, cx->u.w[R2B5 ], S2_1, T2_5);
+	GG(c, d, a, b, cx->u.w[R2B6 ], S2_2, T2_6);
+	GG(b, c, d, a, cx->u.w[R2B7 ], S2_3, T2_7);
+	GG(a, b, c, d, cx->u.w[R2B8 ], S2_0, T2_8);
+	GG(d, a, b, c, cx->u.w[R2B9 ], S2_1, T2_9);
+	GG(c, d, a, b, cx->u.w[R2B10], S2_2, T2_10);
+	GG(b, c, d, a, cx->u.w[R2B11], S2_3, T2_11);
+	GG(a, b, c, d, cx->u.w[R2B12], S2_0, T2_12);
+	GG(d, a, b, c, cx->u.w[R2B13], S2_1, T2_13);
+	GG(c, d, a, b, cx->u.w[R2B14], S2_2, T2_14);
+	GG(b, c, d, a, cx->u.w[R2B15], S2_3, T2_15);
+	HH(a, b, c, d, cx->u.w[R3B0 ], S3_0, T3_0);
+	HH(d, a, b, c, cx->u.w[R3B1 ], S3_1, T3_1);
+	HH(c, d, a, b, cx->u.w[R3B2 ], S3_2, T3_2);
+	HH(b, c, d, a, cx->u.w[R3B3 ], S3_3, T3_3);
+	HH(a, b, c, d, cx->u.w[R3B4 ], S3_0, T3_4);
+	HH(d, a, b, c, cx->u.w[R3B5 ], S3_1, T3_5);
+	HH(c, d, a, b, cx->u.w[R3B6 ], S3_2, T3_6);
+	HH(b, c, d, a, cx->u.w[R3B7 ], S3_3, T3_7);
+	HH(a, b, c, d, cx->u.w[R3B8 ], S3_0, T3_8);
+	HH(d, a, b, c, cx->u.w[R3B9 ], S3_1, T3_9);
+	HH(c, d, a, b, cx->u.w[R3B10], S3_2, T3_10);
+	HH(b, c, d, a, cx->u.w[R3B11], S3_3, T3_11);
+	HH(a, b, c, d, cx->u.w[R3B12], S3_0, T3_12);
+	HH(d, a, b, c, cx->u.w[R3B13], S3_1, T3_13);
+	HH(c, d, a, b, cx->u.w[R3B14], S3_2, T3_14);
+	HH(b, c, d, a, cx->u.w[R3B15], S3_3, T3_15);
+	II(a, b, c, d, cx->u.w[R4B0 ], S4_0, T4_0);
+	II(d, a, b, c, cx->u.w[R4B1 ], S4_1, T4_1);
+	II(c, d, a, b, cx->u.w[R4B2 ], S4_2, T4_2);
+	II(b, c, d, a, cx->u.w[R4B3 ], S4_3, T4_3);
+	II(a, b, c, d, cx->u.w[R4B4 ], S4_0, T4_4);
+	II(d, a, b, c, cx->u.w[R4B5 ], S4_1, T4_5);
+	II(c, d, a, b, cx->u.w[R4B6 ], S4_2, T4_6);
+	II(b, c, d, a, cx->u.w[R4B7 ], S4_3, T4_7);
+	II(a, b, c, d, cx->u.w[R4B8 ], S4_0, T4_8);
+	II(d, a, b, c, cx->u.w[R4B9 ], S4_1, T4_9);
+	II(c, d, a, b, cx->u.w[R4B10], S4_2, T4_10);
+	II(b, c, d, a, cx->u.w[R4B11], S4_3, T4_11);
+	II(a, b, c, d, cx->u.w[R4B12], S4_0, T4_12);
+	II(d, a, b, c, cx->u.w[R4B13], S4_1, T4_13);
+	II(c, d, a, b, cx->u.w[R4B14], S4_2, T4_14);
+	II(b, c, d, a, cx->u.w[R4B15], S4_3, T4_15);
+	cx->cv[0] += a;
+	cx->cv[1] += b;
+	cx->cv[2] += c;
+	cx->cv[3] += d;
+}
+
+void 
+MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen)
+{
+	PRUint32 bytesToConsume;
+	PRUint32 inBufIndex = cx->lsbInput & 63;
+
+	/* Add the number of input bytes to the 64-bit input counter. */
+	addto64(cx->msbInput, cx->lsbInput, inputLen);
+	if (inBufIndex) {
+		/* There is already data in the buffer.  Fill with input. */
+		bytesToConsume = PR_MIN(inputLen, MD5_BUFFER_SIZE - inBufIndex);
+		memcpy(&cx->inBuf[inBufIndex], input, bytesToConsume);
+		if (inBufIndex + bytesToConsume >= MD5_BUFFER_SIZE)
+			/* The buffer is filled.  Run the compression function. */
+			md5_compress(cx);
+		/* Remaining input. */
+		inputLen -= bytesToConsume;
+		input += bytesToConsume;
+	}
+
+	/* Iterate over 64-byte chunks of the message. */
+	while (inputLen >= MD5_BUFFER_SIZE) {
+		memcpy(cx->inBuf, input, MD5_BUFFER_SIZE);
+		md5_compress(cx);
+		inputLen -= MD5_BUFFER_SIZE;
+		input += MD5_BUFFER_SIZE;
+	}
+
+	/* Tail of message (message bytes mod 64). */
+	if (inputLen)
+		memcpy(cx->inBuf, input, inputLen);
+}
+
+static const unsigned char padbytes[] = {
+	0x80, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00
+};
+
+void 
+MD5_End(MD5Context *cx, unsigned char *digest,
+        unsigned int *digestLen, unsigned int maxDigestLen)
+{
+#ifndef IS_LITTLE_ENDIAN
+	PRUint32 tmp;
+#endif
+	PRUint32 lowInput, highInput;
+	PRUint32 inBufIndex = cx->lsbInput & 63;
+
+	if (maxDigestLen < MD5_HASH_LEN) {
+//		PORT_SetError(SEC_ERROR_INVALID_ARGS);
+		return;
+	}
+
+	/* Copy out the length of bits input before padding. */
+	lowInput = cx->lsbInput; 
+	highInput = (cx->msbInput << 3) | (lowInput >> 29);
+	lowInput <<= 3;
+
+	if (inBufIndex < MD5_END_BUFFER) {
+		MD5_Update(cx, padbytes, MD5_END_BUFFER - inBufIndex);
+	} else {
+		MD5_Update(cx, padbytes, 
+		           MD5_END_BUFFER + MD5_BUFFER_SIZE - inBufIndex);
+	}
+
+	/* Store the number of bytes input (before padding) in final 64 bits. */
+	cx->u.w[14] = lendian(lowInput);
+	cx->u.w[15] = lendian(highInput);
+
+	/* Final call to compress. */
+	md5_compress(cx);
+
+	/* Copy the resulting values out of the chain variables into return buf. */
+	*digestLen = MD5_HASH_LEN;
+#ifndef IS_LITTLE_ENDIAN
+	cx->cv[0] = lendian(cx->cv[0]);
+	cx->cv[1] = lendian(cx->cv[1]);
+	cx->cv[2] = lendian(cx->cv[2]);
+	cx->cv[3] = lendian(cx->cv[3]);
+#endif
+	memcpy(digest, cx->cv, MD5_HASH_LEN);
+}
+
+unsigned int 
+MD5_FlattenSize(MD5Context *cx)
+{
+	return sizeof(*cx);
+}
+
+int 
+MD5_Flatten(MD5Context *cx, unsigned char *space)
+{
+	memcpy(space, cx, sizeof(*cx));
+	return 0;
+}
+
+MD5Context * 
+MD5_Resurrect(unsigned char *space, void *arg)
+{
+	MD5Context *cx = MD5_NewContext();
+	if (cx)
+		memcpy(cx, space, sizeof(*cx));
+	return cx;
+}
+
+void 
+MD5_TraceState(MD5Context *cx)
+{
+//	PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
+}
+
+int
+md5_stream (FILE *stream, unsigned char *dest)
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+	unsigned int len;
+	MD5Context *cx = MD5_NewContext();
+	if (cx == NULL) {
+//		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
+		return -1;
+	}
+
+  unsigned char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  MD5_Begin(cx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      do
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+	}
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+	break;
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+	MD5_Update(cx, buffer, BLOCKSIZE);
+    }
+
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+	MD5_Update(cx, buffer, sum);
+
+	MD5_End(cx, dest, &len, MD5_HASH_LEN);
+	MD5_DestroyContext(cx, PR_TRUE);
+	return len;
+
+}
+
+int getMD5sum(const char * fileName,char * sum)
+{
+	unsigned char bin_sum[16];
+	int len=0;
+	if (fileName)
+	{
+		FILE *fp=fopen(fileName,"rb");
+		if (fp)
+		{
+			len=md5_stream(fp,bin_sum);
+			memset(sum,0,33);
+			for (int i = 0; i < len; ++i)
+				sprintf (sum,"%s%02x",sum, bin_sum[i]);
+			fclose(fp);
+			return 0;
+		}
+	}
+	return 1;
+}
+
+int testMD5sum(const char * fileName,char * sum)
+{
+	char newSum[33]="";
+	if (getMD5sum(fileName,newSum))
+		return 1;
+	return strcmp(newSum,sum);
+}
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2002-11-12 14:19:56.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2005-01-09 13:23:33.265625000 -0500
@@ -266,8 +266,7 @@
 	if (mCardDatabase)
 	{
 		mCardDatabase->EditCard(this, PR_TRUE);
-    mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
-		return NS_OK;
+		return mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
 	}
 	else
 		return NS_ERROR_FAILURE;
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2004-03-09 09:42:24.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2005-01-09 13:23:33.281250000 -0500
@@ -537,7 +537,7 @@
         }
       }
     }
-    mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
+    rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
   }
   return rv;
 }
@@ -684,6 +684,7 @@
     return NS_ERROR_NOT_IMPLEMENTED;
 
   nsresult rv = NS_OK;
+
   if (!mDatabase)
     rv = GetAbDatabase();
 
@@ -713,10 +714,11 @@
     mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE);
   else
     mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
-  mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
+  rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
 
+  NS_ENSURE_SUCCESS(rv, rv);
   NS_IF_ADDREF(*addedCard = newCard);
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2004-03-09 10:18:40.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2005-01-09 13:23:33.296875000 -0500
@@ -97,6 +97,7 @@
 {
     index_DisplayName = 0,
     index_EmailAddress,
+    index_SecondEmailAddress,
     index_FirstName,
     index_LastName,
     index_NickName,
@@ -124,32 +125,34 @@
 
 static const ULONG OutlookCardMAPIProps [] = 
 {
-    PR_DISPLAY_NAME_W,
-    PR_EMAIL_ADDRESS_W,
-    PR_GIVEN_NAME_W,
-    PR_SURNAME_W,
-    PR_NICKNAME_W,
-    PR_BUSINESS_TELEPHONE_NUMBER_W,
-    PR_HOME_TELEPHONE_NUMBER_W,
-    PR_BUSINESS_FAX_NUMBER_W,
-    PR_PAGER_TELEPHONE_NUMBER_W,
-    PR_MOBILE_TELEPHONE_NUMBER_W,
-    PR_HOME_ADDRESS_CITY_W,
-    PR_HOME_ADDRESS_STATE_OR_PROVINCE_W,
-    PR_HOME_ADDRESS_POSTAL_CODE_W,
-    PR_HOME_ADDRESS_COUNTRY_W,
-    PR_BUSINESS_ADDRESS_CITY_W,
-    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W,
-    PR_BUSINESS_ADDRESS_POSTAL_CODE_W,
-    PR_BUSINESS_ADDRESS_COUNTRY_W,
-    PR_TITLE_W,
-    PR_DEPARTMENT_NAME_W,
-    PR_COMPANY_NAME_W,
-    PR_BUSINESS_HOME_PAGE_W,
-    PR_PERSONAL_HOME_PAGE_W,
-    PR_COMMENT_W
+    PR_DISPLAY_NAME_A,//0x8035001E
+    PR_EMAIL_ADDRESS_A,//0x8034001E
+    PR_SECOND_EMAIL_ADDRESS_A,//Second Email Address
+    PR_GIVEN_NAME_A,
+    PR_SURNAME_A,
+    PR_NICKNAME_A,
+    PR_BUSINESS_TELEPHONE_NUMBER_A,
+    PR_HOME_TELEPHONE_NUMBER_A,
+    PR_BUSINESS_FAX_NUMBER_A,
+    PR_PAGER_TELEPHONE_NUMBER_A,
+    PR_MOBILE_TELEPHONE_NUMBER_A,
+    PR_HOME_ADDRESS_CITY_A,
+    PR_HOME_ADDRESS_STATE_OR_PROVINCE_A,
+    PR_HOME_ADDRESS_POSTAL_CODE_A,
+    PR_HOME_ADDRESS_COUNTRY_A,
+    PR_BUSINESS_ADDRESS_CITY_A,
+    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A,
+    PR_BUSINESS_ADDRESS_POSTAL_CODE_A,
+    PR_BUSINESS_ADDRESS_COUNTRY_A,
+    PR_TITLE_A,
+    PR_DEPARTMENT_NAME_A,
+    PR_COMPANY_NAME_A,
+    PR_BUSINESS_HOME_PAGE_A,
+    PR_PERSONAL_HOME_PAGE_A,
+    PR_COMMENT_A
 } ;
 
+
 nsresult nsAbOutlookCard::Init(const char *aUri)
 {
     nsresult retCode = nsRDFResource::Init(aUri) ;
@@ -176,6 +179,7 @@
         SetDisplayName(unichars [index_DisplayName]->get()) ;
         SetNickName(unichars [index_NickName]->get()) ;
         SetPrimaryEmail(unichars [index_EmailAddress]->get()) ;
+        SetSecondEmail(unichars [index_SecondEmailAddress]->get()) ;
         SetWorkPhone(unichars [index_WorkPhoneNumber]->get()) ;
         SetHomePhone(unichars [index_HomePhoneNumber]->get()) ;
         SetFaxNumber(unichars [index_WorkFaxNumber]->get()) ;
@@ -210,12 +214,12 @@
     nsAutoString unichar ;
     nsAutoString unicharBis ;
 
-    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_W, unichar)) {
+    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_A, unichar)) {
         splitString(unichar, unicharBis) ;
         SetHomeAddress(unichar.get()) ;
         SetHomeAddress2(unicharBis.get()) ;
     }
-    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_W, unichar)) {
+    if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_A, unichar)) {
         splitString(unichar, unicharBis) ;
         SetWorkAddress(unichar.get()) ;
         SetWorkAddress2(unicharBis.get()) ;
@@ -297,6 +301,7 @@
     SetDisplayName(properties [index_DisplayName]) ;
     GetNickName(getter_Copies(properties [index_NickName])) ;
     GetPrimaryEmail(getter_Copies(properties [index_EmailAddress])) ;
+    GetSecondEmail(getter_Copies(properties [index_SecondEmailAddress])) ;
     GetWorkPhone(getter_Copies(properties [index_WorkPhoneNumber])) ;
     GetHomePhone(getter_Copies(properties [index_HomePhoneNumber])) ;
     GetFaxNumber(getter_Copies(properties [index_WorkFaxNumber])) ;
@@ -316,9 +321,16 @@
     GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
     GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
     GetNotes(getter_Copies(properties [index_Comments])) ;
-    if (!mapiAddBook->SetPropertiesUString(*mMapiData, OutlookCardMAPIProps, 
-        index_LastProp, properties)) {
-        PRINTF(("Cannot set general properties.\n")) ;
+
+    int i=0;
+    for (i=0;i<index_LastProp;i++)
+    {
+        if (!mapiAddBook->SetPropertyUString(*mMapiData,
+                                            OutlookCardMAPIProps[i],
+                                            properties[i]))
+        {
+            PRINTF(("Cannot set properties:%d.\n",OutlookCardMAPIProps[i])) ;
+    }
     }
     delete [] properties ;
     nsXPIDLString unichar ;
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2003-02-25 16:36:33.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2005-01-09 13:23:33.312500000 -0500
@@ -124,8 +124,8 @@
     nsCAutoString uri ;
     nsCOMPtr<nsIRDFResource> resource ;
 
-    for (ULONG i = 0 ; i < folders.mNbEntries ; ++ i) {
-        folders.mEntries [i].ToString(entryId) ;
+    for (ULONG i = 0 ; i < folders.GetSize() ; ++ i) {
+        folders[i].ToString(entryId) ;
         buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
         uri.Append(entryId) ;
         
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2004-02-05 13:33:06.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2005-01-09 13:23:33.328125000 -0500
@@ -126,7 +126,7 @@
         PRINTF(("Cannot get type.\n")) ;
         return NS_ERROR_FAILURE ;
     }
-    if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, unichars)) {
+    if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, unichars)) {
         PRINTF(("Cannot get name.\n")) ;
         return NS_ERROR_FAILURE ;
     }
@@ -163,45 +163,85 @@
     return retCode;
 }
 
+nsresult nsAbOutlookDirectory::BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                                                PRBool aSearchForOld, PRBool& aIsNewCard)
+{   
+    nsresult retCode = NS_OK ;
+    if (aSearchForOld) {
+        nsCStringKey key(uriName) ;
+        nsCOMPtr<nsISupports> existingCard = mCardList.Get(&key) ;
+        
+        if (existingCard) {
+            nsCOMPtr<nsIAbCard> card(do_QueryInterface(existingCard, &retCode)) ;
+            
+            NS_ENSURE_SUCCESS(retCode, retCode) ;
+            NS_IF_ADDREF(*aNewCard = card) ;
+            aIsNewCard = PR_FALSE ;
+            return retCode ;
+        }
+    }
+    aIsNewCard = PR_TRUE ;
+    nsCOMPtr<nsIRDFResource> resource ;
+
+    nsCOMPtr<nsIAbCard> childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    resource = do_QueryInterface(childCard, &retCode) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    retCode = resource->Init(uriName.get()) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    NS_IF_ADDREF(*aNewCard = childCard);
+    return retCode ;
+}
+
 NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
 {
     if (!aCards) { return NS_ERROR_NULL_POINTER ; }
     *aCards = nsnull ;
     nsCOMPtr<nsISupportsArray> cardList ;
+    nsCStringArray uriList ;
+    nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
     nsresult retCode ;
     
-    mCardList.Reset() ;
     if (mIsQueryURI) {
         retCode = StartSearch() ;
-        NS_NewISupportsArray(getter_AddRefs(cardList)) ;
     }
     else {
-        retCode = GetChildCards(getter_AddRefs(cardList), nsnull) ;
+        retCode = GetChildCards(uriList, nsnull) ;
     }
+    NS_NewISupportsArray(getter_AddRefs(cardList)) ;
     if (NS_SUCCEEDED(retCode)) {
         // Fill the results array and update the card list
         // Also update the address list and notify any changes.
         PRUint32 nbCards = 0 ;
-        nsCOMPtr<nsISupports> element ;
+        nsCAutoString uriName;
+        nsCOMPtr <nsIAbCard> childCard;
+        PRBool searchForOldCards = 0; //(mCardList.Count() != 0) ;
+
+        nbCards = uriList.Count();
+		NS_NewISupportsArray(getter_AddRefs(m_AddressList));
         
-        cardList->Enumerate(aCards) ;
-        cardList->Count(&nbCards) ;
         for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
-            cardList->GetElementAt(i, getter_AddRefs(element)) ;
-            nsVoidKey newKey (NS_STATIC_CAST(void *, element)) ;
-            nsCOMPtr<nsISupports> oldElement = mCardList.Get(&newKey) ;
+            PRBool isNewCard = PR_FALSE ;
 
-            if (!oldElement) {
+            uriList.CStringAt(i,uriName);
+            retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), searchForOldCards, isNewCard);
+            NS_ENSURE_SUCCESS(retCode, retCode) ;
+            cardList->AppendElement(childCard);
+
+            if (isNewCard) {
                 // We are dealing with a new element (probably directly
                 // added from Outlook), we may need to sync m_AddressList
-                mCardList.Put(&newKey, element) ;
-                nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
+                nsCStringKey newKey(uriName) ;
+
+                mCardList.Put(&newKey, childCard) ;
+                nsCOMPtr<nsIAbCard> card (do_QueryInterface(childCard, &retCode)) ;
 
                 NS_ENSURE_SUCCESS(retCode, retCode) ;
                 PRBool isMailList = PR_FALSE ;
 
                 retCode = card->GetIsMailList(&isMailList) ;
                 NS_ENSURE_SUCCESS(retCode, retCode) ;
+
                 if (isMailList) {
                     // We can have mailing lists only in folder, 
                     // we must add the directory to m_AddressList
@@ -224,18 +264,33 @@
                     NotifyItemAddition(card) ;
                 }
             }
-            else {
-                NS_ASSERTION(oldElement == element, "Different card stored") ;
             }
         }
+    return cardList->Enumerate(aCards) ;
     }
+
+static nsresult ExtractUriFromCard(nsIAbCard *aCard, nsCString& aUri) {
+    nsresult retCode = NS_OK ;
+    nsCOMPtr<nsIRDFResource> resource (do_QueryInterface(aCard, &retCode)) ;
+    
+    // Receiving a non-RDF card is accepted
+    if (NS_FAILED(retCode)) { return NS_OK ; }
+    nsXPIDLCString uri ;
+    
+    retCode = resource->GetValue(getter_Copies(uri)) ;
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    aUri = uri.get() ;
     return retCode ;
 }
 
 NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
 {
     if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
-    nsVoidKey key (NS_STATIC_CAST(void *, aCard)) ;
+    *aHasCard = PR_FALSE ;
+    nsCString uri ;
+
+    ExtractUriFromCard(aCard, uri) ;
+    nsCStringKey key(uri) ;
 
     *aHasCard = mCardList.Exists(&key) ;
     return NS_OK ;
@@ -317,7 +372,10 @@
                 PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
             }
             else {
-                nsVoidKey key (NS_STATIC_CAST(void *, element)) ;
+                nsCString uri ;
+
+                ExtractUriFromCard(card, uri) ;
+                nsCStringKey key(uri) ;
                 
                 mCardList.Remove(&key) ;
                 if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
@@ -386,7 +444,10 @@
     }
     retCode = CreateCard(aData, addedCard) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    nsVoidKey newKey (NS_STATIC_CAST(void *, *addedCard)) ;
+    nsCString uri ;
+
+    ExtractUriFromCard(*addedCard, uri) ;
+    nsCStringKey newKey(uri) ;
     
     mCardList.Put(&newKey, *addedCard) ;
     if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
@@ -457,7 +518,7 @@
     if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
     retCode = GetDirName(getter_Copies(name)) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, name.get())) {
+    if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, name.get())) {
         return NS_ERROR_FAILURE ;
     }
     retCode = CommitAddressList() ;
@@ -518,6 +579,7 @@
     {"DisplayName", PR_DISPLAY_NAME_A},
     {"NickName", PR_NICKNAME_A},
     {"PrimaryEmail", PR_EMAIL_ADDRESS_A},
+    {"SecondEmail",PR_SECOND_EMAIL_ADDRESS_A},
     {"WorkPhone", PR_BUSINESS_TELEPHONE_NUMBER_A},
     {"HomePhone", PR_HOME_TELEPHONE_NUMBER_A},
     {"FaxNumber", PR_BUSINESS_FAX_NUMBER_A},
@@ -1032,7 +1094,10 @@
 
 nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
 {
-    nsVoidKey newKey (NS_STATIC_CAST(void *, aCard)) ;
+    nsCString uri ;
+
+    ExtractUriFromCard(aCard, uri) ;
+    nsCStringKey newKey(uri) ;
     nsresult retCode = NS_OK ;
     
     mCardList.Put(&newKey, aCard) ;
@@ -1056,14 +1121,14 @@
     retCode = BuildRestriction(aArguments, arguments) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
     nsCOMPtr<nsISupportsArray> resultsArray ;
+    nsCStringArray uriArray ;
     PRUint32 nbResults = 0 ;
     
-    retCode = GetChildCards(getter_AddRefs(resultsArray), 
+    retCode = GetChildCards(uriArray, 
                             arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
     DestroyRestriction(arguments) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
-    retCode = resultsArray->Count(&nbResults) ;
-    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    nbResults = uriArray.Count() ;
     nsCOMPtr<nsIAbDirectoryQueryResult> result ;
     nsAbDirectoryQueryResult *newResult = nsnull ;
 
@@ -1071,15 +1136,18 @@
         nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
     }
     PRUint32 i = 0 ;
-    nsCOMPtr<nsISupports> element ;
     nsCOMPtr<nsISupportsArray> propertyValues ;
     
+    nsCAutoString uriName;
+    nsCOMPtr <nsIAbCard> card;
+
     for (i = 0 ; i < nbResults ; ++ i) {
-        retCode = resultsArray->GetElementAt(i, getter_AddRefs(element)) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
+        PRBool isNewCard = PR_FALSE ;
         
+        uriArray.CStringAt(i,uriName);
+        retCode = BuildCardFromURI(uriName,getter_AddRefs(card), PR_FALSE, isNewCard);
         NS_ENSURE_SUCCESS(retCode, retCode) ;
+        
         FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
         newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                  nsIAbDirectoryQueryResult::queryResultMatch, 
@@ -1104,13 +1172,43 @@
     if (!aCards) { return NS_ERROR_NULL_POINTER ; }
     *aCards = nsnull ;
     nsresult retCode = NS_OK ;
-    nsCOMPtr<nsISupportsArray> cards ;
+
+    nsCOMPtr<nsISupportsArray> cards;
+    retCode = NS_NewISupportsArray(getter_AddRefs(cards));
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+
+    nsCStringArray uriList;
+    retCode = GetChildCards(uriList,aRestriction);
+    NS_ENSURE_SUCCESS(retCode, retCode) ;
+    
+    nsCAutoString uriName;
+    nsCOMPtr <nsIAbCard> childCard;
+    PRUint32 nbURIs = 0 ;
+    nbURIs = uriList.Count();
+    PRUint32 i = 0 ;
+        
+    for (i = 0 ; i < nbURIs ; ++ i) {
+        PRBool isNewCard = PR_FALSE ;
+
+        uriList.CStringAt(i,uriName);
+        retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), PR_TRUE, isNewCard);
+        NS_ENSURE_SUCCESS(retCode, retCode) ;
+        cards->AppendElement(childCard);
+    }        
+    
+    NS_IF_ADDREF(*aCards = cards);
+    return retCode ;
+}
+
+nsresult nsAbOutlookDirectory::GetChildCards(nsCStringArray& aURI, 
+                                             void *aRestriction)
+{
+    nsresult retCode = NS_OK ;
     nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
     nsMapiEntryArray cardEntries ;
     LPSRestriction restriction = (LPSRestriction) aRestriction ;
 
     if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
-    retCode = NS_NewISupportsArray(getter_AddRefs(cards)) ;
     NS_ENSURE_SUCCESS(retCode, retCode) ;
     if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
         PRINTF(("Cannot get cards.\n")) ;
@@ -1119,22 +1217,14 @@
     nsCAutoString entryId ;
     nsCAutoString uriName ;
     nsCOMPtr<nsIRDFResource> resource ;
-    nsCOMPtr <nsIAbCard> childCard;
-        
-    for (ULONG card = 0 ; card < cardEntries.mNbEntries ; ++ card) {
-        cardEntries.mEntries [card].ToString(entryId) ;
+    aURI.Clear();
+    
+    for (ULONG card = 0 ; card < cardEntries.GetSize() ; ++ card) {
+        cardEntries [card].ToString(entryId) ;
         buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
         uriName.Append(entryId) ;
-        childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        resource = do_QueryInterface(childCard, &retCode) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        retCode = resource->Init(uriName.get()) ;
-        NS_ENSURE_SUCCESS(retCode, retCode) ;
-        cards->AppendElement(childCard) ;
+        aURI.AppendCString(uriName);
     }
-    *aCards = cards ;
-    NS_ADDREF(*aCards) ;
     return retCode ;
 }
 
@@ -1158,8 +1248,8 @@
     nsCAutoString uriName ;
     nsCOMPtr <nsIRDFResource> resource ;
 
-    for (ULONG node = 0 ; node < nodeEntries.mNbEntries ; ++ node) {
-        nodeEntries.mEntries [node].ToString(entryId) ;
+    for (ULONG node = 0 ; node < nodeEntries.GetSize() ; ++ node) {
+        nodeEntries [node].ToString(entryId) ;
         buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
         uriName.Append(entryId) ;
         retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
@@ -1280,7 +1370,7 @@
         // In the case of a mailing list, we cannot directly create a new card,
         // we have to create a temporary one in a real folder (to be able to use
         // templates) and then copy it to the mailing list.
-        if (m_IsMailList) {
+        if (m_IsMailList && mAbWinType == nsAbWinType_OutlookExp) {
             nsMapiEntry parentEntry ;
             nsMapiEntry temporaryEntry ;
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h
--- misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2004-02-05 13:33:06.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2005-01-09 13:23:33.343750000 -0500
@@ -46,6 +46,7 @@
 #include "nsHashtable.h"
 
 #include "nsISupportsArray.h"
+#include "nsVoidArray.h"
 
 struct nsMapiEntry ;
 
@@ -92,6 +93,8 @@
 protected:
     // Retrieve hierarchy as cards, with an optional restriction
     nsresult GetChildCards(nsISupportsArray **aCards, void *aRestriction) ;
+    // Retrieve hierarchy as URIs, with an optional restriction
+    nsresult GetChildCards(nsCStringArray& aURI, void *aRestriction) ;
     // Retrieve hierarchy as directories
     nsresult GetChildNodes(nsISupportsArray **aNodes) ;
     // Create a new card
@@ -103,6 +106,9 @@
     nsresult CommitAddressList(void) ;
     // Read MAPI repository
     nsresult UpdateAddressList(void) ;
+    // Search for an existing card or build a new one
+    nsresult BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                              PRBool aSearchForOld, PRBool& aIsNewCard) ;
 
     nsMapiEntry *mMapiData ;
     // Container for the query threads
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2004-04-14 16:16:12.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2005-01-09 13:23:33.359375000 -0500
@@ -41,6 +41,9 @@
 #define USES_IID_IABContainer
 #define USES_IID_IMAPITable
 #define USES_IID_IDistList
+#define USES_IID_IMsgStore
+#define USES_IID_IMessage
+#define USES_IID_IMAPIFolder
 
 #include "nsAbWinHelper.h"
 #include "nsAbUtils.h"
@@ -59,19 +62,6 @@
 
 #define PRINTF(args) PR_LOG(gAbWinHelperLog, PR_LOG_DEBUG, args)
 
-// Small utility to ensure release of all MAPI interfaces
-template <class tInterface> struct nsMapiInterfaceWrapper
-{
-    tInterface mInterface ;
-
-    nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
-    ~nsMapiInterfaceWrapper(void) {
-        if (mInterface != NULL) { mInterface->Release() ; }
-    }
-    operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
-    tInterface operator -> (void) const { return mInterface ; }
-    operator tInterface *(void) { return &mInterface ; }
-} ;
 
 static void assignEntryID(LPENTRYID& aTarget, LPENTRYID aSource, ULONG aByteCount)
 {
@@ -249,24 +239,28 @@
 MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
 
 nsMapiEntryArray::nsMapiEntryArray(void)
-: mEntries(NULL), mNbEntries(0)
 {
     MOZ_COUNT_CTOR(nsMapiEntryArray) ;
 }
 
 nsMapiEntryArray::~nsMapiEntryArray(void)
 {
-    if (mEntries) { delete [] mEntries ; }
+    CleanUp();
     MOZ_COUNT_DTOR(nsMapiEntryArray) ;
 }
-
+void  nsMapiEntryArray::AddItem(nsMapiEntry * aEntries)
+{
+    m_array.AppendElement(aEntries);
+}
 void nsMapiEntryArray::CleanUp(void)
 {
-    if (mEntries != NULL) { 
-        delete [] mEntries ;
-        mEntries = NULL ;
-        mNbEntries = 0 ;
+    nsMapiEntry *pEntries;
+    for (int i = 0; i < m_array.Count(); i++)
+    {
+        pEntries = (nsMapiEntry *)m_array.ElementAt( i);
+        delete pEntries;
     }
+    m_array.Clear();
 }
 
 MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
@@ -280,100 +274,55 @@
 // same protection (MAPI is supposed to be thread-safe).
 PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
 
+int            nsAbWinHelper::m_clients = 0;
+
+PRUnichar *    nsAbWinHelper::m_pUniBuff = NULL;
+int            nsAbWinHelper::m_uniBuffLen = 0;
+char      *    nsAbWinHelper::m_pCStrBuff = NULL;
+int            nsAbWinHelper::m_cstrBuffLen = 0;
+
 nsAbWinHelper::nsAbWinHelper(void)
-: mAddressBook(NULL), mLastError(S_OK)
+:mLastError(S_OK)
 {
     MOZ_COUNT_CTOR(nsAbWinHelper) ;
+    m_clients++;
 }
 
 nsAbWinHelper::~nsAbWinHelper(void)
 {
     MOZ_COUNT_DTOR(nsAbWinHelper) ;
-}
-
-BOOL nsAbWinHelper::GetFolders(nsMapiEntryArray& aFolders)
+    m_clients--;
+    if (!m_clients)
 {
-    aFolders.CleanUp() ;
-    nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
-    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
-    ULONG objType = 0 ;
-    ULONG rowCount = 0 ;
-    SRestriction restriction ;
-    SPropTagArray folderColumns ;
-
-    mLastError = mAddressBook->OpenEntry(0, NULL, NULL, 0, &objType, 
-                                         rootFolder) ;
-    if (HR_FAILED(mLastError)) { 
-        PRINTF(("Cannot open root %08x.\n", mLastError)) ;
-        return FALSE ; 
+        delete [] m_pUniBuff;
+        m_pUniBuff = NULL;
+        m_uniBuffLen = 0;
+        delete [] m_pCStrBuff;
+        m_pCStrBuff = NULL;
+        m_cstrBuffLen = 0;
     }
-    mLastError = rootFolder->GetHierarchyTable(0, folders) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get hierarchy %08x.\n", mLastError)) ;
-        return FALSE ; 
     }
-    // We only take into account modifiable containers, 
-    // otherwise, we end up with all the directory services...
-    restriction.rt = RES_BITMASK ;
-    restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
-    restriction.res.resBitMask.relBMR = BMR_NEZ ;
-    restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
-    mLastError = folders->Restrict(&restriction, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
-    }
-    folderColumns.cValues = 1 ;
-    folderColumns.aulPropTag [0] = PR_ENTRYID ;
-    mLastError = folders->SetColumns(&folderColumns, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = folders->GetRowCount(0, &rowCount) ;
-    if (HR_SUCCEEDED(mLastError)) {
-        aFolders.mEntries = new nsMapiEntry [rowCount] ;
-        aFolders.mNbEntries = 0 ;
-        do {
-            LPSRowSet rowSet = NULL ;
-
-            rowCount = 0 ;
-            mLastError = folders->QueryRows(1, 0, &rowSet) ;
-            if (HR_SUCCEEDED(mLastError)) {
-                rowCount = rowSet->cRows ;
-                if (rowCount > 0) {
-                    nsMapiEntry& current = aFolders.mEntries [aFolders.mNbEntries ++] ;
-                    SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
-                    
-                    current.Assign(currentValue.Value.bin.cb,
-                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
-                }
-                MyFreeProws(rowSet) ;
-            }
-            else {
-                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
-            }
-        } while (rowCount > 0) ;
-    }
-    return HR_SUCCEEDED(mLastError) ;
-}
+
 
 BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                              nsMapiEntryArray& aCards)
 {
     aCards.CleanUp() ;
-    return GetContents(aParent, aRestriction, &aCards.mEntries, aCards.mNbEntries, 0) ;
+    return GetContents(aParent, aRestriction, &aCards, 0) ;
 }
  
 BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
 { 
     aNodes.CleanUp() ;
-    return GetContents(aParent, NULL, &aNodes.mEntries, aNodes.mNbEntries, MAPI_DISTLIST) ;
+    return GetContents(aParent, NULL, &aNodes, MAPI_DISTLIST) ;
 }
 
 BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
 {
-    aNbCards = 0 ;
-    return GetContents(aParent, NULL, NULL, aNbCards, 0) ;
+    nsMapiEntryArray aCards;
+    BOOL ret=GetContents(aParent, NULL, &aCards,  0) ;
+    aNbCards=aCards.GetSize();
+    return ret;
 }
 
 BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
@@ -390,7 +339,7 @@
             aName = values->Value.lpszA ;
         }
         else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
-            aName.AssignWithConversion(values->Value.lpszW) ;
+            UnicodeToCStr(values->Value.lpszW,aName) ;
         }
     }
     FreeBuffer(values) ;
@@ -410,7 +359,7 @@
             aName = values->Value.lpszW ;
         }
         else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
-            aName.AssignWithConversion(values->Value.lpszA) ;
+            CStrToUnicode(values->Value.lpszA,aName) ;
         }
     }
     FreeBuffer(values) ;
@@ -431,16 +380,22 @@
         ULONG i = 0 ;
 
         for (i = 0 ; i < valueCount ; ++ i) {
-            if (PROP_ID(values [i].ulPropTag) == PROP_ID(aPropertyTags [i])) {
+            if (PROP_TYPE( values [i].ulPropTag) != PT_ERROR && values [i].Value.l != MAPI_E_NOT_FOUND){
                 if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                     nsAutoString temp ;
 
-                    temp.AssignWithConversion (values [i].Value.lpszA) ;
+                    CStrToUnicode(values [i].Value.lpszA,temp) ;
                     aNames.AppendString(temp) ;
                 }
                 else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                     aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                 }
+                else if (aPropertyTags [i] == PR_EMAIL_ADDRESS_A) {
+                    nsAutoString temp ;
+
+                    CStrToUnicode (values [i].Value.lpszA,temp) ;
+                    aNames.AppendString(temp) ;
+                }
                 else {
                     aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                 }
@@ -466,7 +421,6 @@
     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) { return FALSE ; }
     if (valueCount == 1 && values != NULL && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
         SYSTEMTIME readableTime ;
-
         if (FileTimeToSystemTime(&values->Value.ft, &readableTime)) {
             aYear = readableTime.wYear ;
             aMonth = readableTime.wMonth ;
@@ -518,7 +472,7 @@
     nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
     ULONG objType = 0 ;
     
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IMAPIContainer, 0, &objType, 
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -537,7 +491,7 @@
     SBinary entry ;
     SBinaryArray entryArray ;
 
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType, 
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -567,14 +521,15 @@
         value.Value.lpszW = NS_CONST_CAST(WORD *, aValue) ;
     }
     else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
-        alternativeValue.AssignWithConversion(aValue) ;
+        UnicodeToCStr(aValue,alternativeValue) ;
         value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
     }
     else {
         PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
         return TRUE ;
     }
-    return SetMAPIProperties(aObject, 1, &value) ;
+    LPSPropValue values=&value;
+    return SetMAPIProperties(aObject, 1, values) ;
 }
 
 BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
@@ -595,7 +550,7 @@
             values [currentValue ++].Value.lpszW = NS_CONST_CAST(WORD *, aValues [i].get()) ;
         }
         else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
-            alternativeValue.AssignWithConversion(aValues [i].get()) ;
+            UnicodeToCStr(aValues [i].get(),alternativeValue) ;
             char *av = nsCRT::strdup(alternativeValue.get()) ;
             if (!av) {
                 retCode = FALSE ;
@@ -633,7 +588,8 @@
         readableTime.wSecond = 0 ;
         readableTime.wMilliseconds = 0 ;
         if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
-            return SetMAPIProperties(aObject, 1, &value) ;
+            LPSPropValue values=&value;
+            return SetMAPIProperties(aObject, 1, values) ;
         }
         return TRUE ;
     }
@@ -645,7 +601,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) { 
@@ -708,7 +664,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) {
@@ -773,7 +729,7 @@
     nsMapiInterfaceWrapper<LPABCONT> container ;
     ULONG objType = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                          &IID_IABContainer, MAPI_MODIFY, &objType,
                                          container) ;
     if (HR_FAILED(mLastError)) { 
@@ -810,194 +766,77 @@
     return TRUE ;
 }
 
-BOOL nsAbWinHelper::GetDefaultContainer(nsMapiEntry& aContainer)
-{
-    LPENTRYID entryId = NULL ; 
-    ULONG byteCount = 0 ;
-
-    mLastError = mAddressBook->GetPAB(&byteCount, &entryId) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get PAB %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    aContainer.Assign(byteCount, entryId) ;
-    FreeBuffer(entryId) ;
-    return TRUE ;
-}
 
-enum
-{
-    ContentsColumnEntryId = 0,
-    ContentsColumnObjectType,
-    ContentsColumnsSize
-} ;
 
-static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
-{
-    ContentsColumnsSize,
-    {
-        PR_ENTRYID,
-        PR_OBJECT_TYPE
-    }
-} ;
 
-BOOL nsAbWinHelper::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
-                                nsMapiEntry **aList, ULONG& aNbElements, ULONG aMapiType)
+void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
 {
-    if (aList != NULL) { *aList = NULL ; }
-    aNbElements = 0 ;
-    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
-    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
-    ULONG objType = 0 ;
-    ULONG rowCount = 0 ;
+    if (aRowset == NULL) { return ; }
+    ULONG i = 0 ;
 
-    mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId, 
-                                         &IID_IMAPIContainer, 0, &objType, 
-                                         parent) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
-        return FALSE ; 
-    }
-    // Here, flags for WAB and MAPI could be different, so this works
-    // only as long as we don't want to use any flag in GetContentsTable
-    mLastError = parent->GetContentsTable(0, contents) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
-        return FALSE ; 
+    for (i = 0 ; i < aRowset->cRows ; ++ i) {
+        FreeBuffer(aRowset->aRow [i].lpProps) ;
     }
-    if (aRestriction != NULL) {
-        mLastError = contents->Restrict(aRestriction, 0) ;
-        if (HR_FAILED(mLastError)) {
-            PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
-            return FALSE ;
-        }
-    }
-    mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = contents->GetRowCount(0, &rowCount) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    if (aList != NULL) { *aList = new nsMapiEntry [rowCount] ; }
-    aNbElements = 0 ;
-    do {
-        LPSRowSet rowSet = NULL ;
-        
-        rowCount = 0 ;
-        mLastError = contents->QueryRows(1, 0, &rowSet) ;
-        if (HR_FAILED(mLastError)) {
-            PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
-            return FALSE ;
-        }
-        rowCount = rowSet->cRows ;
-        if (rowCount > 0 &&
-            (aMapiType == 0 ||
-            rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)) {
-            if (aList != NULL) {
-                nsMapiEntry& current = (*aList) [aNbElements] ;
-                SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
-                
-                current.Assign(currentValue.Value.bin.cb,
-                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+    FreeBuffer(aRowset) ;
+        }
+void nsAbWinHelper::CStrToUnicode( const char *pStr, nsString& result)
+{
+    result.Truncate( 0);
+    int wLen = MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, 0);
+    if (wLen >= m_uniBuffLen)
+    {
+        delete [] m_pUniBuff;
+        m_pUniBuff = new PRUnichar[wLen + 64];
+        m_uniBuffLen = wLen + 64;
             }
-            ++ aNbElements ;
+    if (wLen)
+    {
+        MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, m_uniBuffLen);
+        result = m_pUniBuff;
         }
-        MyFreeProws(rowSet) ;
-    } while (rowCount > 0) ;
-    return TRUE ;
 }
-
-BOOL nsAbWinHelper::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
-                                      ULONG aNbProperties, LPSPropValue& aValue, 
-                                      ULONG& aValueCount)
+void nsAbWinHelper::UnicodeToCStr( const  PRUnichar *pUStr,nsCString& result)
 {
-    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
-    ULONG objType = 0 ;
-    LPSPropTagArray properties = NULL ;
-    ULONG i = 0 ;
-    
-    mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
-                                         &IID_IMAPIProp, 0, &objType, 
-                                         object) ;
-    if (HR_FAILED(mLastError)) { 
-        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
-        return FALSE ; 
+    result.Truncate( 0);
+    int cLen = WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, 0,NULL,NULL);
+    if (cLen >= m_cstrBuffLen) {
+        if (m_pCStrBuff)
+            delete [] m_pCStrBuff;
+        m_pCStrBuff = new char[cLen + 64];
+        m_cstrBuffLen = cLen + 64;
     }
-    AllocateBuffer(CbNewSPropTagArray(aNbProperties), 
-                   NS_REINTERPRET_CAST(void **, &properties)) ;
-    properties->cValues = aNbProperties ;
-    for (i = 0 ; i < aNbProperties ; ++ i) {
-        properties->aulPropTag [i] = aPropertyTags [i] ;
-    }
-    mLastError = object->GetProps(properties, 0, &aValueCount, &aValue) ;
-    FreeBuffer(properties) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot get props %08x.\n", mLastError)) ;
+    if (cLen) {
+        WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, m_cstrBuffLen,NULL,NULL);
+        result = m_pCStrBuff;
     }
-    return HR_SUCCEEDED(mLastError) ;
 }
 
-BOOL nsAbWinHelper::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
-                                      const LPSPropValue& aValues)
-{
-    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
-    ULONG objType = 0 ;
-    LPSPropProblemArray problems = NULL ;
+static nsAbWinHelper *getOutlookAddressBook(void) {
+    static nsMapiAddressBook *addressBook = NULL ;
 
-    mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
-                                         &IID_IMAPIProp, MAPI_MODIFY, &objType, 
-                                         object) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
-        return FALSE ;
-    }
-    if (problems != NULL) {
-        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
-            PRINTF(("Problem %d: index %d code %08x.\n", i, 
-                problems->aProblem [i].ulIndex, 
-                problems->aProblem [i].scode)) ;
-        }
-    }
-    mLastError = object->SaveChanges(0) ;
-    if (HR_FAILED(mLastError)) {
-        PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
-    }
-    return HR_SUCCEEDED(mLastError) ;
+    if (addressBook == NULL) { addressBook = new nsMapiAddressBook ; } 
+    return addressBook ;
 }
 
-void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
-{
-    if (aRowset == NULL) { return ; }
-    ULONG i = 0 ; 
+static nsAbWinHelper *getOutlookExpAddressBook(void) {
+    static nsWabAddressBook *addressBook = NULL ;
 
-    for (i = 0 ; i < aRowset->cRows ; ++ i) {
-        FreeBuffer(aRowset->aRow [i].lpProps) ;
-    }
-    FreeBuffer(aRowset) ;
+    if (addressBook == NULL) { addressBook = new nsWabAddressBook ; } 
+    return addressBook ;
 }
 
 nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
 : mHelper(NULL) 
 {
     switch(aType) {
-    case nsAbWinType_Outlook: mHelper = new nsMapiAddressBook ; break ;
-    case nsAbWinType_OutlookExp: mHelper = new nsWabAddressBook ; break ;
+    case nsAbWinType_Outlook: mHelper = getOutlookAddressBook() ; break ;
+    case nsAbWinType_OutlookExp: mHelper = getOutlookExpAddressBook() ; break ;
     default: break ;
     }
 }
 
 nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
 {
-    delete mHelper ;
 }
 
 const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
diff -ru misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.h misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.h
--- misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2004-04-14 16:16:12.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2005-01-09 17:04:59.843750000 -0500
@@ -45,6 +45,24 @@
 #include "nsVoidArray.h"
 #include "nsXPIDLString.h"
  
+#define PR_SECOND_EMAIL_ADDRESS_A  0x8033001E
+#define PR_SCREEN_NAME_A           0x805B001E
+ 
+
+// Small utility to ensure release of all MAPI interfaces
+template <class tInterface> struct nsMapiInterfaceWrapper
+{
+    tInterface mInterface ;
+
+    nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
+    ~nsMapiInterfaceWrapper(void) {
+        if (mInterface ) { mInterface->Release() ; }
+    }
+    operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
+    tInterface operator -> (void) const { return mInterface ; }
+    operator tInterface *(void) { return &mInterface ; }
+} ;
+
 struct nsMapiEntry
 {
     ULONG     mByteCount ;
@@ -62,14 +80,28 @@
 
 struct nsMapiEntryArray 
 {
-    nsMapiEntry *mEntries ;
-    ULONG      mNbEntries ;
 
     nsMapiEntryArray(void) ;
     ~nsMapiEntryArray(void) ;
 
-    const nsMapiEntry& operator [] (int aIndex) const { return mEntries [aIndex] ; }
+    void  AddItem(nsMapiEntry * aEntries);
+    void  AddItem(    ULONG     mByteCount , LPENTRYID mEntryId )
+    {
+        nsMapiEntry * aEntries=new nsMapiEntry();
+        aEntries->Assign(mByteCount,mEntryId);
+        AddItem(aEntries);
+    }
+
+    ULONG        GetSize( void) { return( m_array.Count());}
+    nsMapiEntry& operator [] (int aIndex)  { return *(nsMapiEntry*)m_array.ElementAt(aIndex); }
+    nsMapiEntry* ElementAt(int aIndex)  { return (nsMapiEntry*)m_array.ElementAt(aIndex); }
     void CleanUp(void) ;
+    void Remove(nsMapiEntry * aEntries){ m_array.RemoveElement(aEntries); }
+    void Remove(int index){ m_array.RemoveElementAt(index); }
+    ULONG IndexOf(nsMapiEntry * aEntries){return m_array.IndexOf(aEntries);};
+private:
+    nsVoidArray        m_array;
+
 } ;
 
 class nsAbWinHelper
@@ -79,7 +111,7 @@
     virtual ~nsAbWinHelper(void) ;
 
     // Get the top address books
-    BOOL GetFolders(nsMapiEntryArray& aFolders) ;
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders) =0;
     // Get a list of entries for cards/mailing lists in a folder/mailing list
     BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                   nsMapiEntryArray& aCards) ;
@@ -97,18 +129,14 @@
     BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                               ULONG aNbProperties, nsStringArray& aValues) ;
     // Get the value of a MAPI property of type SYSTIME
-    BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
+    virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                          WORD& aYear, WORD& aMonth, WORD& aDay) ;
-    // Get the value of a MAPI property of type LONG
-    BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
     // Get the value of a MAPI property of type BIN
     BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
     // Tests if a container contains an entry
     BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
-    // Delete an entry in the address book
-    BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
     // Set the value of a MAPI property of type string in unicode
-    BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
+    virtual BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                              const PRUnichar *aValue) ;
     // Same as previous, but with a bunch of properties in one call
     BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
@@ -117,32 +145,44 @@
     BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                          WORD aYear, WORD aMonth, WORD aDay) ;
     // Create entry in the address book
-    BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Delete an entry in the address book
+    virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
     // Create a distribution list in the address book
-    BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
     // Copy an existing entry in the address book
-    BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+    virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
     // Get a default address book container
-    BOOL GetDefaultContainer(nsMapiEntry& aContainer) ;
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer) =0;
     // Is the helper correctly initialised?
-    BOOL IsOK(void) const { return mAddressBook != NULL ; }
+    virtual BOOL IsOK(void) =0;/*const { return mAddressBook != NULL ; }*/
+
+    // Get the value of a MAPI property of type LONG
+    virtual BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
 
 protected:
     HRESULT mLastError ;
-    LPADRBOOK mAddressBook ;
     static PRUint32 mEntryCounter ;
     static PRLock *mMutex ;
 
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    ) = 0;
+
     // Retrieve the contents of a container, with an optional restriction
-    BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
-                     nsMapiEntry **aList, ULONG &aNbElements, ULONG aMapiType) ;
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) =0;
     // Retrieve the values of a set of properties on a MAPI object
-    BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                            ULONG aNbProperties,
-                           LPSPropValue& aValues, ULONG& aValueCount) ;
+                           LPSPropValue& aValues, ULONG& aValueCount) =0;
     // Set the values of a set of properties on a MAPI object
-    BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
-                           const LPSPropValue& aValues) ;
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues) =0;
     // Clean-up a rowset returned by QueryRows
     void MyFreeProws(LPSRowSet aSet) ;
     // Allocation of a buffer for transmission to interfaces
@@ -150,7 +190,16 @@
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) = 0 ;
 
+    static void            CStrToUnicode( const char *pStr, nsString& result);
+    static void            UnicodeToCStr( const PRUnichar *pStr, nsCString& result);
+
 private:
+    static int                m_clients;
+    static PRUnichar *        m_pUniBuff;
+    static int                m_uniBuffLen;
+    static char *             m_pCStrBuff;
+    static int                m_cstrBuffLen;
+
 } ;
 
 enum nsAbWinType 
@@ -168,6 +217,7 @@
 
     nsAbWinHelper *operator ->(void) { return mHelper ; }
 
+    static void FreeWinAbLibrarys();
 private:
     nsAbWinHelper *mHelper ;
 } ;
diff -ru misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp
--- misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2003-12-24 12:18:08.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2005-01-09 13:23:33.390625000 -0500
@@ -97,6 +97,9 @@
 
 static const char kMailListAddressFormat[] = "Address%d";
 
+extern int getMD5sum(const char * fileName,char * sum);
+extern int testMD5sum(const char * fileName,char * sum);
+
 static NS_DEFINE_CID(kCMorkFactory, NS_MORK_CID);
 
 nsAddrDatabase::nsAddrDatabase()
@@ -166,6 +169,7 @@
       m_LastRecordKey(0),
       m_dbDirectory(nsnull)
 {
+	memset(m_dbMd5Sum,0,33);
 }
 
 nsAddrDatabase::~nsAddrDatabase()
@@ -720,7 +724,11 @@
           NS_RELEASE(oldFile); // always release our file ref, store has own
         }
       }
-      
+
+	  ret = getMD5sum(nativeFileName,m_dbMd5Sum);
+	  if (ret == 1)
+		ret = NS_ERROR_FAILURE;
+
       nsCRT::free(nativeFileName);
       
       if (NS_SUCCEEDED(ret) && thumb)
@@ -817,6 +825,17 @@
     nsresult    err = NS_OK;
     nsIMdbThumb    *commitThumb = nsnull;
 
+    const char *pFilename = m_dbName.GetCString(); /* do not free */
+    char    *nativeFileName = nsCRT::strdup(pFilename);
+#if defined(XP_PC) || defined(XP_MAC)
+      UnixToNative(nativeFileName);
+#endif
+	if (testMD5sum(nativeFileName,m_dbMd5Sum))
+    {
+        nsCRT::free(nativeFileName);
+        return NS_ERROR_FILE_ACCESS_DENIED;
+    }
+
   if (commitType == nsAddrDBCommitType::kLargeCommit || commitType == nsAddrDBCommitType::kSessionCommit)
   {
     mdb_percent outActualWaste = 0;
@@ -867,6 +886,10 @@
     // ### do something with error, but clear it now because mork errors out on commits.
     if (GetEnv())
         GetEnv()->ClearErrors();
+	if (NS_SUCCEEDED(err) && getMD5sum(nativeFileName,m_dbMd5Sum))
+		err = NS_ERROR_FAILURE;
+    nsCRT::free(nativeFileName);
+
     return err;
 }
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.h misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.h
--- misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2004-01-28 12:22:13.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2005-01-09 13:23:33.406250000 -0500
@@ -396,6 +396,7 @@
 	nsIMdbTable		    *m_mdbPabTable;
 	nsIMdbTable                 *m_mdbDeletedCardsTable;
 	nsFileSpec		    m_dbName;
+	char				m_dbMd5Sum[33];
 	PRBool				m_mdbTokensInitialized;
     nsVoidArray /*<nsIAddrDBListener>*/ *m_ChangeListeners;
 
diff -ru misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp
--- misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2001-10-30 02:59:16.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2005-01-09 13:23:33.421875000 -0500
@@ -41,6 +41,22 @@
 
 #include "prlog.h"
 
+static char * stristr(const char *big, const char *little)
+{
+    PRUint32 len;
+
+    if (!big || !little || !*big || !*little)
+      return 0;
+    len = strlen(little);
+
+    for( ; *big; big++ )
+       if(!_strnicmp (big, little, 1) && ! _strnicmp (big, little, len) )
+          return (char *)big;
+
+    return (char *)0;
+
+}
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gMapiAddressBookLog
     = PR_NewLogModule("nsMapiAddressBookLog");
@@ -48,6 +64,60 @@
 
 #define PRINTF(args) PR_LOG(gMapiAddressBookLog, PR_LOG_DEBUG, args)
 
+#define    OUTLOOK_EMAIL_DIAPLAY_MAPI_ID    0x00008005  //use to get and set display
+#define    OUTLOOK_EMAIL1_MAPI_ID           0x00008084  //use to get and set primary email address
+#define    OUTLOOK_EMAIL2_MAPI_ID           0x00008094  //use to get and set second  email address
+#define    OUTLOOK_EMAIL_SCREEN_NAME        0x8061001E  //use to get and set screen name
+#define    OUTLOOK_EMAIL_ORGID              0x00008085  //use to get orginal entryid to add to distlist
+#define    OUTLOOK_EMAIL_LIST1              0x00008054  //use to get distlist table
+#define    OUTLOOK_EMAIL_LIST2              0x00008055  //use to set distlist table
+
+static const TagMap TagMaps[]={
+    {PR_DISPLAY_NAME_A,         OUTLOOK_EMAIL_DIAPLAY_MAPI_ID,    PT_STRING8},
+    {PR_EMAIL_ADDRESS_A,        OUTLOOK_EMAIL1_MAPI_ID,           PT_STRING8},
+    {PR_SECOND_EMAIL_ADDRESS_A, OUTLOOK_EMAIL2_MAPI_ID,           PT_STRING8},
+    {PR_SCREEN_NAME_A,          OUTLOOK_EMAIL_SCREEN_NAME,        PT_STRING8}};
+
+enum {
+    ieidPR_ENTRYID = 0,
+    ieidPR_OBJECT_TYPE,
+    ieidPR_DISPLAY_NAME,
+    ieidPR_MESSAGE_CLASS,
+    ieidPR_STORE_ENTRYID,
+    ieidPR_MESSAGE_RECIPIENTS,
+    ieidMax
+};
+
+static const SizedSPropTagArray(ieidMax, ptaEid)=
+{
+    ieidMax,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE,
+        PR_DISPLAY_NAME,
+        PR_MESSAGE_CLASS,
+        PR_STORE_ENTRYID,
+        PR_MESSAGE_RECIPIENTS
+    }
+};
+
+enum
+{
+    ContentsColumnEntryId = 0,
+    ContentsColumnObjectType,
+    ContentsColumnMessageClass,
+    ContentsColumnsSize
+} ;
+
+static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+{
+    ContentsColumnsSize,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE,
+        PR_MESSAGE_CLASS
+    }
+} ;
 
 HMODULE nsMapiAddressBook::mLibrary = NULL ;
 PRInt32 nsMapiAddressBook::mLibUsage = 0 ;
@@ -60,7 +130,7 @@
 BOOL nsMapiAddressBook::mInitialized = FALSE ;
 BOOL nsMapiAddressBook::mLogonDone = FALSE ;
 LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
-LPADRBOOK nsMapiAddressBook::mRootBook = NULL ;
+#define MAPI_NO_COINIT 8
 
 BOOL nsMapiAddressBook::LoadMapiLibrary(void)
 {
@@ -92,7 +162,7 @@
     mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
         GetProcAddress(mLibrary, "MAPILogonEx")) ;
     if (!mMAPILogonEx) { return FALSE ; }
-    MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS } ;
+    MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS | MAPI_NO_COINIT } ;
     HRESULT retCode = mMAPIInitialize(&mapiInit) ;
 
     if (HR_FAILED(retCode)) { 
@@ -106,22 +176,19 @@
                            MAPI_NEW_SESSION,
                            &mRootSession) ;
     if (HR_FAILED(retCode)) { 
-        PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ; return FALSE ;
+        PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ;
+        return FALSE ;
     }
     mLogonDone = TRUE ;
-    retCode = mRootSession->OpenAddressBook(0, NULL, 0, &mRootBook) ;
-    if (HR_FAILED(retCode)) { 
-        PRINTF(("Cannot open MAPI address book %08x.\n", retCode)) ;
-    }
+
     return HR_SUCCEEDED(retCode) ;
 }
 
 void nsMapiAddressBook::FreeMapiLibrary(void)
 {
     if (mLibrary) {
-        if (-- mLibUsage == 0) {
+        if (--mLibUsage < 0) {
             {
-                if (mRootBook) { mRootBook->Release() ; }
                 if (mRootSession) {
                     if (mLogonDone) { 
                         mRootSession->Logoff(NULL, 0, 0) ; 
@@ -135,6 +202,7 @@
                 }
             }  
             FreeLibrary(mLibrary) ;
+            mRootSession = NULL;
             mLibrary = NULL ; 
         }
     }
@@ -146,7 +214,6 @@
 : nsAbWinHelper()
 {
     BOOL result = Initialize() ;
-
     NS_ASSERTION(result == TRUE, "Couldn't initialize Mapi Helper") ;
     MOZ_COUNT_CTOR(nsMapiAddressBook) ;
 }
@@ -154,22 +221,882 @@
 nsMapiAddressBook::~nsMapiAddressBook(void)
 {
     nsAutoLock guard(mMutex) ;
-
+    CleanUpMDB();
     FreeMapiLibrary() ;
     MOZ_COUNT_DTOR(nsMapiAddressBook) ;
 }
 
+LPSPropValue nsMapiAddressBook::GetMapiProperty( LPMAPIPROP pProp, ULONG tag)
+{
+    if (!pProp)
+        return( NULL);
+
+    int    sz = CbNewSPropTagArray( 1);
+    SPropTagArray *pTag = (SPropTagArray *) new char[sz];
+    pTag->cValues = 1;
+    pTag->aulPropTag[0] = tag;
+    LPSPropValue    lpProp = NULL;
+    ULONG    cValues = 0;
+    HRESULT hr = pProp->GetProps( pTag, 0, &cValues, &lpProp);
+    delete pTag;
+    if (HR_FAILED( hr) || (cValues != 1)) {
+        if (lpProp)
+            mMAPIFreeBuffer( lpProp);
+        return( NULL);
+    }
+    else {
+        if (PROP_TYPE( lpProp->ulPropTag) == PT_ERROR) {
+            if (lpProp->Value.l == MAPI_E_NOT_FOUND) {
+                mMAPIFreeBuffer( lpProp);
+                lpProp = NULL;
+            }
+        }
+    }
+
+    return( lpProp);
+}
+BOOL nsMapiAddressBook::GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal)
+{
+    if (!pVal)
+        return( FALSE);
+    
+    BOOL bResult = TRUE;
+    switch (PROP_TYPE(pVal->ulPropTag))
+    {
+        case PT_BINARY:
+            cbEntryId = pVal->Value.bin.cb;
+            mMAPIAllocateBuffer( cbEntryId, (LPVOID *) &lpEntryId);
+            memcpy( lpEntryId, pVal->Value.bin.lpb, cbEntryId);
+        break;
+
+        default:
+            PRINTF(( "EntryId not in BINARY prop value\n"));
+            bResult = FALSE;
+        break;
+    }
+
+    if (pVal && delVal)
+        mMAPIFreeBuffer( pVal);
+
+    return( bResult);
+}
+
+BOOL nsMapiAddressBook::HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+{
+    LPMDB  lpMsgStore;
+    ULONG objType=0;
+    HRESULT             hr;
+
+    if (oType == MAPI_MESSAGE)
+        return FALSE;
+    if (oType == MAPI_STORE)
+    {
+        hr=mRootSession->OpenEntry(
+                    cb,
+                    pEntry,
+                    &IID_IMsgStore,
+                    MAPI_BEST_ACCESS,
+                    &objType,
+                    (IUnknown**)&lpMsgStore);
+        if (FAILED(hr))
+        return FALSE ;
+        //Add MDB to a list to make it can be released when class  destroyed.
+        //We must leave it openned or else we can't open address store in it.
+        AddToMDBArray(lpMsgStore);
+
+        LPSPropValue    pVal;
+        pVal=GetMapiProperty(lpMsgStore,PR_IPM_SUBTREE_ENTRYID);
+        
+        
+        if (pVal) {
+            ULONG            cbEntry;
+            LPENTRYID        pEntry;
+            nsMapiInterfaceWrapper<LPMAPICONTAINER> lpSubTree;
+
+            if (GetEntryIdFromProp( pVal, cbEntry, pEntry)) {
+                // Open up the folder!
+                BOOL bResult = TRUE;
+                bResult = lpMsgStore->OpenEntry(
+                                cbEntry,
+                                pEntry,
+                                NULL,
+                                MAPI_BEST_ACCESS,
+                                &objType,
+                                lpSubTree);
+                mMAPIFreeBuffer( pEntry);
+                if (!bResult && *(LPMAPICONTAINER*)&lpSubTree) {
+                    // Iterate the subtree with the results going into the folder list
+                    bResult = IterateHierarchy(*(LPMAPICONTAINER*)&lpSubTree,aFolders);
+    }
+                else {
+                    PRINTF(( "GetStoreFolders: Error opening sub tree.\n"));
+                }
+            }
+            else {
+                PRINTF(( "GetStoreFolders: Error getting entryID from sub tree property val.\n"));
+    }
+        }
+        else {
+            PRINTF(( "GetStoreFolders: Error getting sub tree property.\n"));
+        }
+    }
+    else
+    {
+        PRINTF(("Type:%d\n",oType));
+    }
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::IterateHierarchy(LPMAPICONTAINER pFolder,nsMapiEntryArray& aFolders, ULONG flags)
+{
+    // flags can be CONVENIENT_DEPTH or 0
+    // CONVENIENT_DEPTH will return all depths I believe instead
+    // of just children
+    HRESULT        hr;
+    nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+    hr = pFolder->GetHierarchyTable( CONVENIENT_DEPTH , lpTable);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: GetContentsTable failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+}
+
+    ULONG rowCount;
+    hr = lpTable->GetRowCount( 0, &rowCount);
+    if (!rowCount) {
+        return( TRUE);
+    }
+
+    hr = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: SetColumns failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+    }
+
+    hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+    if (HR_FAILED(hr)) {
+        PRINTF(( "IterateHierarchy: SeekRow failed: 0x%lx, %d\n", (long)hr, (int)hr));
+        return( FALSE);
+    }
+
+    int            cNumRows = 0;
+    LPSRowSet    lpRow;
+    BOOL        keepGoing = TRUE;
+    BOOL        bResult = TRUE;
+    do {
+        
+        lpRow = NULL;
+        hr = lpTable->QueryRows( 1, 0, &lpRow);
+
+        if (HR_FAILED(hr))
+{
+            PRINTF(( "QueryRows failed: 0x%lx, %d\n", (long)hr, (int)hr));
+            bResult = FALSE;
+            break;
+        }
+
+        if (lpRow){
+            cNumRows = lpRow->cRows;
+
+            if (cNumRows) {
+                LPENTRYID    lpEntry = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                ULONG        cb = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+                
+                keepGoing = HandleHierarchyItem( oType, cb, lpEntry,aFolders);
+
+            }
+            MyFreeProws(lpRow);
+        }
+
+    } while ( SUCCEEDED(hr) && cNumRows && lpRow && keepGoing);
+
+    
+    if (bResult && !keepGoing)
+        bResult = FALSE;
+
+    return( bResult);
+}
+BOOL nsMapiAddressBook::HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+{
+    ULONG objType=0;
+    if (oType == MAPI_FOLDER)
+    {
+        nsMapiInterfaceWrapper<LPMAPICONTAINER> pFolder ;
+        if (!mRootSession->OpenEntry(
+                        cb,
+                        pEntry,
+                        0,
+                        MAPI_BEST_ACCESS,
+                        &objType,
+                        pFolder))
+        {
+            LPSPropValue        pVal;
+
+
+            pVal = GetMapiProperty(*(LPMAPICONTAINER*)&pFolder, PR_CONTAINER_CLASS);
+            if (pVal)
+            {
+                if (strcmp("IPF.Contact",pVal->Value.lpszA) == 0)
+                {
+                    SPropValue *currentValue=GetMapiProperty( *(LPMAPICONTAINER*)&pFolder, PR_ENTRYID);
+                    
+                    aFolders.AddItem(currentValue->Value.bin.cb,
+                                  NS_REINTERPRET_CAST(LPENTRYID, currentValue->Value.bin.lpb)) ;
+
+                }
+            }
+        }
+    }
+    else
+    {
+        PRINTF(( "GetStoreFolders - HandleHierarchyItem: Unhandled ObjectType: %ld\n", oType));
+    }
+
+    return( TRUE);
+}
+
+
+BOOL nsMapiAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+{
+    aFolders.CleanUp() ;
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> rootFolder ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+    nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+
+    mLastError = mRootSession->GetMsgStoresTable( 0, lpTable);
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open MAPI MsgStores %08x.\n", mLastError));
+        return mLastError;
+    }
+
+    mLastError = lpTable->GetRowCount( 0, &rowCount);
+
+    mLastError = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+    if (FAILED(mLastError))
+        return( mLastError);
+    mLastError = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+    if (FAILED(mLastError))
+        return mLastError;
+    
+    int            cNumRows = 0;
+    LPSRowSet    lpRow;
+    BOOL        keepGoing = TRUE;
+    BOOL        bResult = TRUE;
+    do {
+        
+        lpRow = NULL;
+        mLastError = lpTable->QueryRows( 1, 0, &lpRow);
+
+        if (HR_FAILED(mLastError)){
+            bResult = FALSE;
+            break;
+        }
+
+        if (lpRow){
+            cNumRows = lpRow->cRows;
+
+            if (cNumRows) {
+                LPENTRYID    lpEID = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                ULONG        cbEID = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+
+
+                keepGoing = HandleContentsItem( oType, cbEID, lpEID,aFolders);
+            }
+            MyFreeProws( lpRow);
+        }
+
+    } while ( SUCCEEDED(mLastError) && cNumRows && lpRow && keepGoing);
+
+    
+    return HR_SUCCEEDED(mLastError) ;
+}
+BOOL nsMapiAddressBook::CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction)
+{
+    ULONG conditionType = 0 ;
+    ULONG ulResIndex;
+    if (!aRestriction)
+        return FALSE;
+    for (ulResIndex=0;ulResIndex < aRestrictionNum;ulResIndex++)
+    {
+        conditionType = aRestriction[ulResIndex].rt;
+        switch (conditionType) 
+        {
+        case RES_EXIST  :
+            aRestriction[ulResIndex].res.resExist.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resExist.ulPropTag);
+            break ;
+        case RES_BITMASK  :
+            aRestriction[ulResIndex].res.resBitMask.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resBitMask.ulPropTag);
+            break ;
+        case RES_CONTENT :
+            aRestriction[ulResIndex].res.resContent.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.ulPropTag);
+            aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag);
+            break ;
+        case RES_PROPERTY :
+            aRestriction[ulResIndex].res.resProperty.ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.ulPropTag);
+            aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag);
+            break ;
+        case RES_SIZE :
+            aRestriction[ulResIndex].res.resSize.ulPropTag = 
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resSize.ulPropTag);
+            break ;
+        case RES_COMPAREPROPS :
+            aRestriction[ulResIndex].res.resCompareProps.ulPropTag1 =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag1);
+            aRestriction[ulResIndex].res.resCompareProps.ulPropTag2 =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag2);
+            break ;
+        case RES_NOT :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resNot.lpRes);
+            break;
+        case RES_AND :
+            CorrectRestriction(aMapiProp,
+                                aRestriction[ulResIndex].res.resAnd.cRes,
+                                aRestriction[ulResIndex].res.resAnd.lpRes);
+            break;
+        case RES_OR :
+            CorrectRestriction(aMapiProp,
+                                aRestriction[ulResIndex].res.resOr.cRes,
+                                aRestriction[ulResIndex].res.resOr.lpRes);
+            break;
+
+        case RES_COMMENT :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resComment.lpRes);
+            aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag =
+                GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag);
+            break;
+        case RES_SUBRESTRICTION :
+            CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resSub.lpRes);
+            break;
+        default:
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+BOOL nsMapiAddressBook::Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList)
+{
+    if (!aRestriction)
+        return FALSE;
+
+    ULONG conditionType = 0 ;
+
+    nsMapiEntryArray listOut;
+    ULONG listindex=0;
+    
+    nsMapiEntryArray listDel;
+    ULONG delindex=0;
+
+    ULONG listsize;
+    ULONG resCount = 0;
+    ULONG resIndex = 0;
+
+    listsize = aList->GetSize();
+    conditionType = aRestriction->rt;
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+    case RES_BITMASK  :
+    case RES_CONTENT :
+    case RES_PROPERTY :
+    case RES_SIZE :
+    case RES_COMPAREPROPS :
+    case RES_COMMENT :
+    case RES_SUBRESTRICTION :
+        {
+            while(listindex < aList->GetSize())
+            {
+                if (!FilterOnOneRow(aList->ElementAt(listindex),aRestriction))
+                    aList->Remove(listindex);
+                else
+                    listindex++;
+            }
+        }
+        break;
+    case RES_NOT :
+        aRestriction->res.resNot.ulReserved = 1;
+    case RES_AND :
+    case RES_OR :
+        {
+            if (conditionType == RES_OR)
+            {
+                for(listindex=0;listindex<aList->GetSize();listindex++)
+                {
+                    listDel.AddItem(aList->ElementAt(listindex));
+                }
+            }
+
+            resCount = aRestriction->res.resAnd.cRes;
+            //notice that SAndRestriction ,SNotRestriction ,SOrRestriction
+            //use the same struct
+            for (resIndex = 0;resIndex < resCount;resIndex++)
+            {
+                //can't call listOut.CleanUp() here
+                //because it will destroy all Element too
+                while(listOut.GetSize())
+                {
+                    listOut.Remove(0);
+                }
+
+                for(listindex=0;listindex<aList->GetSize();listindex++)
+                {
+                    listOut.AddItem(aList->ElementAt(listindex));
+                }
+
+                Filter(&aRestriction->res.resAnd.lpRes[resIndex],&listOut);
+                if (conditionType == RES_NOT)
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        aList->Remove(listOut.ElementAt(listindex));
+                    }
+                }
+                else if (conditionType == RES_AND )
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        if (!aList->IndexOf(listOut.ElementAt(listindex)))
+                        {
+                            aList->Remove(listOut.ElementAt(listindex));
+                        }
+                    }
+                }
+                else if (conditionType == RES_OR )
+                {
+                    for(listindex=0;listindex<listOut.GetSize();listindex++)
+                    {
+                        listDel.Remove(listOut.ElementAt(listindex));
+                    }
+                    if (listDel.GetSize() == 0)
+                    {
+                        break;
+                    }
+                }
+            }
+            if (conditionType == RES_OR)
+            {
+                for(listindex=0;listindex<listDel.GetSize();listindex++)
+                {
+                    aList->Remove(listDel.ElementAt(listindex));
+                }
+            }
+        }
+
+    }
+    while(listDel.GetSize())
+    {
+        listDel.Remove(0);
+    }
+    while(listOut.GetSize())
+    {
+        listOut.Remove(0);
+    }
+
+
+    return TRUE;
+}
+
+BOOL nsMapiAddressBook::FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction)
+{
+    LPMAPIPROP object ;
+    ULONG objType = 0 ;
+    LPSPropValue realValue = NULL ;
+    LPSPropValue resValue  = NULL ;
+     ULONG valueCount = 0 ;
+   
+    mLastError = OpenEntry(aEntry->mByteCount, aEntry->mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                         (IUnknown **)&object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    
+    ULONG conditionType = 0 ;
+    conditionType = aRestriction->rt;
+
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resExist.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = NULL;
+        break ;
+    case RES_CONTENT :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resContent.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = aRestriction->res.resContent.lpProp;
+        break ;
+    case RES_PROPERTY :
+        if (!GetMAPIProperties(*aEntry,&aRestriction->res.resProperty.ulPropTag,1,realValue,valueCount)) 
+            return FALSE;
+        resValue = aRestriction->res.resProperty.lpProp;
+        break ;
+    case RES_BITMASK  :
+        return FALSE; //not support
+        break ;
+    case RES_SIZE :
+        return FALSE;//not been used now
+        break ;
+    case RES_COMPAREPROPS :
+        return FALSE;//not been used now
+        break ;
+    case RES_NOT :
+        return FALSE;//not need care here
+        break;
+    case RES_AND :
+        return FALSE;//not need care here
+        break;
+    case RES_OR :
+        return FALSE;//not need care here
+        break;
+    case RES_COMMENT :
+        return TRUE;//comment
+        break;
+    case RES_SUBRESTRICTION :
+        return FALSE;//not been used now
+        break ;
+}
+    return AtomyFilter(aRestriction,realValue,resValue);
+
+}
+
+BOOL nsMapiAddressBook::AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue)
+{
+    ULONG conditionType = 0 ;
+    conditionType = aRestriction->rt;
+
+    BOOL bTagEq=(aRealValue &&
+                PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) && 
+                aFilterValue;
+                // PROP_TYPE( aRealValue->ulPropTag ) == PROP_TYPE( aFilterValue->ulPropTag ));
+    switch (conditionType) 
+    {
+    case RES_EXIST  :
+        return (aRealValue && PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) ;
+        break ;
+    case RES_CONTENT :
+        if (bTagEq)
+        {
+            switch(aRestriction->res.resContent.ulFuzzyLevel)
+            {
+            case FL_FULLSTRING :
+                return !stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA);
+                break;
+            case FL_PREFIX :
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == aRealValue->Value.lpszA;
+                break;
+            case FL_SUBSTRING :
+            default:
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                break;
+            }
+        }
+        return FALSE;
+        break ;
+    case RES_PROPERTY :
+        if (bTagEq)
+        {
+            switch(aRestriction->res.resProperty.relop)
+            {
+            case RELOP_GE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) >= 0;
+                break;
+            case RELOP_GT :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) > 0;
+                break;
+            case RELOP_LE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) <= 0;
+                break;
+            case RELOP_LT :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) < 0;
+                break;
+            case RELOP_EQ :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == 0;
+                break;
+            case RELOP_NE :
+                return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != 0;
+                break;
+            case RELOP_RE :
+            default:
+                return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                break;
+
+            }
+        }
+        return FALSE;
+        break ;
+    case RES_BITMASK  :
+        return FALSE; //not support
+        break ;
+    case RES_SIZE :
+        return FALSE;//not been used now
+        break ;
+    case RES_COMPAREPROPS :
+        return FALSE;//not been used now
+        break ;
+    case RES_NOT :
+        return FALSE;//not need care here
+        break;
+    case RES_AND :
+        return FALSE;//not need care here
+        break;
+    case RES_OR :
+        return FALSE;//not need care here
+        break;
+    case RES_COMMENT :
+        return TRUE;//comment
+        break;
+    case RES_SUBRESTRICTION :
+        return FALSE;//not been used now
+        break ;
+    }
+    return TRUE;
+}
+
+BOOL nsMapiAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                nsMapiEntryArray *aList, ULONG aMapiType)
+{
+    if (aList)
+        aList->CleanUp();
+
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> pFolder;
+    nsCString cs;
+    aParent.ToString(cs);
+    
+    mLastError = OpenEntry(aParent.mByteCount,     aParent.mEntryId,
+                    0, MAPI_BEST_ACCESS, &objType, pFolder);
+    if (HR_FAILED(mLastError))
+    {
+        PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&pFolder,PR_MESSAGE_CLASS);
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+    {
+        HRESULT             hr;
+        LPSPropValue aValue = NULL ;
+        ULONG aValueCount = 0 ;
+
+        LPSPropTagArray properties = NULL ;
+        mMAPIAllocateBuffer(CbNewSPropTagArray(1),
+                           (void **)&properties);
+        properties->cValues = 1;
+        properties->aulPropTag [0] = GetEmailPropertyTag(*(LPMAPIPROP*)&pFolder,OUTLOOK_EMAIL_LIST1);
+        hr = pFolder->GetProps(properties, 0, &aValueCount, &aValue) ;
+
+        SBinaryArray *sa=&aValue->Value.MVbin;
+
+        LPENTRYID    lpEID;
+        ULONG        cbEID;
+        
+        ULONG idx;
+        nsMapiEntry testEntry;
+        nsCString sClass;
+        for (idx=0;sa->lpbin && idx<sa->cValues ;idx++)
+        {
+            lpEID= (LPENTRYID) sa->lpbin[idx].lpb;
+            cbEID = sa->lpbin[idx].cb;
+            testEntry.Assign(sa->lpbin[idx].cb,NS_REINTERPRET_CAST(LPENTRYID,sa->lpbin[idx].lpb));
+            
+            if (GetPropertyString(testEntry,PR_MESSAGE_CLASS,sClass)) //Error get property
+            {
+                aList->AddItem(cbEID,lpEID);
+            }
+        }
+        Filter(aRestriction,aList);
+    }
+    else
+    {
+        if (aRestriction && !CorrectRestriction(*(LPMAPICONTAINER*)&pFolder,1,aRestriction))
+            return FALSE;
+        mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIContainer, MAPI_BEST_ACCESS, &objType,
+                                         parent) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+
+        mLastError = parent->GetContentsTable(0, contents) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+            return FALSE;
+        }
+        if (aRestriction) {
+            mLastError = contents->Restrict(aRestriction, TBL_BATCH) ;
+            if (HR_FAILED(mLastError)) {
+                PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+                return FALSE ;
+            }
+        }
+        mLastError = contents->SetColumns((LPSPropTagArray)&ContentsColumns, 0);
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        mLastError = contents->GetRowCount(0, &rowCount) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        do {
+            LPSRowSet rowSet = NULL ;
+
+            rowCount = 0 ;
+            mLastError = contents->QueryRows(1, 0, &rowSet) ;
+            if (HR_FAILED(mLastError)) {
+                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+                return FALSE ;
+            }
+            rowCount = rowSet->cRows ;
+            if (rowCount > 0 && aList)
+            {
+                if (aMapiType == 0 || rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)
+                {
+                    SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                    aList->AddItem(currentValue.Value.bin.cb,
+                        NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                }
+                else if (aMapiType == MAPI_DISTLIST)
+                {
+                    if (strcmp("IPM.DistList",rowSet->aRow->lpProps[ContentsColumnMessageClass].Value.lpszA)==0)
+                    {
+                        SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                        aList->AddItem(currentValue.Value.bin.cb,
+                            NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+
+                    }
+}
+
+            }
+            MyFreeProws(rowSet) ;
+        } while (rowCount > 0) ;
+    }
+
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags,
+                                      ULONG aNbProperties, LPSPropValue& aValue,
+                                      ULONG& aValueCount)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    LPSPropTagArray properties = NULL ;
+    ULONG i = 0 ;
+    
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                   NS_REINTERPRET_CAST(void **, &properties));
+    properties->cValues = aNbProperties ;
+    for (i = 0 ; i < aNbProperties ; ++ i)
+    {
+        properties->aulPropTag [i] = GetRealMapiPropertyTag(*(LPMAPIPROP*)&object,aPropertyTags [i],TRUE);
+    }
+    mLastError = object->GetProps(properties, 0 , &aValueCount, &aValue) ;
+    FreeBuffer(properties) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Error get props %08x.\n", mLastError)) ;
+    }
+    return HR_SUCCEEDED(mLastError);
+}
+
+BOOL nsMapiAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                      LPSPropValue& aValues)
+{
+    nsMapiInterfaceWrapper<LPMESSAGE> object;
+    ULONG objType = 0 ;
+    LPSPropProblemArray problems = NULL ;
+    ULONG i = 0 ;
+
+    LPMDB lpMsgStore=GetMsgStore(aObject);
+    
+    if (!lpMsgStore)
+    {
+        return FALSE;
+    }
+    mLastError = lpMsgStore->OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                         object) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    for (i = 0 ; i < aNbProperties ; ++ i)
+    {
+        aValues[i].ulPropTag = GetRealMapiPropertyTag(*(LPMESSAGE*)&object,aValues[i].ulPropTag,TRUE);
+    }
+    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (problems) {
+        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+            PRINTF(("Problem %d: index %d code %08x.\n", i,
+                problems->aProblem [i].ulIndex,
+                problems->aProblem [i].scode)) ;
+        }
+    }
+    mLastError = object->SaveChanges(0) ;
+    if (MAPI_E_OBJECT_CHANGED == mLastError)
+    {
+        mLastError = object->SaveChanges(FORCE_SAVE ) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsMapiAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+{
+    return FALSE ;
+}
+
+BOOL nsMapiAddressBook::IsOK(void)
+{
+    return mRootSession && mLibUsage;
+}
+
 BOOL nsMapiAddressBook::Initialize(void)
 {
-    if (mAddressBook) { return TRUE ; }
+
     nsAutoLock guard(mMutex) ;
 
     if (!LoadMapiLibrary()) {
         PRINTF(("Cannot load library.\n")) ;
         return FALSE ;
     }
-    mAddressBook = mRootBook ; 
-    return TRUE ;
+    return TRUE;
 }
 
 void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
@@ -182,7 +1109,803 @@
     mMAPIFreeBuffer(aBuffer) ;
 }
 
+ULONG nsMapiAddressBook::GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID)
+{
+    static GUID emailGUID =
+    {
+       0x00062004, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
+    };
+
+
+  MAPINAMEID mapiNameID;
+  mapiNameID.lpguid = &emailGUID;
+  mapiNameID.ulKind = MNID_ID;
+  mapiNameID.Kind.lID = nameID;
+
+  LPMAPINAMEID lpMapiNames = &mapiNameID;
+  LPSPropTagArray lpMailTagArray = NULL;
+
+  HRESULT result = lpProp->GetIDsFromNames(1L, &lpMapiNames, 0, &lpMailTagArray);
+  if (result == S_OK)
+  {
+    ULONG lTag = lpMailTagArray->aulPropTag[0];
+    mMAPIFreeBuffer(lpMailTagArray);
+    return lTag;
+  }
+  return 0L;
+}
+ULONG nsMapiAddressBook::GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest)
+{
+    LPSPropValue addr;
+    ULONG        upRealTag=aPropertyTag;
+    ULONG        lSize=sizeof(TagMaps) / sizeof(TagMap);
+    
+    for(int i=0; i<lSize; i++)
+    {
+        if (TagMaps[i].AddressTag == aPropertyTag)
+        {
+
+            ULONG kPriEmailColumn=GetEmailPropertyTag(lpProp,TagMaps[i].NameID);
+            if (aTest)
+            {
+                if (PR_DISPLAY_NAME_A == aPropertyTag)
+                {
+                    //We need not change PR_DISPLAY_NAME_A tag if we are not using an address
+                    LPSPropValue msgClass=GetMapiProperty(lpProp,PR_MESSAGE_CLASS);
+                    if (msgClass && !strcmp("IPM.Contact",msgClass->Value.lpszA))
+                    {
+                        if (kPriEmailColumn)
+                            upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                    }
+                    else
+                    {
+                        FreeBuffer(msgClass);
+                        upRealTag = aPropertyTag;
+                    }
+                }
+                else //PR_DISPLAY_NAME_A == aPropertyTag
+                {
+                    addr=GetMapiProperty(lpProp,aPropertyTag);
+                    if (!addr || PROP_TYPE( addr->ulPropTag) == PT_ERROR ||
+                        addr->Value.l == MAPI_E_NOT_FOUND)
+                    {
+                        if (kPriEmailColumn)
+                            upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                    }
+                }
+            }
+            else //aTest
+            {
+                if (kPriEmailColumn)
+                    upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+            }
+      
+            break; //we find it,exit
+        }
+    }
+
+    return upRealTag;
+}
+
+BOOL nsMapiAddressBook::GetPropertyLong(const nsMapiEntry& aObject,
+                                    ULONG aPropertyTag,
+                                    ULONG& aValue)
+{
+    aValue = 0 ;
+    LPSPropValue values = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (PR_OBJECT_TYPE == aPropertyTag)
+    {
+        nsMapiInterfaceWrapper<LPMAPIFOLDER> pFolder ;
+        ULONG objType=0;
+        mLastError = OpenEntry(aObject.mByteCount,aObject.mEntryId,
+                         NULL,MAPI_BEST_ACCESS,&objType, pFolder);
+        if (HR_FAILED(mLastError))
+        {
+            PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+            return FALSE;
+        }
+        LPSPropValue msgClass=GetMapiProperty(*(LPMAPIFOLDER*)&pFolder,PR_MESSAGE_CLASS);
+        if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        {
+            FreeBuffer(msgClass);
+            aValue = MAPI_DISTLIST;
+            return TRUE;
+        }
+    }
 
+    if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) 
+        return FALSE ;
 
+    if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_LONG) {
+        aValue = values->Value.ul ;
+    }
+    FreeBuffer(values) ;
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                                    WORD& aYear, WORD& aMonth, WORD& aDay)
+{
+    aYear = 0;
+    aMonth = 0;
+    aDay = 0;
+    LPSPropValue values = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount))
+        return FALSE ;
+
+    if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
+        SYSTEMTIME readableTime ;
+        FILETIME   localTime ;
+        FileTimeToLocalFileTime(&values->Value.ft,&localTime);
+        if (FileTimeToSystemTime(&localTime, &readableTime)) {
+            aYear = readableTime.wYear ;
+            aMonth = readableTime.wMonth ;
+            aDay = readableTime.wDay ;
+        }
+    }
+    FreeBuffer(values) ;
+    return TRUE ;
+}
+
+HRESULT     nsMapiAddressBook::OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    )
+{
+
+    int err;
+    HRESULT rv;
+    __try
+    {
+        rv=mRootSession->OpenEntry(cbEntryID,
+                    lpEntryID,
+                    lpInterface,
+                    ulFlags ,
+                    lpulObjType,
+                    lppUnk
+                    );
+    }__except(err)
+    {
+        return (-1);
+    }
+
+    if (HR_FAILED(rv) && !m_MDBArray.Count())
+    {
+        //There are no openned Message store,so we have to open them all
+        nsMapiEntryArray aFolders;
+        if (GetFolders(aFolders))
+        {
+            __try
+            {
+                rv=mRootSession->OpenEntry(cbEntryID,
+                            lpEntryID,
+                            lpInterface,
+                            ulFlags ,
+                            lpulObjType,
+                            lppUnk
+                            );
+            }__except(err)
+            {
+                return (-1);
+            }
+        }
+    }
+    return rv;
+
+}
+
+BOOL nsMapiAddressBook::AddEntryToList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+        return FALSE;
+    
+    LPMDB lpMsgStore=GetMsgStore(parentEntry);
+    
+    if (!lpMsgStore)
+        return FALSE;
+    mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))       
+        return FALSE ;
+    
+
+    /*
+    When add mail address to distlist,Mapi need update 2 tag.
+    */
+    //update OUTLOOK_EMAIL_LIST1
+    ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+    SBinaryArray oldChilds;
+    LPSBinary    bins=NULL;
+    SBinaryArray newChilds;
+    LPSPropValue oldChildValue = NULL ;
+    ULONG valueCount = 0 ;
+
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChilds = oldChildValue->Value.MVbin;
+        newChilds.cValues=oldChilds.cValues + 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+        for (ULONG i=0;i<oldChilds.cValues;i++)
+        {
+            newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+            newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+        }
+    }
+    else
+    {
+        newChilds.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+    }
+
+    nsMapiEntry orgEntryID;
+    if (!GetPropertyBin(aNewEntry,
+        GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_ORGID) | PT_BINARY,
+        orgEntryID))
+    {
+        return FALSE;
+    }
+    newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+    newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+
+    SPropValue childs;
+    childs.ulPropTag = listTag;
+    childs.Value.MVbin = newChilds;
+
+    LPSPropProblemArray problems = NULL ;
+    mLastError = container->SetProps(1, &childs, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    //update OUTLOOK_EMAIL_LIST2
+    listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+    
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChilds = oldChildValue->Value.MVbin;
+        newChilds.cValues=oldChilds.cValues + 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+        for (ULONG i=0;i<oldChilds.cValues;i++)
+        {
+            newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+            newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+        }
+    }
+    else
+    {
+        newChilds.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+    }
+
+    /*
+    Need more work here.
+    There are two kind of mail address in outlook DistList.
+    One is sample,not include in parent folder.
+    The other is a link to a unattached address in parents folders.
+    Currently we can only add first kind of address to a outlook distlist.
+    */
+    
+    newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+    newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+
+    childs.ulPropTag = listTag;
+    childs.Value.MVbin = newChilds;
+
+    mLastError = container->SetProps(1, &childs, &problems) ;
+    if (HR_FAILED(mLastError))
+    {
+        PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mMAPIFreeBuffer(bins);
+
+    mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    return TRUE ;
+}
+BOOL nsMapiAddressBook::DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+        return FALSE;
+
+    LPMDB lpMsgStore=GetMsgStore(parentEntry);
+    if (!lpMsgStore)
+        return FALSE;
+
+    mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))
+        return FALSE ;
+    /*
+    When delete mail address from distlist,Mapi need update 2 tag.
+    */
+    //update OUTLOOK_EMAIL_LIST1
+    ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+
+    SBinaryArray oldChilds;
+    LPSBinary    bins=NULL;
+    SBinaryArray newChilds;
+    LPSPropValue oldChildValue = NULL ;
+    ULONG valueCount = 0 ;
+
+    newChilds.lpbin=NULL;
+
+    ULONG lDeleteEntry=0;
+    ULONG newIndex=0;
+    ULONG oldIndex=0;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+    
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChilds = oldChildValue->Value.MVbin;
+        newChilds.cValues=oldChilds.cValues - 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+        for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+        {
+            if ( oldChilds.lpbin[oldIndex].cb == aNewEntry.mByteCount &&
+                !memcmp((void*)(oldChilds.lpbin[oldIndex].lpb+4),
+                        (void*)(aNewEntry.mEntryId->ab),
+                        oldChilds.lpbin[oldIndex].cb-4))
+            {
+                lDeleteEntry=oldIndex;
+            }
+            else
+            {
+                newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                newIndex++;
+            }
+        }
+    }
+    else
+        return FALSE;
+
+
+    SPropValue childs;
+    LPSPropProblemArray problems = NULL ;
+    
+    if (newChilds.cValues == 0)
+    {
+        SPropTagArray delTags;
+        delTags.cValues = 1;
+        delTags.aulPropTag[0] = listTag;
+
+        mLastError = container->DeleteProps(&delTags, &problems) ;
+    }
+    else
+    {
+        childs.ulPropTag = listTag;
+        childs.Value.MVbin = newChilds;
+        mLastError = container->SetProps(1, &childs, &problems) ;
+    }
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    //update OUTLOOK_EMAIL_LIST2
+    listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+    if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+    {
+        PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+        return FALSE;
+    }
+
+    newIndex=0;
+    if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+    {
+        oldChilds = oldChildValue->Value.MVbin;
+        newChilds.cValues=oldChilds.cValues - 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+        for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+        {
+            if (oldIndex != lDeleteEntry)
+            {
+                newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                newIndex++;
+            }
+        }
+    }
+    else
+    {
+        newChilds.cValues = 1;
+        mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+        newChilds.lpbin = bins;
+    }
 
 
+    
+    if (newChilds.cValues == 0)
+    {
+        SPropTagArray delTags;
+        delTags.cValues = 1;
+        delTags.aulPropTag[0] = listTag;
+
+        mLastError = container->DeleteProps(&delTags, &problems) ;
+    }
+    else
+    {
+        childs.ulPropTag = listTag;
+        childs.Value.MVbin = newChilds;
+        mLastError = container->SetProps(1, &childs, &problems) ;
+    }
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mMAPIFreeBuffer(bins);
+
+    mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         (IUnknown **)&object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue *parentID=GetMapiProperty(*(LPMAPIPROP*)&object, PR_PARENT_ENTRYID);
+
+    if (parentID->Value.l == MAPI_E_NOT_FOUND)
+        return FALSE;
+    aParentEntry.Assign(parentID->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, parentID->Value.bin.lpb));
+    return TRUE;
+}
+BOOL nsMapiAddressBook::CreateEntryInList(const nsMapiEntry& aDistlist, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+    ULONG objType = 0 ;
+
+    nsMapiEntry parentEntry;
+    if (!GetEntryParent(aDistlist,parentEntry))
+    {
+        return FALSE;
+    }
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+    if (!CreateEntry(parentEntry,aNewEntry)) //Create a entry in parent folder
+        return FALSE;
+
+    return AddEntryToList(aDistlist,aNewEntry);
+}
+
+BOOL nsMapiAddressBook::CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        return CreateEntryInList(aParent,aNewEntry);        //Create entry in DistList
+    
+    LPMDB lpMsgStore=GetMsgStore(aParent);
+    
+    if (!lpMsgStore)
+        return FALSE;
+    
+    mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError))
+        return FALSE;
+    
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+
+    mLastError = container->CreateMessage(&IID_IMessage,
+                                        0,
+                                        newEntry) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue messageclass ;
+    LPSPropProblemArray problems = NULL ;
+    nsCString tempName ;
+
+    messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+    tempName.Assign("IPM.Contact") ;
+    messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+    mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set temporary name %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    SPropTagArray property ;
+    LPSPropValue value = NULL ;
+    ULONG valueCount = 0 ;
+
+    property.cValues = 1 ;
+    property.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+    if (HR_FAILED(mLastError) || valueCount != 1) {
+        PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+    FreeBuffer(value) ;
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+
+    LPMDB lpMsgStore=GetMsgStore(aParent);
+    if (!lpMsgStore)
+        return FALSE;
+    mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    lpMsgStore->Release();
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+    mLastError = container->CreateMessage(&IID_IMAPIProp,
+                                        0,
+                                        newEntry) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    SPropValue messageclass ;
+    LPSPropProblemArray problems = NULL ;
+    nsCString tempName ;
+
+    messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+    tempName.Assign("IPM.DistList") ;
+    messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+    mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set PR_MESSAGE_CLASS_A %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    ULONG valueCount = 0 ;
+    SPropTagArray property ;
+    LPSPropValue value = NULL ;
+
+    property.cValues = 1 ;
+    property.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+    if (HR_FAILED(mLastError) || valueCount != 1) {
+        PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+
+    FreeBuffer(value) ;
+    return TRUE ;
+}
+
+
+BOOL nsMapiAddressBook::CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource,
+                              nsMapiEntry& aTarget)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> targetFolder ;
+    ULONG objType = 0 ;
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+    {
+        //Add Entry To DistList
+        if (!AddEntryToList(aContainer,aSource))
+            return FALSE;
+        aTarget.Assign(aSource.mByteCount,aSource.mEntryId);
+        return TRUE;
+    }
+
+    SBinary entry ;
+    SBinaryArray entryArray ;
+
+    entry.cb = aSource.mByteCount ;
+    entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aSource.mEntryId) ;
+    entryArray.cValues = 1 ;
+    entryArray.lpbin = &entry ;
+ 
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         container) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    mLastError = OpenEntry(aTarget.mByteCount, aTarget.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                         targetFolder) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open Target folder %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+
+    nsMapiInterfaceWrapper<LPMAPIPROP> newEntry ;
+
+    mLastError = container->CopyMessages(&entryArray,
+                                        &IID_IMessage,
+                                        (void*)&targetFolder,
+                                        0,
+                                        NULL,
+                                        NULL) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    return TRUE ;
+}
+
+BOOL nsMapiAddressBook::DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+    ULONG objType = 0 ;
+    SBinary entry ;
+    SBinaryArray entryArray ;
+
+    
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                         object) ;
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+
+    if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+        return DeleteEntryFromList(aContainer,aEntry);      //Delete Entry from DistList
+
+    LPMDB lpMsgStore=GetMsgStore(aContainer);
+    if (!lpMsgStore)
+        return FALSE;
+
+    mLastError = lpMsgStore->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                         &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType, 
+                                         container) ;
+    lpMsgStore->Release();
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    entry.cb = aEntry.mByteCount ;
+    entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aEntry.mEntryId) ;
+    entryArray.cValues = 1 ;
+    entryArray.lpbin = &entry ;
+    mLastError = container->DeleteMessages(&entryArray, 0,0,0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot delete entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    return TRUE ;
+}
+
+//Use to open message store in write mode
+LPMDB nsMapiAddressBook::GetMsgStore(const nsMapiEntry& aEntry)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object;
+    ULONG objType=0;
+
+    mLastError = OpenEntry(aEntry.mByteCount, aEntry.mEntryId,
+                                         &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                         object) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    SPropValue *svMsgSore=GetMapiProperty( *(LPMAPIPROP*)&object, PR_STORE_ENTRYID);;
+
+    LPMDB  lpMsgStore=NULL;
+    mLastError=mRootSession->OpenMsgStore(0,
+                              svMsgSore->Value.bin.cb,
+                              (ENTRYID*)svMsgSore->Value.bin.lpb,
+                              &IID_IMsgStore,
+                              MAPI_BEST_ACCESS  ,
+                              &lpMsgStore);
+
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open MsgStore %08x.\n", mLastError)) ;
+        return NULL ;
+    }
+    
+    return lpMsgStore;
+}
diff -ru misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h
--- misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2001-09-28 16:06:25.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2005-01-09 13:23:33.437500000 -0500
@@ -40,12 +40,42 @@
 
 #include "nsAbWinHelper.h"
  
+struct TagMap
+{
+    ULONG AddressTag;
+    ULONG NameID;
+    ULONG TypeMask;
+};
 class nsMapiAddressBook : public nsAbWinHelper
 {
 public :
     nsMapiAddressBook(void) ;
     virtual ~nsMapiAddressBook(void) ;
 
+    // Get the top address books
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+
+    // Get a default address book container
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+    // Is the helper correctly initialised?
+    virtual BOOL IsOK(void);
+    virtual BOOL GetPropertyLong(const nsMapiEntry& aObject,
+                                    ULONG aPropertyTag,
+                                    ULONG& aValue);
+    // Get the value of a MAPI property of type SYSTIME
+    virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                         WORD& aYear, WORD& aMonth, WORD& aDay);
+    // Create entry in the address book
+    virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Delete an entry in the address book
+    virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
+    // Create a distribution list in the address book
+    virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+    // Copy an existing entry in the address book
+    virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+
+    static void FreeMapiLibrary(void) ;
+
 protected :
     // Class members to handle the library/entry points
     static HMODULE mLibrary ;
@@ -67,19 +97,77 @@
     static BOOL mInitialized ;
     static BOOL mLogonDone ;
     static LPMAPISESSION mRootSession ;
-    static LPADRBOOK mRootBook ;
+
 
     // Load the MAPI environment
     BOOL Initialize(void) ;
+
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    );
+ 
+
+    // Retrieve the contents of a container, with an optional restriction
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) ;
+    // Retrieve the values of a set of properties on a MAPI object
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                           ULONG aNbProperties,
+                           LPSPropValue& aValues, ULONG& aValueCount) ;
+    // Set the values of a set of properties on a MAPI object
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues);
+
+
     // Allocation of a buffer for transmission to interfaces
     virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) ;
     // Library management 
     static BOOL LoadMapiLibrary(void) ;
-    static void FreeMapiLibrary(void) ;
+
+    BOOL HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
+    LPSPropValue GetMapiProperty( LPMAPIPROP pProp, ULONG tag);
+    BOOL GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal=FALSE);
+    BOOL HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
+    BOOL IterateHierarchy(IMAPIContainer * pFolder, nsMapiEntryArray& aFolders,ULONG flags=0);
+    ULONG GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID);
+    ULONG GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest=FALSE);
+    LPMDB GetMsgStore(const nsMapiEntry& aEntry);
+    BOOL CreateEntryInList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry);
+    BOOL AddEntryToList(const nsMapiEntry& aParent,const nsMapiEntry& aNewEntry);
+    BOOL DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry);
+    BOOL GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry);
+    BOOL CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction);
+
+    //filter
+    BOOL Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList);
+    BOOL FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction);
+    BOOL AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue);
+
+    void AddToMDBArray(LPMDB aMDB)
+    {
+        m_MDBArray.AppendElement(aMDB);
+    }
+    void CleanUpMDB()
+    {
+        LPMDB mdb;
+        for (int i = 0; i < m_MDBArray.Count(); i++)
+        {
+            mdb = (LPMDB)m_MDBArray.ElementAt(i);
+            mdb->Release();
+        }
+        m_MDBArray.Clear();
+    }
 
 private :
+    //use to keep all openned MsgStore,if we not open a message store,we can't open any thing on it
+    //so we have to kill message stores openned
+    nsVoidArray        m_MDBArray; 
 } ;
 
 #endif // nsMapiAddressBook_h___
diff -ru misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp
--- misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2001-10-30 02:59:16.000000000 -0500
+++ misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2005-01-09 13:23:33.453125000 -0500
@@ -47,6 +47,22 @@
 
 #define PRINTF(args) PR_LOG(gWabAddressBookLog, PR_LOG_DEBUG, args)
 
+enum
+{
+    ContentsColumnEntryId = 0,
+    ContentsColumnObjectType,
+    ContentsColumnsSize
+} ;
+
+static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+{
+    ContentsColumnsSize,
+    {
+        PR_ENTRYID,
+        PR_OBJECT_TYPE
+    }
+} ;
+
 HMODULE nsWabAddressBook::mLibrary = NULL ;
 PRInt32 nsWabAddressBook::mLibUsage = 0 ;
 LPWABOPEN nsWabAddressBook::mWABOpen = NULL ;
@@ -95,7 +111,7 @@
 MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
 
 nsWabAddressBook::nsWabAddressBook(void)
-: nsAbWinHelper()
+: nsAbWinHelper(),mAddressBook(NULL)
 {
     BOOL result = Initialize() ;
 
@@ -110,9 +126,254 @@
     MOZ_COUNT_DTOR(nsWabAddressBook) ;
 }
 
+BOOL nsWabAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+{
+    aFolders.CleanUp() ;
+    nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+    SRestriction restriction ;
+    SPropTagArray folderColumns ;
+
+    mLastError = OpenEntry(0, NULL, NULL, 0, &objType,
+                                         rootFolder);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot open root %08x.\n", mLastError));
+        return FALSE;
+    }
+    mLastError = rootFolder->GetHierarchyTable(0, folders);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get hierarchy %08x.\n", mLastError));
+        return FALSE;
+    }
+    // We only take into account modifiable containers,
+    // otherwise, we end up with all the directory services...
+    restriction.rt = RES_BITMASK ;
+    restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
+    restriction.res.resBitMask.relBMR = BMR_NEZ ;
+    restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
+    mLastError = folders->Restrict(&restriction, 0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
+    }
+    folderColumns.cValues = 1 ;
+    folderColumns.aulPropTag [0] = PR_ENTRYID ;
+    mLastError = folders->SetColumns(&folderColumns, 0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = folders->GetRowCount(0, &rowCount) ;
+    if (HR_SUCCEEDED(mLastError)) {
+        do {
+            LPSRowSet rowSet = NULL ;
+
+            rowCount = 0 ;
+            mLastError = folders->QueryRows(1, 0, &rowSet) ;
+            if (HR_SUCCEEDED(mLastError)) {
+                rowCount = rowSet->cRows ;
+                if (rowCount > 0) {
+                    SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
+                    
+                    aFolders.AddItem(currentValue.Value.bin.cb,
+                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                }
+                MyFreeProws(rowSet) ;
+            }
+            else {
+                PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+            }
+        } while (rowCount > 0) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+BOOL nsWabAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                nsMapiEntryArray *aList, ULONG aMapiType)
+{
+    if (aList) { aList->CleanUp(); }
+    nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+    nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+    ULONG objType = 0 ;
+    ULONG rowCount = 0 ;
+
+    mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                         &IID_IMAPIContainer, 0, &objType,
+                                         parent) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    // Here, flags for WAB and MAPI could be different, so this works
+    // only as long as we don't want to use any flag in GetContentsTable
+    mLastError = parent->GetContentsTable(0, contents) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (aRestriction) {
+        mLastError = contents->Restrict(aRestriction, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+    }
+    int entryId = ContentsColumnEntryId ;
+    int objectType = ContentsColumnObjectType ;
+
+    if (aRestriction) 
+    {
+        LPSPropTagArray allColumns = NULL ;
+
+        mLastError = contents->QueryColumns(TBL_ALL_COLUMNS, &allColumns) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot query columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+
+        for (unsigned int j = 0 ; j < allColumns->cValues ; ++ j) {
+            if (allColumns->aulPropTag [j] == PR_ENTRYID) { 
+                entryId = j ; 
+            }
+            else if (allColumns->aulPropTag [j] == PR_OBJECT_TYPE) { 
+                objectType = j ; 
+            }
+        }
+        mLastError = contents->SetColumns(allColumns, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        FreeBuffer(allColumns) ;
+    }
+    else
+    {
+
+        mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+     }    
+    
+    mLastError = contents->GetRowCount(0, &rowCount) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    do {
+        LPSRowSet rowSet = NULL ;
+        
+        rowCount = 0 ;
+        mLastError = contents->QueryRows(1, 0, &rowSet) ;
+        if (HR_FAILED(mLastError)) {
+            PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+            return FALSE ;
+        }
+        rowCount = rowSet->cRows ;
+        if (rowCount > 0 &&
+            (aMapiType == 0 ||
+            rowSet->aRow->lpProps[objectType].Value.ul == aMapiType)) {
+            if (aList) {
+                SPropValue& currentValue = rowSet->aRow->lpProps[entryId] ;
+                
+                aList->AddItem(currentValue.Value.bin.cb,
+                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                
+            }
+        }
+        MyFreeProws(rowSet) ;
+    } while (rowCount > 0) ;
+    return TRUE ;
+}
+
+BOOL nsWabAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                                      ULONG aNbProperties, LPSPropValue& aValue, 
+                                      ULONG& aValueCount)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    IMsgStore * mdb=NULL;
+    ULONG objType = 0 ;
+    LPSPropTagArray properties = NULL ;
+    ULONG i = 0 ;
+    
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, 0, &objType, 
+                                         object) ;
+
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot open entry %08x.\n", mLastError));
+        return FALSE;
+    }
+    AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                   NS_REINTERPRET_CAST(void **, &properties));
+    properties->cValues = aNbProperties;
+    for (i = 0 ; i < aNbProperties ; ++ i) {
+        properties->aulPropTag [i] = aPropertyTags [i];
+    }
+    mLastError = object->GetProps(properties, 0, &aValueCount, &aValue);
+    FreeBuffer(properties);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get props %08x.\n", mLastError));
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsWabAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                      LPSPropValue& aValues)
+{
+    nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+    ULONG objType = 0 ;
+    LPSPropProblemArray problems = NULL ;
+
+    mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                         &IID_IMAPIProp, MAPI_MODIFY, &objType, 
+                                         object) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+        return FALSE ;
+    }
+    if (problems) {
+        for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+            PRINTF(("Problem %d: index %d code %08x.\n", i,
+                problems->aProblem [i].ulIndex,
+                problems->aProblem [i].scode));
+        }
+    }
+    mLastError = object->SaveChanges(0) ;
+    if (HR_FAILED(mLastError)) {
+        PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
+    }
+    return HR_SUCCEEDED(mLastError) ;
+}
+
+BOOL nsWabAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+{
+    LPENTRYID entryId = NULL;
+    ULONG byteCount = 0;
+
+    mLastError = mAddressBook->GetPAB(&byteCount, &entryId);
+    if (HR_FAILED(mLastError)){
+        PRINTF(("Cannot get PAB %08x.\n", mLastError));
+        return FALSE;
+    }
+    aContainer.Assign(byteCount, entryId);
+    FreeBuffer(entryId) ;
+    return TRUE ;
+}
+
+BOOL nsWabAddressBook::IsOK(void)
+{
+    return mAddressBook != NULL ;
+}
+
 BOOL nsWabAddressBook::Initialize(void)
 {
-    if (mAddressBook) { return TRUE ; }
     nsAutoLock guard(mMutex) ;
 
     if (!LoadWabLibrary()) {
diff -ru misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.h misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.h
--- misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2001-09-28 16:06:25.000000000 -0400
+++ misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2005-01-09 13:23:33.468750000 -0500
@@ -47,6 +47,15 @@
     nsWabAddressBook(void) ;
     virtual ~nsWabAddressBook(void) ;
 
+    // Get the top address books
+    virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+
+    // Get a default address book container
+    virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+    // Is the helper correctly initialised?
+    virtual BOOL IsOK(void);
+    static void FreeWabLibrary(void) ;
+
 protected :
     // Session and address book that will be shared by all instances
     // (see nsMapiAddressBook.h for details)
@@ -57,15 +66,46 @@
     static HMODULE mLibrary ;
     static LPWABOPEN mWABOpen ;
 
+    LPADRBOOK mAddressBook ;
+
     // Load the WAB environment
     BOOL Initialize(void) ;
+
+    virtual HRESULT OpenEntry(ULONG cbEntryID,
+                    LPENTRYID lpEntryID,
+                    LPCIID lpInterface,
+                    ULONG ulFlags,
+                    ULONG FAR * lpulObjType,
+                    LPUNKNOWN FAR * lppUnk
+                    )
+    {
+        return mAddressBook->OpenEntry(cbEntryID,
+                    lpEntryID,
+                    lpInterface,
+                    ulFlags,
+                    lpulObjType,
+                    lppUnk
+                    );
+    }
+ 
+
+    // Retrieve the contents of a container, with an optional restriction
+    virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                     nsMapiEntryArray *aList, ULONG aMapiType) ;
+    // Retrieve the values of a set of properties on a MAPI object
+    virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                           ULONG aNbProperties,
+                           LPSPropValue& aValues, ULONG& aValueCount) ;
+    // Set the values of a set of properties on a MAPI object
+    virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                           LPSPropValue& aValues) ;
+
     // Allocation of a buffer for transmission to interfaces
     virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
     // Destruction of a buffer provided by the interfaces
     virtual void FreeBuffer(LPVOID aBuffer) ;
     // Manage the library
     static BOOL LoadWabLibrary(void) ;
-    static void FreeWabLibrary(void) ;
 
 private :
 } ;
diff -ru misc/mozilla/profile/src/nsProfile.cpp misc/build/mozilla/profile/src/nsProfile.cpp
--- misc/mozilla/profile/src/nsProfile.cpp	2004-04-24 13:15:40.000000000 -0400
+++ misc/build/mozilla/profile/src/nsProfile.cpp	2005-01-09 13:23:33.515625000 -0500
@@ -37,7 +37,9 @@
 
 #include "nscore.h" 
 #include "nsProfile.h"
+#ifdef MOZ_PROFILELOCKING
 #include "nsProfileLock.h"
+#endif
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 
@@ -499,12 +501,14 @@
                 profileURLStr = PROFILE_MANAGER_URL; 
             if (exists)
             {
+#ifdef MOZ_PROFILELOCKING
                 // If the profile is locked, we need the UI
                 nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(curProfileDir));
                 nsProfileLock tempLock;
                 rv = tempLock.Lock(localFile);
                 if (NS_FAILED(rv))
                     profileURLStr = PROFILE_MANAGER_URL;
+#endif
             } 
         }
         else
@@ -1173,7 +1177,7 @@
     }
     else
         isSwitch = PR_FALSE;
-    
+#ifdef MOZ_PROFILELOCKING    
     nsProfileLock localLock;
     nsCOMPtr<nsILocalFile> localProfileDir(do_QueryInterface(profileDir, &rv));
     if (NS_FAILED(rv)) return rv;
@@ -1183,7 +1187,7 @@
         NS_ERROR("Could not get profile directory lock.");
         return rv;
     }
-
+#endif
     nsCOMPtr<nsIObserverService> observerService = 
              do_GetService("@mozilla.org/observer-service;1", &rv);
     NS_ENSURE_TRUE(observerService, NS_ERROR_FAILURE);
@@ -1237,8 +1241,10 @@
         UpdateCurrentProfileModTime(PR_FALSE);        
     }
 
+#ifdef MOZ_PROFILELOCKING    
     // Do the profile switch
     localLock.Unlock(); // gDirServiceProvider will get and hold its own lock
+#endif
     gDirServiceProvider->SetProfileDir(profileDir);  
     mCurrentProfileName.Assign(aCurrentProfile);    
     gProfileDataAccess->SetCurrentProfile(aCurrentProfile);
diff -ru misc/mozilla/security/nss/lib/nss/config.mk misc/build/mozilla/security/nss/lib/nss/config.mk
--- misc/mozilla/security/nss/lib/nss/config.mk	2004-10-15 19:52:33.000000000 -0400
+++ misc/build/mozilla/security/nss/lib/nss/config.mk	2005-01-09 13:23:33.531250000 -0500
@@ -112,7 +112,7 @@
 MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1:/usr/lib/mps'
 endif
 else
-MKSHLIB += -R '$$ORIGIN'
+#MKSHLIB += -R '$$ORIGIN'
 endif
 endif
 
--- misc/build/mozilla/security/nss/lib/nss/nss.def	2004-07-13 10:38:04.000000000 +0800
+++ misc/build/mozilla/security/nss/lib/nss/nss.def	2004-05-20 01:32:27.000000000 +0800
@@ -60,6 +60,7 @@
 CERT_CheckCertValidTimes;
 CERT_CreateCertificateRequest;
 CERT_ChangeCertTrust;
+CERT_DecodeDERCertificate;
 CERT_DecodeDERCrl;
 CERT_DestroyCertificateRequest;
 CERT_DestroyCertList;
diff -ru misc/mozilla/security/nss/lib/softoken/config.mk misc/build/mozilla/security/nss/lib/softoken/config.mk
--- misc/mozilla/security/nss/lib/softoken/config.mk	2004-10-15 19:52:35.000000000 -0400
+++ misc/build/mozilla/security/nss/lib/softoken/config.mk	2005-01-09 13:23:33.546875000 -0500
@@ -86,7 +86,7 @@
 ifeq ($(OS_TARGET),SunOS)
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
+#MKSHLIB += -R '$$ORIGIN'
 endif
 
 ifeq ($(OS_TARGET),WINCE)
--- misc/build/mozilla/security/nss/lib/ckfw/builtins/config.mk	Sat Oct 16 07:52:32 2004
+++ misc/build/mozilla/security/nss/lib/ckfw/builtins/config.mk	Thu Jan 20 21:48:52 2005
@@ -62,6 +62,6 @@
 ifeq ($(OS_TARGET),SunOS)
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
+#MKSHLIB += -R '$$ORIGIN'
 endif
 
--- misc/build/mozilla/security/nss/lib/freebl/Makefile	Sat Oct 16 07:52:33 2004
+++ misc/build/mozilla/security/nss/lib/freebl/Makefile	Thu Jan 20 21:49:40 2005
@@ -182,8 +182,7 @@
 
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
-
+#MKSHLIB += -R '$$ORIGIN'
 ifeq ($(CPU_ARCH),sparc)
 ifndef NS_USE_GCC
 ifdef USE_HYBRID
@@ -199,7 +198,7 @@
 MKSHLIB += -Wl,-B,symbolic,-z,defs,-z,now,-z,text,-M,mapfile.Solaris
 endif # GCC_USE_GNU_LD
 else
-MKSHLIB += -B symbolic -z defs -z now -z text -M mapfile.Solaris
+MKSHLIB += -z defs -z now -z text -M mapfile.Solaris
 endif # NS_USE_GCC
 ifdef USE_PURE_32
 # this builds for Sparc v8 pure 32-bit architecture
diff -u -r misc/build/mozilla/security/nss/lib/smime/config.mk misc/build/mozilla/security/nss/lib/smime/config.mk
--- misc/build/mozilla/security/nss/lib/smime/config.mk	Sat Oct 16 07:52:34 2004
+++ misc/build/mozilla/security/nss/lib/smime/config.mk	Thu Jan 20 21:42:18 2005
@@ -89,6 +89,6 @@
 ifeq ($(OS_TARGET),SunOS)
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
+#MKSHLIB += -R '$$ORIGIN'
 endif
 
diff -u -r misc/build/mozilla/security/nss/lib/ssl/config.mk misc/build/mozilla/security/nss/lib/ssl/config.mk
--- misc/build/mozilla/security/nss/lib/ssl/config.mk	Sat Oct 16 07:52:35 2004
+++ misc/build/mozilla/security/nss/lib/ssl/config.mk	Thu Jan 20 21:42:44 2005
@@ -81,7 +81,7 @@
 ifeq ($(OS_TARGET),SunOS)
 # The -R '$ORIGIN' linker option instructs this library to search for its
 # dependencies in the same directory where it resides.
-MKSHLIB += -R '$$ORIGIN'
+#MKSHLIB += -R '$$ORIGIN'
 endif
 
 endif
--- misc/build/mozilla/gfx/src/gtk/Makefile.in Sun Jan 30 11:10:45 2005
+++ misc/build/mozilla/gfx/src/gtk/Makefile.in Sun Jan 30 11:10:46 2005
@@ -176,6 +176,10 @@
 CXXFLAGS       += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 CFLAGS         += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 
+ifeq ($(OS_ARCH), Darwin)
+EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS)
+endif
+
 ifeq ($(OS_ARCH), SunOS)
 ifndef GNU_CC
 # When using Sun's WorkShop compiler, including
