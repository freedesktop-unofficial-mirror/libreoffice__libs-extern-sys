*** misc/icu/source/common/putil.c	Mon Jul 31 20:14:28 2006
--- misc/build/icu/source/common/putil.c	Tue Nov 13 13:03:51 2007
***************
*** 48,54 ****
  #endif
  
  /* Make sure things like readlink and such functions work. */
! #ifndef _XOPEN_SOURCE_EXTENDED
  #define _XOPEN_SOURCE_EXTENDED 1
  #endif
  
--- 48,55 ----
  #endif
  
  /* Make sure things like readlink and such functions work. */
! /* It is invalid to compile an XPG3, XPG4, XPG4v2 or XPG5 application using c99 */
! #if !defined(_XOPEN_SOURCE_EXTENDED) && __STDC_VERSION__ < 199901L
  #define _XOPEN_SOURCE_EXTENDED 1
  #endif
  
*** misc/icu/source/common/unicode/pwin32.h	Tue Aug 29 23:34:38 2006
--- misc/build/icu/source/common/unicode/pwin32.h	Tue Nov 13 13:03:51 2007
***************
*** 266,273 ****
--- 266,278 ----
  #else
  #define U_EXPORT __declspec(dllexport)
  #endif
+ #ifdef __MINGW32__
+ #define U_EXPORT2
+ #define U_IMPORT
+ #else
  #define U_EXPORT2 __cdecl
  #define U_IMPORT __declspec(dllimport)
+ #endif
  
  /*===========================================================================*/
  /* Code alignment and C function inlining                                    */
*** misc/icu/source/common/unicode/rbbi.h	Fri Aug 11 07:46:40 2006
--- misc/build/icu/source/common/unicode/rbbi.h	Tue Nov 13 13:03:51 2007
***************
*** 611,622 ****
--- 611,624 ----
      virtual int32_t getBreakType() const;
  #endif
  
+ public:
      /**
        * Set the type of the break iterator.
        * @internal
        */
      virtual void setBreakType(int32_t type);
  
+ protected:
      /**
        * Common initialization function, used by constructors and bufferClone.
        *   (Also used by DictionaryBasedBreakIterator::createBufferClone().)
*** misc/icu/source/common/unicode/umachine.h	Tue Feb  7 02:54:16 2006
--- misc/build/icu/source/common/unicode/umachine.h	Tue Nov 13 13:03:51 2007
***************
*** 322,328 ****
   */
  
  /* Define UChar to be compatible with wchar_t if possible. */
! #if U_SIZEOF_WCHAR_T==2
      typedef wchar_t UChar;
  #else
      typedef uint16_t UChar;
--- 322,328 ----
   */
  
  /* Define UChar to be compatible with wchar_t if possible. */
! #if U_SIZEOF_WCHAR_T==2 && !defined(__MINGW32__)
      typedef wchar_t UChar;
  #else
      typedef uint16_t UChar;
*** misc/icu/source/common/unicode/unistr.h	Tue Aug 29 23:52:50 2006
--- misc/build/icu/source/common/unicode/unistr.h	Tue Nov 13 13:03:51 2007
***************
*** 3280,3286 ****
  //========================================
  inline int8_t
  UnicodeString::doCompare(int32_t start,
!               int32_t length,
                const UnicodeString& srcText,
                int32_t srcStart,
                int32_t srcLength) const
--- 3280,3286 ----
  //========================================
  inline int8_t
  UnicodeString::doCompare(int32_t start,
!               int32_t _length,
                const UnicodeString& srcText,
                int32_t srcStart,
                int32_t srcLength) const
***************
*** 3289,3295 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompare(start, length, srcText.fArray, srcStart, srcLength);
    }
  }
  
--- 3289,3295 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompare(start, _length, srcText.fArray, srcStart, srcLength);
    }
  }
  
***************
*** 3374,3380 ****
  
  inline int8_t
  UnicodeString::doCompareCodePointOrder(int32_t start,
!                                        int32_t length,
                                         const UnicodeString& srcText,
                                         int32_t srcStart,
                                         int32_t srcLength) const
--- 3374,3380 ----
  
  inline int8_t
  UnicodeString::doCompareCodePointOrder(int32_t start,
!                                        int32_t _length,
                                         const UnicodeString& srcText,
                                         int32_t srcStart,
                                         int32_t srcLength) const
***************
*** 3383,3389 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompareCodePointOrder(start, length, srcText.fArray, srcStart, srcLength);
    }
  }
  
--- 3383,3389 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompareCodePointOrder(start, _length, srcText.fArray, srcStart, srcLength);
    }
  }
  
***************
*** 3435,3441 ****
  
  inline int8_t
  UnicodeString::doCaseCompare(int32_t start,
!                              int32_t length,
                               const UnicodeString &srcText,
                               int32_t srcStart,
                               int32_t srcLength,
--- 3435,3441 ----
  
  inline int8_t
  UnicodeString::doCaseCompare(int32_t start,
!                              int32_t _length,
                               const UnicodeString &srcText,
                               int32_t srcStart,
                               int32_t srcLength,
***************
*** 3445,3451 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCaseCompare(start, length, srcText.fArray, srcStart, srcLength, options);
    }
  }
  
--- 3445,3451 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCaseCompare(start, _length, srcText.fArray, srcStart, srcLength, options);
    }
  }
  
*** misc/icu/source/common/unicode/ustring.h	Tue Aug 29 23:52:50 2006
--- misc/build/icu/source/common/unicode/ustring.h	Tue Nov 13 13:03:51 2007
***************
*** 918,924 ****
   * </pre>
   * @stable ICU 2.0
   */
! #if U_SIZEOF_WCHAR_T==U_SIZEOF_UCHAR && (U_CHARSET_FAMILY==U_ASCII_FAMILY || (U_SIZEOF_UCHAR == 2 && defined(U_WCHAR_IS_UTF16)))
  #   define U_STRING_DECL(var, cs, length) static const wchar_t var[(length)+1]={ L ## cs }
      /**@stable ICU 2.0 */
  #   define U_STRING_INIT(var, cs, length)
--- 918,924 ----
   * </pre>
   * @stable ICU 2.0
   */
! #if U_SIZEOF_WCHAR_T==U_SIZEOF_UCHAR && (U_CHARSET_FAMILY==U_ASCII_FAMILY || (U_SIZEOF_UCHAR == 2 && defined(U_WCHAR_IS_UTF16))) && !defined(__MINGW32__)
  #   define U_STRING_DECL(var, cs, length) static const wchar_t var[(length)+1]={ L ## cs }
      /**@stable ICU 2.0 */
  #   define U_STRING_INIT(var, cs, length)
*** misc/icu/source/config/mh-darwin	Wed Feb  1 08:52:42 2006
--- misc/build/icu/source/config/mh-darwin	Tue Nov 13 13:03:51 2007
***************
*** 25,31 ****
  SHLIB.cc=	$(CXX) -dynamiclib -dynamic $(CXXFLAGS) $(LDFLAGS)
  
  ## Compiler switches to embed a library name and version information
! LD_SONAME = -Wl,-compatibility_version -Wl,$(SO_TARGET_VERSION_MAJOR) -Wl,-current_version -Wl,$(SO_TARGET_VERSION) -install_name $(notdir $(MIDDLE_SO_TARGET))
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=
--- 25,31 ----
  SHLIB.cc=	$(CXX) -dynamiclib -dynamic $(CXXFLAGS) $(LDFLAGS)
  
  ## Compiler switches to embed a library name and version information
! LD_SONAME = -Wl,-compatibility_version -Wl,$(SO_TARGET_VERSION_MAJOR) -Wl,-current_version -Wl,$(SO_TARGET_VERSION) -install_name @executable_path/$(notdir $(FINAL_SO_TARGET))
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=
*** misc/icu/source/config/mh-irix	Thu Mar 23 19:51:52 2006
--- misc/build/icu/source/config/mh-irix	Tue Nov 13 13:03:52 2007
***************
*** 23,28 ****
--- 23,31 ----
  SHLIB.c=    $(CC) -shared $(DEFS) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS)
  SHLIB.cc=   $(CXX) -shared $(DEFS) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS)
  
+ # Environment variable to set a runtime search path
+ LDLIBRARYPATH_ENVVAR = LD_LIBRARYN32_PATH
+ 
  ## Additional flags when building libraries with thread safety
  THREADSCPPFLAGS = -D_REENTRANT -D_PTHREADS
  LIBCPPFLAGS =
*** misc/icu/source/config/mh-linux	Thu Mar 23 19:51:52 2006
--- misc/build/icu/source/config/mh-linux	Tue Nov 13 13:03:52 2007
***************
*** 20,25 ****
--- 20,33 ----
  LD_RPATH=	
  LD_RPATH_PRE = -Wl,-rpath,
  
+ ## Force RPATH=$ORIGIN to locate own dependencies w/o need for LD_LIBRARY_PATH
+ ## (incl. the C++ runtime libs potentially found in the URE lib dir):
+ ENABLE_RPATH=YES
+ RPATHLDFLAGS=${LD_RPATH_PRE}'$$ORIGIN:$$ORIGIN/../ure-link/lib'
+ 
+ #SH#  ENABLE_RPATH=YES
+ #SH#  RPATHLDFLAGS="${LD_RPATH_PRE}'$$ORIGIN:$$ORIGIN/../ure-link/lib'"
+ 
  ## These are the library specific LDFLAGS
  LDFLAGSICUDT=-nodefaultlibs -nostdlib
  
*** misc/icu/source/config/mh-mingw	Tue Aug 15 10:24:14 2006
--- misc/build/icu/source/config/mh-mingw	Tue Nov 13 13:03:52 2007
***************
*** 54,59 ****
--- 54,62 ----
  STATIC_O = ao
  SO_TARGET_VERSION_SUFFIX = $(SO_TARGET_VERSION_MAJOR)
  
+ STUB_SUFFIX=l
+ LIBICUDT=       -L$(LIBDIR) -L$(top_builddir)/stubdata -l$(STATIC_PREFIX_WHEN_USED)$(ICUPREFIX)$(DATA_STUBNAME)$(ICULIBSUFFIX)$(SO_TARGET_VERSION_MAJOR)l
+ 
  # Static library prefix and file extension
  LIBSICU = $(STATIC_PREFIX)$(ICUPREFIX)
  A = lib
***************
*** 71,77 ****
  
  # The #M# is used to delete lines for icu-config
  # Current full path directory.
! CURR_FULL_DIR=$(shell pwd -W)#M#
  # Current full path directory for use in source code in a -D compiler option.
  CURR_SRCCODE_FULL_DIR=$(subst /,\\\\,$(shell pwd -W))#M#
  
--- 74,83 ----
  
  # The #M# is used to delete lines for icu-config
  # Current full path directory.
! CURR_FULL_DIR=$(subst \,/,$(shell cygpath -aw .))#M#
! SRCDIRW:=$(SRCDIR)
! SRCDIR:=$(foreach p,$(SRCDIR),$(shell cygpath -u $(subst \,/,$(p))))#M#
! DATAFILEPATHS:=$(foreach p,$(DATAFILEPATHS),$(shell cygpath -u $(subst \,/,$(p))))#M#
  # Current full path directory for use in source code in a -D compiler option.
  CURR_SRCCODE_FULL_DIR=$(subst /,\\\\,$(shell pwd -W))#M#
  
*** misc/icu/source/config/mh-solaris	Fri Feb 24 20:31:14 2006
--- misc/build/icu/source/config/mh-solaris	Tue Nov 13 13:03:52 2007
***************
*** 18,33 ****
  
  ## Commands to link
  ## For Sun Workshop, use CC to link to bring in C++ runtime
! LINK.c=		$(CXX) $(CXXFLAGS) $(LDFLAGS)
! LINK.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS)
  
  ## Commands to make a shared library
  SHLIB.c=	$(CC) $(CFLAGS) $(LDFLAGS) -G
! SHLIB.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS) -G
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=	-R
  LD_RPATH_PRE=	
  
  #LIBRARY_PATH_PREFIX=/usr/lib/lwp:
  
--- 18,41 ----
  
  ## Commands to link
  ## For Sun Workshop, use CC to link to bring in C++ runtime
! ## For Sun Workshop, -norunpath stops compiler to record a useless RPATH
! LINK.c=     $(CXX) $(CXXFLAGS) $(LDFLAGS) -norunpath
! LINK.cc=    $(CXX) $(CXXFLAGS) $(LDFLAGS) -norunpath
  
  ## Commands to make a shared library
  SHLIB.c=	$(CC) $(CFLAGS) $(LDFLAGS) -G
! SHLIB.cc=   $(CXX) $(CXXFLAGS) $(LDFLAGS) -G -norunpath
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=	-R
  LD_RPATH_PRE=	
+ 
+ ## Force RPATH=$ORIGIN to locate own dependencies w/o need for LD_LIBRARY_PATH
+ ENABLE_RPATH=YES
+ RPATHLDFLAGS=${LD_RPATH}'$$ORIGIN'
+ 
+ #SH#  ENABLE_RPATH=YES
+ #SH#  RPATHLDFLAGS="${LD_RPATH}'$$ORIGIN'"
  
  #LIBRARY_PATH_PREFIX=/usr/lib/lwp:
  
*** misc/icu/source/data/Makefile.in	Sat Aug 12 00:22:24 2006
--- misc/build/icu/source/data/Makefile.in	Tue Nov 13 13:03:52 2007
***************
*** 344,350 ****
  ifneq ($(ICUDATA_SOURCE_IS_NATIVE_TARGET),YES)
  	@echo "Unpacking $(ICUDATA_SOURCE_ARCHIVE) and generating $@ (list of data files)"
  	@-$(RMV) $@
! 	$(INVOKE) $(BINDIR)/icupkg -d $(BUILDDIR) --list -x \* $(ICUDATA_SOURCE_ARCHIVE) > $@
  else
  	@echo "$@" > $@
  endif
--- 344,350 ----
  ifneq ($(ICUDATA_SOURCE_IS_NATIVE_TARGET),YES)
  	@echo "Unpacking $(ICUDATA_SOURCE_ARCHIVE) and generating $@ (list of data files)"
  	@-$(RMV) $@
! 	$(INVOKE) $(BINDIR)/icupkg -d $(BUILDDIR) --list -x \* $(ICUDATA_SOURCE_ARCHIVE) | grep -v ".cnv" > $@
  else
  	@echo "$@" > $@
  endif
*** misc/icu/source/i18n/windtfmt.cpp	Tue Aug 15 08:48:02 2006
--- misc/build/icu/source/i18n/windtfmt.cpp	Tue Nov 13 13:03:52 2007
***************
*** 232,249 ****
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, buffer, STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, buffer, newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 232,249 ----
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, reinterpret_cast<LPWSTR>(buffer), newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
***************
*** 258,275 ****
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, buffer, STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, buffer, newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 258,275 ----
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, reinterpret_cast<LPWSTR>(buffer), newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
*** misc/icu/source/i18n/winnmfmt.cpp	Thu Aug 17 07:21:06 2006
--- misc/build/icu/source/i18n/winnmfmt.cpp	Tue Nov 13 13:03:52 2007
***************
*** 86,95 ****
      GetLocaleInfoA(lcid, LOCALE_SGROUPING, buf, 10);
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SDECIMAL,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_STHOUSAND, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGNUMBER, (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
--- 86,95 ----
      GetLocaleInfoA(lcid, LOCALE_SGROUPING, buf, 10);
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SDECIMAL,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_STHOUSAND, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGNUMBER, (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
***************
*** 111,126 ****
      GetLocaleInfoA(lcid, LOCALE_SMONGROUPING, buf, sizeof(buf));
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SMONDECIMALSEP,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SMONTHOUSANDSEP, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGCURR,  (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_ICURRENCY, (LPWSTR) &fmt->PositiveOrder, sizeof(UINT));
  
!     fmt->lpCurrencySymbol = NEW_ARRAY(UChar, 8);
      GetLocaleInfoW(lcid, LOCALE_SCURRENCY, (LPWSTR) fmt->lpCurrencySymbol, 8);
  }
  
--- 111,126 ----
      GetLocaleInfoA(lcid, LOCALE_SMONGROUPING, buf, sizeof(buf));
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SMONDECIMALSEP,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SMONTHOUSANDSEP, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGCURR,  (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_ICURRENCY, (LPWSTR) &fmt->PositiveOrder, sizeof(UINT));
  
!     fmt->lpCurrencySymbol = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 8));
      GetLocaleInfoW(lcid, LOCALE_SCURRENCY, (LPWSTR) fmt->lpCurrencySymbol, 8);
  }
  
***************
*** 290,296 ****
              formatInfo.currency.Grouping = 0;
          }
  
!         result = GetCurrencyFormatW(fLCID, 0, nBuffer, &formatInfo.currency, buffer, STACK_BUFFER_SIZE);
  
          if (result == 0) {
              DWORD lastError = GetLastError();
--- 290,296 ----
              formatInfo.currency.Grouping = 0;
          }
  
!         result = GetCurrencyFormatW(fLCID, 0, nBuffer, &formatInfo.currency, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
          if (result == 0) {
              DWORD lastError = GetLastError();
***************
*** 300,306 ****
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetCurrencyFormatW(fLCID, 0, nBuffer,  &formatInfo.currency, buffer, newLength);
              }
          }
      } else {
--- 300,306 ----
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetCurrencyFormatW(fLCID, 0, nBuffer,  &formatInfo.currency, reinterpret_cast<LPWSTR>(buffer), newLength);
              }
          }
      } else {
***************
*** 312,318 ****
              formatInfo.number.Grouping = 0;
          }
  
!         result = GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, buffer, STACK_BUFFER_SIZE);
  
          if (result == 0) {
              if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
--- 312,318 ----
              formatInfo.number.Grouping = 0;
          }
  
!         result = GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
          if (result == 0) {
              if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
***************
*** 320,331 ****
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, buffer, newLength);
              }
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 320,331 ----
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, reinterpret_cast<LPWSTR>(buffer), newLength);
              }
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
*** misc/icu/source/layout/CoverageTables.cpp	Sat May  8 01:28:42 2004
--- misc/build/icu/source/layout/CoverageTables.cpp	Tue Nov 13 13:03:52 2007
***************
*** 44,49 ****
--- 44,53 ----
      le_uint16 count = SWAPW(glyphCount);
      le_uint8 bit = OpenTypeUtilities::highBit(count);
      le_uint16 power = 1 << bit;
+ 
+     if (count == 0)
+         return -1;
+ 
      le_uint16 extra = count - power;
      le_uint16 probe = power;
      le_uint16 index = 0;
*** misc/icu/source/layout/DeviceTables.cpp	Fri Jan 14 18:25:12 2005
--- misc/build/icu/source/layout/DeviceTables.cpp	Tue Nov 13 13:03:52 2007
***************
*** 22,28 ****
      le_uint16 format = SWAPW(deltaFormat) - 1;
      le_int16 result = 0;
      
!     if (ppem >= start && ppem <= SWAPW(endSize)) {
          le_uint16 sizeIndex = ppem - start;
          le_uint16 bits = fieldBits[format];
          le_uint16 count = 16 / bits;
--- 22,29 ----
      le_uint16 format = SWAPW(deltaFormat) - 1;
      le_int16 result = 0;
      
!     if (ppem >= start && ppem <= SWAPW(endSize)
!      && format < sizeof(fieldBits)/sizeof(fieldBits[0])) {
          le_uint16 sizeIndex = ppem - start;
          le_uint16 bits = fieldBits[format];
          le_uint16 count = 16 / bits;
*** misc/icu/source/layout/GXLayoutEngine.cpp	Fri Sep  2 20:22:10 2005
--- misc/build/icu/source/layout/GXLayoutEngine.cpp	Tue Nov 13 13:03:52 2007
***************
*** 39,45 ****
          return 0;
      }
  
!     mapCharsToGlyphs(chars, offset, count, FALSE, rightToLeft, TRUE, glyphStorage, success);
  
      if (LE_FAILURE(success)) {
          return 0;
--- 39,45 ----
          return 0;
      }
  
!     mapCharsToGlyphs(chars, offset, count, rightToLeft, rightToLeft, TRUE, glyphStorage, success);
  
      if (LE_FAILURE(success)) {
          return 0;
*** misc/icu/source/layout/IndicClassTables.cpp	Wed Aug 23 02:12:40 2006
--- misc/build/icu/source/layout/IndicClassTables.cpp	Tue Nov 13 13:03:52 2007
***************
*** 94,100 ****
      _dr, _db, _db, _db, _db, _xx, _xx, _l1, _dl, _xx, _xx, _s1, _s2, _vr, _xx, _xx, // 09C0 - 09CF
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _cn, // 09D0 - 09DF
      _iv, _iv, _dv, _dv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 09E0 - 09EF
!     _ct, _ct, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx                           // 09F0 - 09FA
  };
  
  static const IndicClassTable::CharClass punjCharClasses[] =
--- 94,100 ----
      _dr, _db, _db, _db, _db, _xx, _xx, _l1, _dl, _xx, _xx, _s1, _s2, _vr, _xx, _xx, // 09C0 - 09CF
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _cn, // 09D0 - 09DF
      _iv, _iv, _dv, _dv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 09E0 - 09EF
!     _rv, _ct, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx                           /* 09F0 - 09FA */
  };
  
  static const IndicClassTable::CharClass punjCharClasses[] =
***************
*** 120,125 ****
--- 120,138 ----
      _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0AE0 - 0AEF
  };
  
+ #if 1
+ static const IndicClassTable::CharClass oryaCharClasses[] =
+ {
+     _xx, _ma, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _xx, _iv, /* 0B00 - 0B0F */
+     _iv, _xx, _xx, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _ct, _bb, /* 0B10 - 0B1F */
+     _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _pb, /* 0B20 - 0B2F */
+     _rb, _xx, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _nu, _xx, _dr, _da, /* 0B30 - 0B3F */
+     _dr, _db, _db, _db, _xx, _xx, _xx, _dl, _s1, _xx, _xx, _s2, _s3, _vr, _xx, _xx, /* 0B40 - 0B4F */
+     _xx, _xx, _xx, _xx, _xx, _xx, _da, _dr, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _pb, /* 0B50 - 0B5F */
+     _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, /* 0B60 - 0B6F */
+     _xx, _bb                                                                        /* 0B70 - 0B71 */
+ };
+ #else
  static const IndicClassTable::CharClass oryaCharClasses[] =
  {
      _xx, _ma, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _xx, _iv, // 0B00 - 0B0F
***************
*** 131,136 ****
--- 144,150 ----
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0B60 - 0B6F
      _xx, _ct                                                                        // 0B70 - 0B71
  };
+ #endif
  
  static const IndicClassTable::CharClass tamlCharClasses[] =
  {
***************
*** 150,156 ****
      _xx, _mp, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, // 0C00 - 0C0F
      _iv, _xx, _iv, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, // 0C10 - 0C1F
      _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _bb, // 0C20 - 0C2F
!     _bb, _ct, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _xx, _xx, _da, _da, // 0C30 - 0C3F
      _da, _dr, _dr, _dr, _dr, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
      _xx, _xx, _xx, _xx, _xx, _da, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0C50 - 0C5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0C60 - 0C6F
--- 164,170 ----
      _xx, _mp, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, // 0C00 - 0C0F
      _iv, _xx, _iv, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, // 0C10 - 0C1F
      _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _bb, // 0C20 - 0C2F
!     _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _xx, _xx, _da, _da, // 0C30 - 0C3F
      _da, _dr, _dr, _dr, _dr, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
      _xx, _xx, _xx, _xx, _xx, _da, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0C50 - 0C5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0C60 - 0C6F
***************
*** 173,178 ****
--- 187,205 ----
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0CE0 - 0CEF
  };
  
+ #if 1
+ //use the pango char class table here
+ static const IndicClassTable::CharClass mlymCharClasses[] =
+ {
+     _xx, _xx, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, /* 0D00 - 0D0F */
+     _iv, _xx, _iv, _iv, _iv, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, /* 0D10 - 0D1F */
+     _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _xx, _ct, _ct, _ct, _ct, _ct, _pb, /* 0D20 - 0D2F */
+     _pb, _cn, _ct, _ct, _ct, _pb, _ct, _ct, _ct, _ct, _xx, _xx, _xx, _xx, _dr, _dr, /* 0D30 - 0D3F */
+     _dr, _dr, _dr, _dr, _xx, _xx, _dl, _dl, _dl, _xx, _s1, _s2, _s3, _vr, _xx, _xx, /* 0D40 - 0D4F */
+     _xx, _xx, _xx, _xx, _xx, _xx, _xx, _dr, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, /* 0D50 - 0D5F */
+     _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  /* 0D60 - 0D6F */
+ };
+ #else
  // FIXME: this is correct for old-style Malayalam (MAL) but not for reformed Malayalam (MLR)
  // FIXME: should there be a REPH for old-style Malayalam?
  static const IndicClassTable::CharClass mlymCharClasses[] =
***************
*** 185,190 ****
--- 212,218 ----
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0D50 - 0D5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0D60 - 0D6F
  };
+ #endif
   
  static const IndicClassTable::CharClass sinhCharClasses[] =
  {
***************
*** 232,238 ****
  #define TAML_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define TELU_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
  #define KNDA_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
! #define MLYM_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define SINH_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  
  //
--- 260,266 ----
  #define TAML_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define TELU_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
  #define KNDA_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
! #define MLYM_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  #define SINH_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  
  //
***************
*** 256,262 ****
  
  static const IndicClassTable mlymClassTable = {0x0D00, 0x0D6F, 3, MLYM_SCRIPT_FLAGS, mlymCharClasses, mlymSplitTable};
  
! static const IndicClassTable sinhClassTable = {0x0D80, 0x0DF4, 3, SINH_SCRIPT_FLAGS, sinhCharClasses, sinhSplitTable};
  
  //
  // IndicClassTable addresses
--- 284,290 ----
  
  static const IndicClassTable mlymClassTable = {0x0D00, 0x0D6F, 3, MLYM_SCRIPT_FLAGS, mlymCharClasses, mlymSplitTable};
  
! static const IndicClassTable sinhClassTable = {0x0D80, 0x0DF4, 4, SINH_SCRIPT_FLAGS, sinhCharClasses, sinhSplitTable};
  
  //
  // IndicClassTable addresses
*** misc/icu/source/layout/IndicReordering.cpp	Tue Apr 25 21:08:12 2006
--- misc/build/icu/source/layout/IndicReordering.cpp	Tue Nov 13 13:03:52 2007
***************
*** 50,55 ****
--- 50,63 ----
  #define distFeatureMask 0x00010000UL
  #define initFeatureMask 0x00008000UL
  
+ // TODO: Find better names for these!
+ #define tagArray4 (loclFeatureMask | nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | blwmFeatureMask | abvmFeatureMask | distFeatureMask)
+ #define tagArray3 (pstfFeatureMask | tagArray4)
+ #define tagArray2 (halfFeatureMask | tagArray3)
+ #define tagArray1 (blwfFeatureMask | tagArray2)
+ #define tagArray0 (rphfFeatureMask | tagArray1)
+ 
+ 
  class IndicReorderingOutput : public UMemory {
  private:
      le_int32   fOutIndex;
***************
*** 154,159 ****
--- 162,188 ----
          fSMabove = fSMbelow = 0;
      }
  
+     void swapChars(int a, int b)
+     {
+ 	LEErrorCode success = LE_NO_ERROR;
+         LEUnicode temp_char;
+         le_uint32 temp_index;
+         FeatureMask temp_tag;
+ 
+         temp_char = fOutChars[fOutIndex + b];
+ 	temp_index = fGlyphStorage.getCharIndex(fOutIndex + b, success);
+         temp_tag = fGlyphStorage.getAuxData(fOutIndex + b, success);
+ 
+         fOutChars[fOutIndex + b] = fOutChars[fOutIndex + a];
+         le_uint32 toswap = fGlyphStorage.getCharIndex(fOutIndex + a, success);
+         fGlyphStorage.setCharIndex(fOutIndex + b,  toswap, success);
+         fGlyphStorage.setAuxData(fOutIndex + b, tagArray3, success);
+ 
+         fOutChars[fOutIndex + a] = temp_char;
+         fGlyphStorage.setCharIndex(fOutIndex + a, temp_index, success);
+         fGlyphStorage.setAuxData(fOutIndex + a, temp_tag, success);
+     }
+ 
      void writeChar(LEUnicode ch, le_uint32 charIndex, FeatureMask charFeatures)
      {
          LEErrorCode success = LE_NO_ERROR;
***************
*** 335,347 ****
      C_DOTTED_CIRCLE = 0x25CC
  };
  
- // TODO: Find better names for these!
- #define tagArray4 (loclFeatureMask | nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | blwmFeatureMask | abvmFeatureMask | distFeatureMask)
- #define tagArray3 (pstfFeatureMask | tagArray4)
- #define tagArray2 (halfFeatureMask | tagArray3)
- #define tagArray1 (blwfFeatureMask | tagArray2)
- #define tagArray0 (rphfFeatureMask | tagArray1)
- 
  static const FeatureMap featureMap[] =
  {
      {loclFeatureTag, loclFeatureMask},
--- 364,369 ----
***************
*** 373,379 ****
      {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5,  9,  5,  5,  4, 12}, //  2 - consonant with nukta
      {-1,  6,  1, -1, -1, -1, -1, -1,  2,  5,  9,  5,  5,  4, 12}, //  3 - consonant
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1,  7}, //  4 - consonant virama
!     {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  5 - dependent vowels
      {-1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  6 - vowel mark
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1, -1}, //  7 - consonant virama ZWJ, consonant ZWJ virama
      {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  4, -1}, //  8 - independent vowels that can take a virama
--- 395,401 ----
      {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5,  9,  5,  5,  4, 12}, //  2 - consonant with nukta
      {-1,  6,  1, -1, -1, -1, -1, -1,  2,  5,  9,  5,  5,  4, 12}, //  3 - consonant
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1,  7}, //  4 - consonant virama
!     {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5, -1, -1, -1, -1, -1}, //  5 - dependent vowels
      {-1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  6 - vowel mark
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1, -1}, //  7 - consonant virama ZWJ, consonant ZWJ virama
      {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  4, -1}, //  8 - independent vowels that can take a virama
***************
*** 627,632 ****
--- 649,668 ----
              // write base consonant
              for (i = baseConsonant; i < bcSpan; i += 1) {
                  output.writeChar(chars[i], i, tagArray4);
+             }
+ 
+             /* for the special conjuction of Cons+0x0d4d+0x0d31 or Cons+0x0d4d+0x0d30 of Malayalam */
+             if ((baseConsonant - 2 >= 0) &&
+                 (chars[baseConsonant - 1] == 0x0d4d) &&
+ 		((chars[baseConsonant] == 0x0d31) || 
+ 		 (chars[baseConsonant] == 0x0d30)) &&
+                 ((chars[baseConsonant - 2] >= 0x0d15) &&
+                  (chars[baseConsonant - 2] <= 0x0d39)))  {
+ 
+                 output.swapChars(-1, -3);
+ 
+ 		if (mpreFixups)
+ 			mpreFixups->reduce();
              }
  
              if ((classTable->scriptFlags & SF_MATRAS_AFTER_BASE) != 0) {
*** misc/icu/source/layout/LESwaps.h	Thu Jun 23 00:39:36 2005
--- misc/build/icu/source/layout/LESwaps.h	Tue Nov 13 13:03:52 2007
***************
*** 2,7 ****
--- 2,8 ----
  /*
   *
   * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
+  * with additions by Sun Microsystems 2002-2006
   *
   */
  
***************
*** 17,28 ****
  
  U_NAMESPACE_BEGIN
  
  /**
!  * A convenience macro which invokes the swapWord member function
   * from a concise call.
   *
   * @stable ICU 2.8
   */
  #if defined(U_IS_BIG_ENDIAN)
      #if U_IS_BIG_ENDIAN
          #define SWAPW(value) (value)
--- 18,38 ----
  
  U_NAMESPACE_BEGIN
  
+ // There exist popular font files which contain unaligned tables
+ // (e.g. "Watanabe Gothic"'s "mort" table)
+ // On some platforms unaligned memory accesses cause a crash.
+ // The ALLOW_UNALIGNED hack prevents these crashes by assuming that
+ // every use of the SWAPx macros in ICU's layout engine is intended
+ // for loading a big endian value and replaces them appropriately.
+ #define ALLOW_UNALIGNED_HACK
+ 
  /**
!  * A convenience macro which invokes the swapLong member function
   * from a concise call.
   *
   * @stable ICU 2.8
   */
+ #ifndef ALLOW_UNALIGNED_HACK
  #if defined(U_IS_BIG_ENDIAN)
      #if U_IS_BIG_ENDIAN
          #define SWAPW(value) (value)
***************
*** 48,53 ****
--- 58,82 ----
  #else
      #define SWAPL(value) (LESwaps::isBigEndian() ? (value) : LESwaps::swapLong(value))
  #endif
+ 
+ #else // ALLOW_UNALIGNED_HACK
+ 
+ #define SWAPW(rValue) loadBigEndianWord(reinterpret_cast<const le_uint16&>(rValue))
+ #define SWAPL(rValue) loadBigEndianLong(reinterpret_cast<const le_uint32&>(rValue))
+ 
+ inline le_uint16 loadBigEndianWord( const le_uint16& rValue )
+ {
+     const le_uint8* p = reinterpret_cast<const le_uint8*>(&rValue);
+     return ((p[0] << 8) + p[1]);
+ }
+ 
+ inline le_uint32 loadBigEndianLong( const le_uint32& rValue )
+ {
+     const le_uint8* p = reinterpret_cast<const le_uint8*>(&rValue);
+     return ((p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]);
+ }
+ 
+ #endif // ALLOW_UNALIGNED_HACK
  
  /**
   * This class is used to access data which stored in big endian order
*** misc/icu/source/layout/MPreFixups.cpp	Sat May  8 01:28:44 2004
--- misc/build/icu/source/layout/MPreFixups.cpp	Tue Nov 13 13:03:52 2007
***************
*** 40,45 ****
--- 40,51 ----
      }
  }
  
+ void MPreFixups::reduce()
+ {
+     if (fFixupCount > 0)
+         fFixupCount--;
+ }
+ 
  void MPreFixups::apply(LEGlyphStorage &glyphStorage)
  {
      for (le_int32 fixup = 0; fixup < fFixupCount; fixup += 1) {
*** misc/icu/source/layout/MPreFixups.h	Mon Apr 12 20:51:32 2004
--- misc/build/icu/source/layout/MPreFixups.h	Tue Nov 13 13:03:52 2007
***************
*** 31,36 ****
--- 31,38 ----
      
      void apply(LEGlyphStorage &glyphStorage);
  
+     void reduce();
+ 
  private:
      FixupData *fFixupData;
      le_int32   fFixupCount;
*** misc/icu/source/stubdata/Makefile.in	Fri Dec  2 11:21:34 2005
--- misc/build/icu/source/stubdata/Makefile.in	Tue Nov 13 13:03:52 2007
***************
*** 25,30 ****
--- 25,36 ----
  ## Target information
  
  TARGET_STUBNAME=$(DATA_STUBNAME)
+ ifeq (@platform_make_fragment_name@,mh-mingw)
+ FINAL_SO_TARGET=$(STUBDATA_LIBDIR)$(LIBICU)$(TARGET_STUBNAME)$(ICULIBSUFFIX)$(SO_TARGET_VERSION_MAJOR)$(STUB_SUFFIX).$(SO)
+ %$(STUB_SUFFIX).$(SO): %$(SO_TARGET_VERSION_MAJOR)$(STUB_SUFFIX).$(SO)
+ 	$(RM) $@ && ln $< $@
+ 
+ endif
  
  ifneq ($(ENABLE_STATIC),)
  TARGET = $(STUBDATA_LIBDIR)$(LIBSICU)$(TARGET_STUBNAME)$(ICULIBSUFFIX).$(A)
*** misc/icu/source/test/intltest/loctest.cpp	Thu Jul  6 03:50:04 2006
--- misc/build/icu/source/test/intltest/loctest.cpp	Tue Nov 13 13:03:52 2007
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "loctest.h"
  #include "unicode/decimfmt.h"
  #include "unicode/ucurr.h"
*** misc/icu/source/test/intltest/tsputil.cpp	Wed Jul 19 00:18:10 2006
--- misc/build/icu/source/test/intltest/tsputil.cpp	Tue Nov 13 13:03:52 2007
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "tsputil.h"
  
  #include <float.h> // DBL_MAX, DBL_MIN
*** misc/icu/source/test/intltest/uobjtest.cpp	Thu Mar 23 01:54:12 2006
--- misc/build/icu/source/test/intltest/uobjtest.cpp	Tue Nov 13 13:03:52 2007
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "uobjtest.h"
  #include "cmemory.h" // UAlignedMemory
  #include <string.h>
*** misc/icu/source/test/intltest/ustrtest.cpp	Tue Dec 28 22:13:54 2004
--- misc/build/icu/source/test/intltest/ustrtest.cpp	Tue Nov 13 13:03:52 2007
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "ustrtest.h"
  #include "unicode/unistr.h"
  #include "unicode/uchar.h"
*** misc/icu/source/tools/icupkg/icupkg.cpp	Fri Jul 21 23:17:52 2006
--- misc/build/icu/source/tools/icupkg/icupkg.cpp	Tue Nov 13 13:03:52 2007
***************
*** 332,337 ****
--- 332,341 ----
      return (UBool)(len>0 && 0==strcmp(filename+len, ".dat"));
  }
  
+ #ifdef __MINGW32__
+ int _CRT_glob=0;
+ #endif
+ 
  extern int
  main(int argc, char *argv[]) {
      const char *pname, *sourcePath, *destPath, *inFilename, *outFilename, *outComment;
*** misc/icu/source/tools/pkgdata/make.c	Wed Mar 22 09:14:10 2006
--- misc/build/icu/source/tools/pkgdata/make.c	Tue Nov 13 13:03:52 2007
***************
*** 172,178 ****
--- 172,180 ----
                      "MODE=%s\n"
                      "MAKEFILE=%s\n"
                      "ENTRYPOINT=%s\n"
+ #ifndef __MINGW32__
                      "include %s\n"
+ #endif
                      "\n\n\n",
                      o->shortName,
                      o->libName,
***************
*** 182,189 ****
--- 184,195 ----
                      o->srcDir,
                      o->mode,
                      o->makeFile,
+ #ifdef __MINGW32__
+                     o->entryName);
+ #else
                      o->entryName,
                      o->options);
+ #endif
      T_FileStream_writeLine(f, linebuf);
      
      /* TEMP_PATH  and TARG_PATH will be empty if the respective dir is . */
***************
*** 233,238 ****
--- 239,252 ----
  
      pkg_writeCharListWrap(f, o->filePaths, " ", " \\\n",0);
  
+ #ifdef __MINGW32__
+     sprintf(linebuf, "\n"
+                     "include %s\n"
+                     "\n\n\n",
+                     o->options);
+     T_FileStream_writeLine(f, linebuf);
+ #endif
+     
      T_FileStream_writeLine(f, "\n\n\n");
  
  }
***************
*** 396,402 ****
--- 410,420 ----
      T_FileStream_writeLine(f, "BASE_OBJECTS=$(NAME)_dat.o\n");
      T_FileStream_writeLine(f, "\n");
      T_FileStream_writeLine(f, "$(TEMP_DIR)/$(NAME).dat: $(CMNLIST) $(DATAFILEPATHS)\n");
+ #ifdef __MINGW32__
+     T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCMN) -c -e $(ENTRYPOINT) -n $(NAME) -s $(SRCDIRW) -t dat -d $(TEMP_DIR) 0 $(CMNLIST)\n");
+ #else
      T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCMN) -c -e $(ENTRYPOINT) -n $(NAME) -s $(SRCDIR) -t dat -d $(TEMP_DIR) 0 $(CMNLIST)\n");
+ #endif
      T_FileStream_writeLine(f, "\n");
      T_FileStream_writeLine(f, "$(TEMP_DIR)/$(NAME)_dat.o : $(TEMP_DIR)/$(NAME).dat\n");
      T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCCODE) $(GENCCODE_ASSEMBLY) -n $(NAME) -e $(ENTRYPOINT) -d $(TEMP_DIR) $<\n");
