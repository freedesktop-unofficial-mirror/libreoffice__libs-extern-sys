*** misc/icu/source/common/putil.c	Mon Jul 31 20:14:28 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/putil.c	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/putil.c	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 48,54 ****
  #endif
  
  /* Make sure things like readlink and such functions work. */
! #ifndef _XOPEN_SOURCE_EXTENDED
  #define _XOPEN_SOURCE_EXTENDED 1
  #endif
  
--- 48,55 ----
  #endif
  
  /* Make sure things like readlink and such functions work. */
! /* It is invalid to compile an XPG3, XPG4, XPG4v2 or XPG5 application using c99 */
! #if !defined(_XOPEN_SOURCE_EXTENDED) && __STDC_VERSION__ < 199901L
  #define _XOPEN_SOURCE_EXTENDED 1
  #endif
  
*** misc/icu/source/common/unicode/pwin32.h	Tue Aug 29 23:34:38 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/unicode/pwin32.h	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/unicode/pwin32.h	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 266,273 ****
--- 266,278 ----
  #else
  #define U_EXPORT __declspec(dllexport)
  #endif
+ #ifdef __MINGW32__
+ #define U_EXPORT2
+ #define U_IMPORT
+ #else
  #define U_EXPORT2 __cdecl
  #define U_IMPORT __declspec(dllimport)
+ #endif
  
  /*===========================================================================*/
  /* Code alignment and C function inlining                                    */
*** misc/icu/source/common/unicode/rbbi.h	Fri Aug 11 07:46:40 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/unicode/rbbi.h	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/unicode/rbbi.h	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 611,622 ****
--- 611,624 ----
      virtual int32_t getBreakType() const;
  #endif
  
+ public:
      /**
        * Set the type of the break iterator.
        * @internal
        */
      virtual void setBreakType(int32_t type);
  
+ protected:
      /**
        * Common initialization function, used by constructors and bufferClone.
        *   (Also used by DictionaryBasedBreakIterator::createBufferClone().)
*** misc/icu/source/common/unicode/umachine.h	Tue Feb  7 02:54:16 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/unicode/umachine.h	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/unicode/umachine.h	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 322,328 ****
   */
  
  /* Define UChar to be compatible with wchar_t if possible. */
! #if U_SIZEOF_WCHAR_T==2
      typedef wchar_t UChar;
  #else
      typedef uint16_t UChar;
--- 322,328 ----
   */
  
  /* Define UChar to be compatible with wchar_t if possible. */
! #if U_SIZEOF_WCHAR_T==2 && !defined(__MINGW32__)
      typedef wchar_t UChar;
  #else
      typedef uint16_t UChar;
*** misc/icu/source/common/unicode/unistr.h	Tue Aug 29 23:52:50 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/unicode/unistr.h	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/unicode/unistr.h	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 3280,3286 ****
  //========================================
  inline int8_t
  UnicodeString::doCompare(int32_t start,
!               int32_t length,
                const UnicodeString& srcText,
                int32_t srcStart,
                int32_t srcLength) const
--- 3280,3286 ----
  //========================================
  inline int8_t
  UnicodeString::doCompare(int32_t start,
!               int32_t _length,
                const UnicodeString& srcText,
                int32_t srcStart,
                int32_t srcLength) const
***************
*** 3289,3295 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompare(start, length, srcText.fArray, srcStart, srcLength);
    }
  }
  
--- 3289,3295 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompare(start, _length, srcText.fArray, srcStart, srcLength);
    }
  }
  
***************
*** 3374,3380 ****
  
  inline int8_t
  UnicodeString::doCompareCodePointOrder(int32_t start,
!                                        int32_t length,
                                         const UnicodeString& srcText,
                                         int32_t srcStart,
                                         int32_t srcLength) const
--- 3374,3380 ----
  
  inline int8_t
  UnicodeString::doCompareCodePointOrder(int32_t start,
!                                        int32_t _length,
                                         const UnicodeString& srcText,
                                         int32_t srcStart,
                                         int32_t srcLength) const
***************
*** 3383,3389 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompareCodePointOrder(start, length, srcText.fArray, srcStart, srcLength);
    }
  }
  
--- 3383,3389 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCompareCodePointOrder(start, _length, srcText.fArray, srcStart, srcLength);
    }
  }
  
***************
*** 3435,3441 ****
  
  inline int8_t
  UnicodeString::doCaseCompare(int32_t start,
!                              int32_t length,
                               const UnicodeString &srcText,
                               int32_t srcStart,
                               int32_t srcLength,
--- 3435,3441 ----
  
  inline int8_t
  UnicodeString::doCaseCompare(int32_t start,
!                              int32_t _length,
                               const UnicodeString &srcText,
                               int32_t srcStart,
                               int32_t srcLength,
***************
*** 3445,3451 ****
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCaseCompare(start, length, srcText.fArray, srcStart, srcLength, options);
    }
  }
  
--- 3445,3451 ----
      return (int8_t)!isBogus(); // 0 if both are bogus, 1 otherwise
    } else {
      srcText.pinIndices(srcStart, srcLength);
!     return doCaseCompare(start, _length, srcText.fArray, srcStart, srcLength, options);
    }
  }
  
*** misc/icu/source/common/unicode/ustring.h	Tue Aug 29 23:52:50 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/common/unicode/ustring.h	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/common/unicode/ustring.h	Mon Jan 28 21:31:50 2008
>>>>>>> 1.10.12.2
***************
*** 918,924 ****
   * </pre>
   * @stable ICU 2.0
   */
! #if U_SIZEOF_WCHAR_T==U_SIZEOF_UCHAR && (U_CHARSET_FAMILY==U_ASCII_FAMILY || (U_SIZEOF_UCHAR == 2 && defined(U_WCHAR_IS_UTF16)))
  #   define U_STRING_DECL(var, cs, length) static const wchar_t var[(length)+1]={ L ## cs }
      /**@stable ICU 2.0 */
  #   define U_STRING_INIT(var, cs, length)
--- 918,924 ----
   * </pre>
   * @stable ICU 2.0
   */
! #if U_SIZEOF_WCHAR_T==U_SIZEOF_UCHAR && (U_CHARSET_FAMILY==U_ASCII_FAMILY || (U_SIZEOF_UCHAR == 2 && defined(U_WCHAR_IS_UTF16))) && !defined(__MINGW32__)
  #   define U_STRING_DECL(var, cs, length) static const wchar_t var[(length)+1]={ L ## cs }
      /**@stable ICU 2.0 */
  #   define U_STRING_INIT(var, cs, length)
*** misc/icu/source/common/uvectr32.cpp	Wed Aug 27 03:01:30 2003
--- misc/build/icu/source/common/uvectr32.cpp	Mon Jan 28 21:31:51 2008
***************
*** 1,6 ****
  /*
  ******************************************************************************
! * Copyright (C) 1999-2003, International Business Machines Corporation and   *
  * others. All Rights Reserved.                                               *
  ******************************************************************************
  *   Date        Name        Description
--- 1,6 ----
  /*
  ******************************************************************************
! * Copyright (C) 1999-2008, International Business Machines Corporation and   *
  * others. All Rights Reserved.                                               *
  ******************************************************************************
  *   Date        Name        Description
***************
*** 26,31 ****
--- 26,32 ----
  UVector32::UVector32(UErrorCode &status) :
      count(0),
      capacity(0),
+     maxCapacity(0),
      elements(NULL)
  {
      _init(DEFUALT_CAPACITY, status);
***************
*** 34,39 ****
--- 35,41 ----
  UVector32::UVector32(int32_t initialCapacity, UErrorCode &status) :
      count(0),
      capacity(0),
+     maxCapacity(0),
      elements(0)
  {
      _init(initialCapacity, status);
***************
*** 46,51 ****
--- 48,56 ----
      if (initialCapacity < 1) {
          initialCapacity = DEFUALT_CAPACITY;
      }
+     if (maxCapacity>0 && maxCapacity<initialCapacity) {
+         initialCapacity = maxCapacity;
+     }
      elements = (int32_t *)uprv_malloc(sizeof(int32_t)*initialCapacity);
      if (elements == 0) {
          status = U_MEMORY_ALLOCATION_ERROR;
***************
*** 189,209 ****
  UBool UVector32::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
      if (capacity >= minimumCapacity) {
          return TRUE;
!     } else {
!         int32_t newCap = capacity * 2;
!         if (newCap < minimumCapacity) {
!             newCap = minimumCapacity;
!         }
!         int32_t* newElems = (int32_t *)uprv_malloc(sizeof(int32_t)*newCap);
!         if (newElems == 0) {
!             status = U_MEMORY_ALLOCATION_ERROR;
!             return FALSE;
!         }
!         uprv_memcpy(newElems, elements, sizeof(elements[0]) * count);
!         uprv_free(elements);
!         elements = newElems;
!         capacity = newCap;
!         return TRUE;
      }
  }
  
--- 194,228 ----
  UBool UVector32::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
      if (capacity >= minimumCapacity) {
          return TRUE;
!     }
!     if (maxCapacity>0 && minimumCapacity>maxCapacity) {
!         status = U_BUFFER_OVERFLOW_ERROR;
!         return FALSE;
!     }
!     int32_t newCap = capacity * 2;
!     if (newCap < minimumCapacity) {
!         newCap = minimumCapacity;
!     }
!     if (maxCapacity > 0 && newCap > maxCapacity) {
!         newCap = maxCapacity;
!     }
!     int32_t* newElems = (int32_t *)uprv_malloc(sizeof(int32_t)*newCap);
!     if (newElems == 0) {
!         status = U_MEMORY_ALLOCATION_ERROR;
!         return FALSE;
!     }
!     uprv_memcpy(newElems, elements, sizeof(elements[0]) * count);
!     uprv_free(elements);
!     elements = newElems;
!     capacity = newCap;
!     return TRUE;
! }
! 
! void UVector32::setMaxCapacity(int32_t limit) {
!     U_ASSERT(limit >= 0);
!     maxCapacity = limit;
!     if (maxCapacity < 0) {
!         maxCapacity = 0;
      }
  }
  
*** misc/icu/source/common/uvectr32.h	Wed Jan 18 04:52:04 2006
--- misc/build/icu/source/common/uvectr32.h	Mon Jan 28 21:31:51 2008
***************
*** 1,6 ****
  /*
  **********************************************************************
! *   Copyright (C) 1999-2006, International Business Machines
  *   Corporation and others.  All Rights Reserved.
  **********************************************************************
  */
--- 1,6 ----
  /*
  **********************************************************************
! *   Copyright (C) 1999-2008, International Business Machines
  *   Corporation and others.  All Rights Reserved.
  **********************************************************************
  */
***************
*** 61,66 ****
--- 61,68 ----
      int32_t   count;
  
      int32_t   capacity;
+     
+     int32_t   maxCapacity;   // Limit beyond which capacity is not permitted to grow.
  
      int32_t*  elements;
  
***************
*** 162,167 ****
--- 164,177 ----
      int32_t *getBuffer() const;
  
      /**
+      * Set the maximum allowed buffer capacity for this vector/stack.
+      * Default with no limit set is unlimited, go until malloc() fails.
+      * A Limit of zero means unlimited capacity.
+      * Units are vector elements (32 bits each), not bytes.
+      */
+     void setMaxCapacity(int32_t limit);
+ 
+     /**
       * ICU "poor man's RTTI", returns a UClassID for this class.
       */
      static UClassID U_EXPORT2 getStaticClassID();
***************
*** 221,227 ****
  }
  
  inline int32_t *UVector32::reserveBlock(int32_t size, UErrorCode &status) {
!     ensureCapacity(count+size, status);
      int32_t  *rp = elements+count;
      count += size;
      return rp;
--- 231,239 ----
  }
  
  inline int32_t *UVector32::reserveBlock(int32_t size, UErrorCode &status) {
!     if (ensureCapacity(count+size, status) == FALSE) {
!         return NULL;
!     }
      int32_t  *rp = elements+count;
      count += size;
      return rp;
*** misc/icu/source/config/mh-darwin	Wed Feb  1 08:52:42 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/config/mh-darwin	Tue Nov 13 13:03:51 2007
=======
--- misc/build/icu/source/config/mh-darwin	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 25,31 ****
  SHLIB.cc=	$(CXX) -dynamiclib -dynamic $(CXXFLAGS) $(LDFLAGS)
  
  ## Compiler switches to embed a library name and version information
! LD_SONAME = -Wl,-compatibility_version -Wl,$(SO_TARGET_VERSION_MAJOR) -Wl,-current_version -Wl,$(SO_TARGET_VERSION) -install_name $(notdir $(MIDDLE_SO_TARGET))
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=
--- 25,31 ----
  SHLIB.cc=	$(CXX) -dynamiclib -dynamic $(CXXFLAGS) $(LDFLAGS)
  
  ## Compiler switches to embed a library name and version information
! LD_SONAME = -Wl,-compatibility_version -Wl,$(SO_TARGET_VERSION_MAJOR) -Wl,-current_version -Wl,$(SO_TARGET_VERSION) -install_name @executable_path/$(notdir $(FINAL_SO_TARGET))
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=
*** misc/icu/source/config/mh-irix	Thu Mar 23 19:51:52 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/config/mh-irix	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/config/mh-irix	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 23,28 ****
--- 23,31 ----
  SHLIB.c=    $(CC) -shared $(DEFS) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS)
  SHLIB.cc=   $(CXX) -shared $(DEFS) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS)
  
+ # Environment variable to set a runtime search path
+ LDLIBRARYPATH_ENVVAR = LD_LIBRARYN32_PATH
+ 
  ## Additional flags when building libraries with thread safety
  THREADSCPPFLAGS = -D_REENTRANT -D_PTHREADS
  LIBCPPFLAGS =
*** misc/icu/source/config/mh-linux	Thu Mar 23 19:51:52 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/config/mh-linux	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/config/mh-linux	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 20,25 ****
--- 20,33 ----
  LD_RPATH=	
  LD_RPATH_PRE = -Wl,-rpath,
  
+ ## Force RPATH=$ORIGIN to locate own dependencies w/o need for LD_LIBRARY_PATH
+ ## (incl. the C++ runtime libs potentially found in the URE lib dir):
+ ENABLE_RPATH=YES
+ RPATHLDFLAGS=${LD_RPATH_PRE}'$$ORIGIN:$$ORIGIN/../ure-link/lib'
+ 
+ #SH#  ENABLE_RPATH=YES
+ #SH#  RPATHLDFLAGS="${LD_RPATH_PRE}'$$ORIGIN:$$ORIGIN/../ure-link/lib'"
+ 
  ## These are the library specific LDFLAGS
  LDFLAGSICUDT=-nodefaultlibs -nostdlib
  
*** misc/icu/source/config/mh-mingw	Tue Aug 15 10:24:14 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/config/mh-mingw	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/config/mh-mingw	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 54,59 ****
--- 54,62 ----
  STATIC_O = ao
  SO_TARGET_VERSION_SUFFIX = $(SO_TARGET_VERSION_MAJOR)
  
+ STUB_SUFFIX=l
+ LIBICUDT=       -L$(LIBDIR) -L$(top_builddir)/stubdata -l$(STATIC_PREFIX_WHEN_USED)$(ICUPREFIX)$(DATA_STUBNAME)$(ICULIBSUFFIX)$(SO_TARGET_VERSION_MAJOR)l
+ 
  # Static library prefix and file extension
  LIBSICU = $(STATIC_PREFIX)$(ICUPREFIX)
  A = lib
***************
*** 71,77 ****
  
  # The #M# is used to delete lines for icu-config
  # Current full path directory.
! CURR_FULL_DIR=$(shell pwd -W)#M#
  # Current full path directory for use in source code in a -D compiler option.
  CURR_SRCCODE_FULL_DIR=$(subst /,\\\\,$(shell pwd -W))#M#
  
--- 74,83 ----
  
  # The #M# is used to delete lines for icu-config
  # Current full path directory.
! CURR_FULL_DIR=$(subst \,/,$(shell cygpath -aw .))#M#
! SRCDIRW:=$(SRCDIR)
! SRCDIR:=$(foreach p,$(SRCDIR),$(shell cygpath -u $(subst \,/,$(p))))#M#
! DATAFILEPATHS:=$(foreach p,$(DATAFILEPATHS),$(shell cygpath -u $(subst \,/,$(p))))#M#
  # Current full path directory for use in source code in a -D compiler option.
  CURR_SRCCODE_FULL_DIR=$(subst /,\\\\,$(shell pwd -W))#M#
  
*** misc/icu/source/config/mh-solaris	Fri Feb 24 20:31:14 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/config/mh-solaris	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/config/mh-solaris	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 18,34 ****
  
  ## Commands to link
  ## For Sun Workshop, use CC to link to bring in C++ runtime
! LINK.c=		$(CXX) $(CXXFLAGS) $(LDFLAGS)
! LINK.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS)
  
  ## Commands to make a shared library
  SHLIB.c=	$(CC) $(CFLAGS) $(LDFLAGS) -G
! SHLIB.cc=	$(CXX) $(CXXFLAGS) $(LDFLAGS) -G
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=	-R
  LD_RPATH_PRE=	
  
  #LIBRARY_PATH_PREFIX=/usr/lib/lwp:
  
  ## Compiler switch to embed a library name
--- 18,42 ----
  
  ## Commands to link
  ## For Sun Workshop, use CC to link to bring in C++ runtime
! ## For Sun Workshop, -norunpath stops compiler to record a useless RPATH
! LINK.c=     $(CXX) $(CXXFLAGS) $(LDFLAGS) -norunpath
! LINK.cc=    $(CXX) $(CXXFLAGS) $(LDFLAGS) -norunpath
  
  ## Commands to make a shared library
  SHLIB.c=	$(CC) $(CFLAGS) $(LDFLAGS) -G
! SHLIB.cc=   $(CXX) $(CXXFLAGS) $(LDFLAGS) -G -norunpath
  
  ## Compiler switch to embed a runtime search path
  LD_RPATH=	-R
  LD_RPATH_PRE=	
  
+ ## Force RPATH=$ORIGIN to locate own dependencies w/o need for LD_LIBRARY_PATH
+ ENABLE_RPATH=YES
+ RPATHLDFLAGS=${LD_RPATH}'$$ORIGIN'
+ 
+ #SH#  ENABLE_RPATH=YES
+ #SH#  RPATHLDFLAGS="${LD_RPATH}'$$ORIGIN'"
+ 
  #LIBRARY_PATH_PREFIX=/usr/lib/lwp:
  
  ## Compiler switch to embed a library name
*** misc/icu/source/data/Makefile.in	Sat Aug 12 00:22:24 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/data/Makefile.in	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/data/Makefile.in	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 344,350 ****
  ifneq ($(ICUDATA_SOURCE_IS_NATIVE_TARGET),YES)
  	@echo "Unpacking $(ICUDATA_SOURCE_ARCHIVE) and generating $@ (list of data files)"
  	@-$(RMV) $@
! 	$(INVOKE) $(BINDIR)/icupkg -d $(BUILDDIR) --list -x \* $(ICUDATA_SOURCE_ARCHIVE) > $@
  else
  	@echo "$@" > $@
  endif
--- 344,350 ----
  ifneq ($(ICUDATA_SOURCE_IS_NATIVE_TARGET),YES)
  	@echo "Unpacking $(ICUDATA_SOURCE_ARCHIVE) and generating $@ (list of data files)"
  	@-$(RMV) $@
! 	$(INVOKE) $(BINDIR)/icupkg -d $(BUILDDIR) --list -x \* $(ICUDATA_SOURCE_ARCHIVE) | grep -v ".cnv" > $@
  else
  	@echo "$@" > $@
  endif
*** misc/icu/source/i18n/regexcmp.cpp	Thu Feb  2 05:37:14 2006
--- misc/build/icu/source/i18n/regexcmp.cpp	Mon Jan 28 21:31:51 2008
***************
*** 2,8 ****
  //
  //  file:  regexcmp.cpp
  //
! //  Copyright (C) 2002-2006 International Business Machines Corporation and others.
  //  All Rights Reserved.
  //
  //  This file contains the ICU regular expression compiler, which is responsible
--- 2,8 ----
  //
  //  file:  regexcmp.cpp
  //
! //  Copyright (C) 2002-2008 International Business Machines Corporation and others.
  //  All Rights Reserved.
  //
  //  This file contains the ICU regular expression compiler, which is responsible
***************
*** 1187,1200 ****
              // Because capture groups can be forward-referenced by back-references,
              //  we fill the operand with the capture group number.  At the end
              //  of compilation, it will be changed to the variable's location.
!             U_ASSERT(groupNum > 0);
!             int32_t  op;
!             if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
!                 op = URX_BUILD(URX_BACKREF_I, groupNum);
              } else {
!                 op = URX_BUILD(URX_BACKREF, groupNum);
              }
-             fRXPat->fCompiledPat->addElement(op, *fStatus);
          }
          break;
  
--- 1187,1203 ----
              // Because capture groups can be forward-referenced by back-references,
              //  we fill the operand with the capture group number.  At the end
              //  of compilation, it will be changed to the variable's location.
!             if (groupNum < 1) { 
!                 error(U_REGEX_INVALID_BACK_REF);
              } else {
!                 int32_t  op;
!                 if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
!                     op = URX_BUILD(URX_BACKREF_I, groupNum);
!                 } else {
!                     op = URX_BUILD(URX_BACKREF, groupNum);
!                 }
!                 fRXPat->fCompiledPat->addElement(op, *fStatus);
              }
          }
          break;
  
*** misc/icu/source/i18n/rematch.cpp	Thu Aug 25 20:02:20 2005
--- misc/build/icu/source/i18n/rematch.cpp	Mon Jan 28 21:31:51 2008
***************
*** 6,12 ****
  //
  /*
  **************************************************************************
! *   Copyright (C) 2002-2005 International Business Machines Corporation  *
  *   and others. All rights reserved.                                     *
  **************************************************************************
  */
--- 6,12 ----
  //
  /*
  **************************************************************************
! *   Copyright (C) 2002-2008 International Business Machines Corporation  *
  *   and others. All rights reserved.                                     *
  **************************************************************************
  */
***************
*** 30,35 ****
--- 30,44 ----
  
  U_NAMESPACE_BEGIN
  
+ // Limit the size of the back track stack, to avoid system failures caused
+ //   by heap exhaustion.  Units are in 32 bit words, not bytes.
+ // This value puts ICU's limits higher than most other regexp implementations,
+ //  which use recursion rather than the heap, and take more storage per
+ //  backtrack point.
+ // This constant is _temporary_.  Proper API to control the value will added.
+ //
+ static const int32_t BACKTRACK_STACK_CAPACITY = 8000000;
+ 
  //-----------------------------------------------------------------------------
  //
  //   Constructor and Destructor
***************
*** 53,60 ****
      }
      if (fStack == NULL || fData == NULL) {
          fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
      }
-         
      reset(*RegexStaticSets::gStaticSets->fEmptyString);
  }
  
--- 62,70 ----
      }
      if (fStack == NULL || fData == NULL) {
          fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
+     } else {
+         fStack->setMaxCapacity(BACKTRACK_STACK_CAPACITY);
      }
      reset(*RegexStaticSets::gStaticSets->fEmptyString);
  }
  
***************
*** 78,83 ****
--- 88,95 ----
      }
      if (fStack == NULL || fData == NULL) {
          status = U_MEMORY_ALLOCATION_ERROR;
+     } else {
+         fStack->setMaxCapacity(BACKTRACK_STACK_CAPACITY);
      }
      reset(input);
  }
***************
*** 102,107 ****
--- 114,121 ----
      }
      if (fStack == NULL || fData == NULL) {
          status = U_MEMORY_ALLOCATION_ERROR;
+     } else {
+         fStack->setMaxCapacity(BACKTRACK_STACK_CAPACITY);
      }
      reset(*RegexStaticSets::gStaticSets->fEmptyString);
  }
***************
*** 1015,1020 ****
--- 1029,1042 ----
  inline REStackFrame *RegexMatcher::StateSave(REStackFrame *fp, int32_t savePatIdx, int32_t frameSize, UErrorCode &status) {
      // push storage for a new frame. 
      int32_t *newFP = fStack->reserveBlock(frameSize, status);
+     if (newFP == NULL) {
+         // Heap allocation error on attempted stack expansion.
+         // We need to return a writable stack frame, so just return the
+         //    previous frame.  The match operation will stop quickly
+         //    becuase of the error status, after which the frame will never
+         //    be looked at again.
+         return fp;
+     }
      fp = (REStackFrame *)(newFP - frameSize);  // in case of realloc of stack.
      
      // New stack frame = copy of old top frame.
***************
*** 1030,1037 ****
      fp->fPatIdx = savePatIdx;
      return (REStackFrame *)newFP;
  }
!     
!             
  //--------------------------------------------------------------------------------
  //
  //   MatchAt      This is the actual matching engine.
--- 1052,1059 ----
      fp->fPatIdx = savePatIdx;
      return (REStackFrame *)newFP;
  }
! 
! 
  //--------------------------------------------------------------------------------
  //
  //   MatchAt      This is the actual matching engine.
***************
*** 2262,2267 ****
--- 2284,2290 ----
          }
  
          if (U_FAILURE(status)) {
+             isMatch = FALSE;
              break;
          }
      }
*** misc/icu/source/i18n/windtfmt.cpp	Tue Aug 15 08:48:02 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/i18n/windtfmt.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/i18n/windtfmt.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 232,249 ****
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, buffer, STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, buffer, newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 232,249 ----
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, dfFlags[fDateStyle - kDateOffset], st, NULL, reinterpret_cast<LPWSTR>(buffer), newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
***************
*** 258,275 ****
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, buffer, STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, buffer, newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 258,275 ----
      UChar stackBuffer[STACK_BUFFER_SIZE];
      UChar *buffer = stackBuffer;
  
!     result = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
      if (result == 0) {
          if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
              int newLength = GetTimeFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, NULL, 0);
  
              buffer = NEW_ARRAY(UChar, newLength);
!             GetDateFormatW(fLCID, tfFlags[fTimeStyle], st, NULL, reinterpret_cast<LPWSTR>(buffer), newLength);
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
*** misc/icu/source/i18n/winnmfmt.cpp	Thu Aug 17 07:21:06 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/i18n/winnmfmt.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/i18n/winnmfmt.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 86,95 ****
      GetLocaleInfoA(lcid, LOCALE_SGROUPING, buf, 10);
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SDECIMAL,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_STHOUSAND, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGNUMBER, (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
--- 86,95 ----
      GetLocaleInfoA(lcid, LOCALE_SGROUPING, buf, 10);
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SDECIMAL,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_STHOUSAND, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGNUMBER, (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
***************
*** 111,126 ****
      GetLocaleInfoA(lcid, LOCALE_SMONGROUPING, buf, sizeof(buf));
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SMONDECIMALSEP,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = NEW_ARRAY(UChar, 6);
      GetLocaleInfoW(lcid, LOCALE_SMONTHOUSANDSEP, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGCURR,  (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_ICURRENCY, (LPWSTR) &fmt->PositiveOrder, sizeof(UINT));
  
!     fmt->lpCurrencySymbol = NEW_ARRAY(UChar, 8);
      GetLocaleInfoW(lcid, LOCALE_SCURRENCY, (LPWSTR) fmt->lpCurrencySymbol, 8);
  }
  
--- 111,126 ----
      GetLocaleInfoA(lcid, LOCALE_SMONGROUPING, buf, sizeof(buf));
      fmt->Grouping = getGrouping(buf);
  
!     fmt->lpDecimalSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SMONDECIMALSEP,  fmt->lpDecimalSep,  6);
  
!     fmt->lpThousandSep = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 6));
      GetLocaleInfoW(lcid, LOCALE_SMONTHOUSANDSEP, fmt->lpThousandSep, 6);
  
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_INEGCURR,  (LPWSTR) &fmt->NegativeOrder, sizeof(UINT));
      GetLocaleInfoW(lcid, LOCALE_RETURN_NUMBER|LOCALE_ICURRENCY, (LPWSTR) &fmt->PositiveOrder, sizeof(UINT));
  
!     fmt->lpCurrencySymbol = reinterpret_cast<LPWSTR>(NEW_ARRAY(UChar, 8));
      GetLocaleInfoW(lcid, LOCALE_SCURRENCY, (LPWSTR) fmt->lpCurrencySymbol, 8);
  }
  
***************
*** 290,296 ****
              formatInfo.currency.Grouping = 0;
          }
  
!         result = GetCurrencyFormatW(fLCID, 0, nBuffer, &formatInfo.currency, buffer, STACK_BUFFER_SIZE);
  
          if (result == 0) {
              DWORD lastError = GetLastError();
--- 290,296 ----
              formatInfo.currency.Grouping = 0;
          }
  
!         result = GetCurrencyFormatW(fLCID, 0, nBuffer, &formatInfo.currency, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
          if (result == 0) {
              DWORD lastError = GetLastError();
***************
*** 300,306 ****
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetCurrencyFormatW(fLCID, 0, nBuffer,  &formatInfo.currency, buffer, newLength);
              }
          }
      } else {
--- 300,306 ----
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetCurrencyFormatW(fLCID, 0, nBuffer,  &formatInfo.currency, reinterpret_cast<LPWSTR>(buffer), newLength);
              }
          }
      } else {
***************
*** 312,318 ****
              formatInfo.number.Grouping = 0;
          }
  
!         result = GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, buffer, STACK_BUFFER_SIZE);
  
          if (result == 0) {
              if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
--- 312,318 ----
              formatInfo.number.Grouping = 0;
          }
  
!         result = GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, reinterpret_cast<LPWSTR>(buffer), STACK_BUFFER_SIZE);
  
          if (result == 0) {
              if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
***************
*** 320,331 ****
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, buffer, newLength);
              }
          }
      }
  
!     appendTo.append(buffer, (int32_t) wcslen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
--- 320,331 ----
  
                  buffer = NEW_ARRAY(UChar, newLength);
                  buffer[0] = 0x0000;
!                 GetNumberFormatW(fLCID, 0, nBuffer, &formatInfo.number, reinterpret_cast<LPWSTR>(buffer), newLength);
              }
          }
      }
  
!     appendTo.append(buffer, (int32_t) u_strlen(buffer));
  
      if (buffer != stackBuffer) {
          DELETE_ARRAY(buffer);
*** misc/icu/source/layout/CoverageTables.cpp	Sat May  8 01:28:42 2004
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/CoverageTables.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/CoverageTables.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 44,49 ****
--- 44,53 ----
      le_uint16 count = SWAPW(glyphCount);
      le_uint8 bit = OpenTypeUtilities::highBit(count);
      le_uint16 power = 1 << bit;
+ 
+     if (count == 0)
+         return -1;
+ 
      le_uint16 extra = count - power;
      le_uint16 probe = power;
      le_uint16 index = 0;
*** misc/icu/source/layout/DeviceTables.cpp	Fri Jan 14 18:25:12 2005
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/DeviceTables.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/DeviceTables.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 22,28 ****
      le_uint16 format = SWAPW(deltaFormat) - 1;
      le_int16 result = 0;
      
!     if (ppem >= start && ppem <= SWAPW(endSize)) {
          le_uint16 sizeIndex = ppem - start;
          le_uint16 bits = fieldBits[format];
          le_uint16 count = 16 / bits;
--- 22,29 ----
      le_uint16 format = SWAPW(deltaFormat) - 1;
      le_int16 result = 0;
      
!     if (ppem >= start && ppem <= SWAPW(endSize)
!      && format < sizeof(fieldBits)/sizeof(fieldBits[0])) {
          le_uint16 sizeIndex = ppem - start;
          le_uint16 bits = fieldBits[format];
          le_uint16 count = 16 / bits;
*** misc/icu/source/layout/GXLayoutEngine.cpp	Fri Sep  2 20:22:10 2005
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/GXLayoutEngine.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/GXLayoutEngine.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 39,45 ****
          return 0;
      }
  
!     mapCharsToGlyphs(chars, offset, count, FALSE, rightToLeft, TRUE, glyphStorage, success);
  
      if (LE_FAILURE(success)) {
          return 0;
--- 39,45 ----
          return 0;
      }
  
!     mapCharsToGlyphs(chars, offset, count, rightToLeft, rightToLeft, TRUE, glyphStorage, success);
  
      if (LE_FAILURE(success)) {
          return 0;
*** misc/icu/source/layout/IndicClassTables.cpp	Wed Aug 23 02:12:40 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/IndicClassTables.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/IndicClassTables.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 94,100 ****
      _dr, _db, _db, _db, _db, _xx, _xx, _l1, _dl, _xx, _xx, _s1, _s2, _vr, _xx, _xx, // 09C0 - 09CF
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _cn, // 09D0 - 09DF
      _iv, _iv, _dv, _dv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 09E0 - 09EF
!     _ct, _ct, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx                           // 09F0 - 09FA
  };
  
  static const IndicClassTable::CharClass punjCharClasses[] =
--- 94,100 ----
      _dr, _db, _db, _db, _db, _xx, _xx, _l1, _dl, _xx, _xx, _s1, _s2, _vr, _xx, _xx, // 09C0 - 09CF
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _cn, // 09D0 - 09DF
      _iv, _iv, _dv, _dv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 09E0 - 09EF
!     _rv, _ct, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx                           /* 09F0 - 09FA */
  };
  
  static const IndicClassTable::CharClass punjCharClasses[] =
***************
*** 120,125 ****
--- 120,138 ----
      _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0AE0 - 0AEF
  };
  
+ #if 1
+ static const IndicClassTable::CharClass oryaCharClasses[] =
+ {
+     _xx, _ma, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _xx, _iv, /* 0B00 - 0B0F */
+     _iv, _xx, _xx, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _ct, _bb, /* 0B10 - 0B1F */
+     _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _pb, /* 0B20 - 0B2F */
+     _rb, _xx, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _nu, _xx, _dr, _da, /* 0B30 - 0B3F */
+     _dr, _db, _db, _db, _xx, _xx, _xx, _dl, _s1, _xx, _xx, _s2, _s3, _vr, _xx, _xx, /* 0B40 - 0B4F */
+     _xx, _xx, _xx, _xx, _xx, _xx, _da, _dr, _xx, _xx, _xx, _xx, _cn, _cn, _xx, _pb, /* 0B50 - 0B5F */
+     _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, /* 0B60 - 0B6F */
+     _xx, _bb                                                                        /* 0B70 - 0B71 */
+ };
+ #else
  static const IndicClassTable::CharClass oryaCharClasses[] =
  {
      _xx, _ma, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _xx, _iv, // 0B00 - 0B0F
***************
*** 131,136 ****
--- 144,150 ----
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0B60 - 0B6F
      _xx, _ct                                                                        // 0B70 - 0B71
  };
+ #endif
  
  static const IndicClassTable::CharClass tamlCharClasses[] =
  {
***************
*** 150,156 ****
      _xx, _mp, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, // 0C00 - 0C0F
      _iv, _xx, _iv, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, // 0C10 - 0C1F
      _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _bb, // 0C20 - 0C2F
!     _bb, _ct, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _xx, _xx, _da, _da, // 0C30 - 0C3F
      _da, _dr, _dr, _dr, _dr, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
      _xx, _xx, _xx, _xx, _xx, _da, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0C50 - 0C5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0C60 - 0C6F
--- 164,170 ----
      _xx, _mp, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, // 0C00 - 0C0F
      _iv, _xx, _iv, _iv, _iv, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, // 0C10 - 0C1F
      _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _bb, // 0C20 - 0C2F
!     _bb, _bb, _bb, _bb, _xx, _bb, _bb, _bb, _bb, _bb, _xx, _xx, _xx, _xx, _da, _da, // 0C30 - 0C3F
      _da, _dr, _dr, _dr, _dr, _xx, _a1, _da, _s1, _xx, _da, _da, _da, _vr, _xx, _xx, // 0C40 - 0C4F
      _xx, _xx, _xx, _xx, _xx, _da, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0C50 - 0C5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0C60 - 0C6F
***************
*** 173,178 ****
--- 187,205 ----
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0CE0 - 0CEF
  };
  
+ #if 1
+ //use the pango char class table here
+ static const IndicClassTable::CharClass mlymCharClasses[] =
+ {
+     _xx, _xx, _mp, _mp, _xx, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _iv, _xx, _iv, _iv, /* 0D00 - 0D0F */
+     _iv, _xx, _iv, _iv, _iv, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, /* 0D10 - 0D1F */
+     _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _ct, _xx, _ct, _ct, _ct, _ct, _ct, _pb, /* 0D20 - 0D2F */
+     _pb, _cn, _ct, _ct, _ct, _pb, _ct, _ct, _ct, _ct, _xx, _xx, _xx, _xx, _dr, _dr, /* 0D30 - 0D3F */
+     _dr, _dr, _dr, _dr, _xx, _xx, _dl, _dl, _dl, _xx, _s1, _s2, _s3, _vr, _xx, _xx, /* 0D40 - 0D4F */
+     _xx, _xx, _xx, _xx, _xx, _xx, _xx, _dr, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, /* 0D50 - 0D5F */
+     _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  /* 0D60 - 0D6F */
+ };
+ #else
  // FIXME: this is correct for old-style Malayalam (MAL) but not for reformed Malayalam (MLR)
  // FIXME: should there be a REPH for old-style Malayalam?
  static const IndicClassTable::CharClass mlymCharClasses[] =
***************
*** 185,190 ****
--- 212,218 ----
      _xx, _xx, _xx, _xx, _xx, _xx, _xx, _m2, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0D50 - 0D5F
      _iv, _iv, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx  // 0D60 - 0D6F
  };
+ #endif
   
  static const IndicClassTable::CharClass sinhCharClasses[] =
  {
***************
*** 232,238 ****
  #define TAML_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define TELU_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
  #define KNDA_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
! #define MLYM_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define SINH_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  
  //
--- 260,266 ----
  #define TAML_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT | SF_FILTER_ZERO_WIDTH)
  #define TELU_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
  #define KNDA_SCRIPT_FLAGS (SF_MATRAS_AFTER_BASE | SF_FILTER_ZERO_WIDTH | 3)
! #define MLYM_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  #define SINH_SCRIPT_FLAGS (SF_MPRE_FIXUP | SF_NO_POST_BASE_LIMIT)
  
  //
***************
*** 256,262 ****
  
  static const IndicClassTable mlymClassTable = {0x0D00, 0x0D6F, 3, MLYM_SCRIPT_FLAGS, mlymCharClasses, mlymSplitTable};
  
! static const IndicClassTable sinhClassTable = {0x0D80, 0x0DF4, 3, SINH_SCRIPT_FLAGS, sinhCharClasses, sinhSplitTable};
  
  //
  // IndicClassTable addresses
--- 284,290 ----
  
  static const IndicClassTable mlymClassTable = {0x0D00, 0x0D6F, 3, MLYM_SCRIPT_FLAGS, mlymCharClasses, mlymSplitTable};
  
! static const IndicClassTable sinhClassTable = {0x0D80, 0x0DF4, 4, SINH_SCRIPT_FLAGS, sinhCharClasses, sinhSplitTable};
  
  //
  // IndicClassTable addresses
*** misc/icu/source/layout/IndicReordering.cpp	Tue Apr 25 21:08:12 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/IndicReordering.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/IndicReordering.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 50,55 ****
--- 50,63 ----
  #define distFeatureMask 0x00010000UL
  #define initFeatureMask 0x00008000UL
  
+ // TODO: Find better names for these!
+ #define tagArray4 (loclFeatureMask | nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | blwmFeatureMask | abvmFeatureMask | distFeatureMask)
+ #define tagArray3 (pstfFeatureMask | tagArray4)
+ #define tagArray2 (halfFeatureMask | tagArray3)
+ #define tagArray1 (blwfFeatureMask | tagArray2)
+ #define tagArray0 (rphfFeatureMask | tagArray1)
+ 
+ 
  class IndicReorderingOutput : public UMemory {
  private:
      le_int32   fOutIndex;
***************
*** 154,159 ****
--- 162,188 ----
          fSMabove = fSMbelow = 0;
      }
  
+     void swapChars(int a, int b)
+     {
+ 	LEErrorCode success = LE_NO_ERROR;
+         LEUnicode temp_char;
+         le_uint32 temp_index;
+         FeatureMask temp_tag;
+ 
+         temp_char = fOutChars[fOutIndex + b];
+ 	temp_index = fGlyphStorage.getCharIndex(fOutIndex + b, success);
+         temp_tag = fGlyphStorage.getAuxData(fOutIndex + b, success);
+ 
+         fOutChars[fOutIndex + b] = fOutChars[fOutIndex + a];
+         le_uint32 toswap = fGlyphStorage.getCharIndex(fOutIndex + a, success);
+         fGlyphStorage.setCharIndex(fOutIndex + b,  toswap, success);
+         fGlyphStorage.setAuxData(fOutIndex + b, tagArray3, success);
+ 
+         fOutChars[fOutIndex + a] = temp_char;
+         fGlyphStorage.setCharIndex(fOutIndex + a, temp_index, success);
+         fGlyphStorage.setAuxData(fOutIndex + a, temp_tag, success);
+     }
+ 
      void writeChar(LEUnicode ch, le_uint32 charIndex, FeatureMask charFeatures)
      {
          LEErrorCode success = LE_NO_ERROR;
***************
*** 335,347 ****
      C_DOTTED_CIRCLE = 0x25CC
  };
  
- // TODO: Find better names for these!
- #define tagArray4 (loclFeatureMask | nuktFeatureMask | akhnFeatureMask | vatuFeatureMask | presFeatureMask | blwsFeatureMask | abvsFeatureMask | pstsFeatureMask | halnFeatureMask | blwmFeatureMask | abvmFeatureMask | distFeatureMask)
- #define tagArray3 (pstfFeatureMask | tagArray4)
- #define tagArray2 (halfFeatureMask | tagArray3)
- #define tagArray1 (blwfFeatureMask | tagArray2)
- #define tagArray0 (rphfFeatureMask | tagArray1)
- 
  static const FeatureMap featureMap[] =
  {
      {loclFeatureTag, loclFeatureMask},
--- 364,369 ----
***************
*** 373,379 ****
      {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5,  9,  5,  5,  4, 12}, //  2 - consonant with nukta
      {-1,  6,  1, -1, -1, -1, -1, -1,  2,  5,  9,  5,  5,  4, 12}, //  3 - consonant
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1,  7}, //  4 - consonant virama
!     {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  5 - dependent vowels
      {-1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  6 - vowel mark
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1, -1}, //  7 - consonant virama ZWJ, consonant ZWJ virama
      {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  4, -1}, //  8 - independent vowels that can take a virama
--- 395,401 ----
      {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5,  9,  5,  5,  4, 12}, //  2 - consonant with nukta
      {-1,  6,  1, -1, -1, -1, -1, -1,  2,  5,  9,  5,  5,  4, 12}, //  3 - consonant
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1,  7}, //  4 - consonant virama
!     {-1,  6,  1, -1, -1, -1, -1, -1, -1,  5, -1, -1, -1, -1, -1}, //  5 - dependent vowels
      {-1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  6 - vowel mark
      {-1, -1, -1, -1, -1, -1,  3,  2, -1, -1, -1, -1, -1, -1, -1}, //  7 - consonant virama ZWJ, consonant ZWJ virama
      {-1,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  4, -1}, //  8 - independent vowels that can take a virama
***************
*** 629,634 ****
--- 651,670 ----
                  output.writeChar(chars[i], i, tagArray4);
              }
  
+             /* for the special conjuction of Cons+0x0d4d+0x0d31 or Cons+0x0d4d+0x0d30 of Malayalam */
+             if ((baseConsonant - 2 >= 0) &&
+                 (chars[baseConsonant - 1] == 0x0d4d) &&
+ 		((chars[baseConsonant] == 0x0d31) || 
+ 		 (chars[baseConsonant] == 0x0d30)) &&
+                 ((chars[baseConsonant - 2] >= 0x0d15) &&
+                  (chars[baseConsonant - 2] <= 0x0d39)))  {
+ 
+                 output.swapChars(-1, -3);
+ 
+ 		if (mpreFixups)
+ 			mpreFixups->reduce();
+             }
+ 
              if ((classTable->scriptFlags & SF_MATRAS_AFTER_BASE) != 0) {
                  output.writeMbelow();
                  output.writeSMbelow(); // FIXME: there are no SMs in these scripts...
*** misc/icu/source/layout/LESwaps.h	Thu Jun 23 00:39:36 2005
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/LESwaps.h	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/LESwaps.h	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 2,7 ****
--- 2,8 ----
  /*
   *
   * (C) Copyright IBM Corp. 1998-2005 - All Rights Reserved
+  * with additions by Sun Microsystems 2002-2006
   *
   */
  
***************
*** 17,28 ****
  
  U_NAMESPACE_BEGIN
  
  /**
!  * A convenience macro which invokes the swapWord member function
   * from a concise call.
   *
   * @stable ICU 2.8
   */
  #if defined(U_IS_BIG_ENDIAN)
      #if U_IS_BIG_ENDIAN
          #define SWAPW(value) (value)
--- 18,38 ----
  
  U_NAMESPACE_BEGIN
  
+ // There exist popular font files which contain unaligned tables
+ // (e.g. "Watanabe Gothic"'s "mort" table)
+ // On some platforms unaligned memory accesses cause a crash.
+ // The ALLOW_UNALIGNED hack prevents these crashes by assuming that
+ // every use of the SWAPx macros in ICU's layout engine is intended
+ // for loading a big endian value and replaces them appropriately.
+ #define ALLOW_UNALIGNED_HACK
+ 
  /**
!  * A convenience macro which invokes the swapLong member function
   * from a concise call.
   *
   * @stable ICU 2.8
   */
+ #ifndef ALLOW_UNALIGNED_HACK
  #if defined(U_IS_BIG_ENDIAN)
      #if U_IS_BIG_ENDIAN
          #define SWAPW(value) (value)
***************
*** 49,54 ****
--- 59,83 ----
      #define SWAPL(value) (LESwaps::isBigEndian() ? (value) : LESwaps::swapLong(value))
  #endif
  
+ #else // ALLOW_UNALIGNED_HACK
+ 
+ #define SWAPW(rValue) loadBigEndianWord(reinterpret_cast<const le_uint16&>(rValue))
+ #define SWAPL(rValue) loadBigEndianLong(reinterpret_cast<const le_uint32&>(rValue))
+ 
+ inline le_uint16 loadBigEndianWord( const le_uint16& rValue )
+ {
+     const le_uint8* p = reinterpret_cast<const le_uint8*>(&rValue);
+     return ((p[0] << 8) + p[1]);
+ }
+ 
+ inline le_uint32 loadBigEndianLong( const le_uint32& rValue )
+ {
+     const le_uint8* p = reinterpret_cast<const le_uint8*>(&rValue);
+     return ((p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]);
+ }
+ 
+ #endif // ALLOW_UNALIGNED_HACK
+ 
  /**
   * This class is used to access data which stored in big endian order
   * regardless of the conventions of the platform. It has been designed
*** misc/icu/source/layout/MPreFixups.cpp	Sat May  8 01:28:44 2004
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/MPreFixups.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/MPreFixups.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 40,45 ****
--- 40,51 ----
      }
  }
  
+ void MPreFixups::reduce()
+ {
+     if (fFixupCount > 0)
+         fFixupCount--;
+ }
+ 
  void MPreFixups::apply(LEGlyphStorage &glyphStorage)
  {
      for (le_int32 fixup = 0; fixup < fFixupCount; fixup += 1) {
*** misc/icu/source/layout/MPreFixups.h	Mon Apr 12 20:51:32 2004
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/layout/MPreFixups.h	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/layout/MPreFixups.h	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 31,36 ****
--- 31,38 ----
      
      void apply(LEGlyphStorage &glyphStorage);
  
+     void reduce();
+ 
  private:
      FixupData *fFixupData;
      le_int32   fFixupCount;
*** misc/icu/source/stubdata/Makefile.in	Fri Dec  2 11:21:34 2005
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/stubdata/Makefile.in	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/stubdata/Makefile.in	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 25,30 ****
--- 25,36 ----
  ## Target information
  
  TARGET_STUBNAME=$(DATA_STUBNAME)
+ ifeq (@platform_make_fragment_name@,mh-mingw)
+ FINAL_SO_TARGET=$(STUBDATA_LIBDIR)$(LIBICU)$(TARGET_STUBNAME)$(ICULIBSUFFIX)$(SO_TARGET_VERSION_MAJOR)$(STUB_SUFFIX).$(SO)
+ %$(STUB_SUFFIX).$(SO): %$(SO_TARGET_VERSION_MAJOR)$(STUB_SUFFIX).$(SO)
+ 	$(RM) $@ && ln $< $@
+ 
+ endif
  
  ifneq ($(ENABLE_STATIC),)
  TARGET = $(STUBDATA_LIBDIR)$(LIBSICU)$(TARGET_STUBNAME)$(ICULIBSUFFIX).$(A)
*** misc/icu/source/test/intltest/loctest.cpp	Thu Jul  6 03:50:04 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/test/intltest/loctest.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/test/intltest/loctest.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "loctest.h"
  #include "unicode/decimfmt.h"
  #include "unicode/ucurr.h"
*** misc/icu/source/test/intltest/regextst.cpp	Tue Jul  5 20:39:00 2005
--- misc/build/icu/source/test/intltest/regextst.cpp	Mon Jan 28 23:18:47 2008
***************
*** 1,6 ****
  /********************************************************************
   * COPYRIGHT:
!  * Copyright (c) 2002-2005, International Business Machines Corporation and
   * others. All Rights Reserved.
   ********************************************************************/
  
--- 1,6 ----
  /********************************************************************
   * COPYRIGHT:
!  * Copyright (c) 2002-2008, International Business Machines Corporation and
   * others. All Rights Reserved.
   ********************************************************************/
  
***************
*** 66,71 ****
--- 66,75 ----
          case 6: name = "PerlTests";
              if (exec) PerlTests();
              break;
+         case 7: name = "Bug 6149";
+             if (exec) Bug6149();
+             break;
+             
  
  
          default: name = "";
***************
*** 1639,1644 ****
--- 1643,1661 ----
  
  }
  
+     
+     // Invalid Back Reference \0
+     //    For ICU 3.8 and earlier
+     //    For ICU versions newer than 3.8, \0 introduces an octal escape.
+     //
+ #ifndef _MSC_VER
+ // erAck: 2008-01-28T23:16+0100 MSVC doesn't digest the escaped backslash and
+ // mumbles something about  
+ // error C2501: 'regex_err' : missing storage-class or type specifiers
+ // error C2078: too many initializers
+ // We're not interested in fixing that deficiency just for a testcase.
+     REGEX_ERR("(ab)\\0", 1, 6, U_REGEX_INVALID_BACK_REF);
+ #endif
  
  //-------------------------------------------------------------------------------
  //
***************
*** 2119,2124 ****
--- 2136,2161 ----
  }
  
  
+ //--------------------------------------------------------------
+ //
+ //  Bug6149   Verify limits to heap expansion for backtrack stack.
+ //             Use this pattern,
+ //                 "(a?){1,}"
+ //             The zero-length match will repeat forever.
+ //                (That this goes into a loop is another bug)
+ //
+ //---------------------------------------------------------------
+ void RegexTest::Bug6149() {
+     UnicodeString pattern("(a?){1,}");
+     UnicodeString s("xyz");
+     uint32_t flags = 0;
+     UErrorCode status = U_ZERO_ERROR;
+     
+     RegexMatcher  matcher(pattern, s, flags, status);
+     UBool result = false;
+     REGEX_ASSERT_FAIL(result=matcher.matches(status), U_BUFFER_OVERFLOW_ERROR);
+     REGEX_ASSERT(result == FALSE);
+  }
  
  #endif  /* !UCONFIG_NO_REGULAR_EXPRESSIONS  */
  
*** misc/icu/source/test/intltest/regextst.h	Wed Dec  3 07:58:28 2003
--- misc/build/icu/source/test/intltest/regextst.h	Mon Jan 28 21:31:51 2008
***************
*** 1,6 ****
  /********************************************************************
   * COPYRIGHT: 
!  * Copyright (c) 2002-2003, International Business Machines Corporation and
   * others. All Rights Reserved.
   ********************************************************************/
  
--- 1,6 ----
  /********************************************************************
   * COPYRIGHT: 
!  * Copyright (c) 2002-2008, International Business Machines Corporation and
   * others. All Rights Reserved.
   ********************************************************************/
  
***************
*** 30,35 ****
--- 30,36 ----
      virtual void Extended();
      virtual void Errors();
      virtual void PerlTests();
+     virtual void Bug6149();
  
      // The following functions are internal to the regexp tests.
      virtual UBool doRegexLMTest(const char *pat, const char *text, UBool looking, UBool match, int line);
*** misc/icu/source/test/intltest/tsputil.cpp	Wed Jul 19 00:18:10 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/test/intltest/tsputil.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/test/intltest/tsputil.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "tsputil.h"
  
  #include <float.h> // DBL_MAX, DBL_MIN
*** misc/icu/source/test/intltest/uobjtest.cpp	Thu Mar 23 01:54:12 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/test/intltest/uobjtest.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/test/intltest/uobjtest.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "uobjtest.h"
  #include "cmemory.h" // UAlignedMemory
  #include <string.h>
*** misc/icu/source/test/intltest/ustrtest.cpp	Tue Dec 28 22:13:54 2004
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/test/intltest/ustrtest.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/test/intltest/ustrtest.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 4,9 ****
--- 4,10 ----
   * others. All Rights Reserved.
   ********************************************************************/
  
+ #include "unicode/utypes.h"
  #include "ustrtest.h"
  #include "unicode/unistr.h"
  #include "unicode/uchar.h"
*** misc/icu/source/tools/icupkg/icupkg.cpp	Fri Jul 21 23:17:52 2006
<<<<<<< icu-3.6.patch
--- misc/build/icu/source/tools/icupkg/icupkg.cpp	Tue Nov 13 13:03:52 2007
=======
--- misc/build/icu/source/tools/icupkg/icupkg.cpp	Mon Jan 28 21:31:51 2008
>>>>>>> 1.10.12.2
***************
*** 332,337 ****
--- 332,341 ----
      return (UBool)(len>0 && 0==strcmp(filename+len, ".dat"));
  }
  
+ #ifdef __MINGW32__
+ int _CRT_glob=0;
+ #endif
+ 
  extern int
  main(int argc, char *argv[]) {
      const char *pname, *sourcePath, *destPath, *inFilename, *outFilename, *outComment;
*** misc/icu/source/tools/pkgdata/make.c	Wed Mar 22 09:14:10 2006
--- misc/build/icu/source/tools/pkgdata/make.c	Tue Nov 13 13:03:52 2007
***************
*** 172,178 ****
--- 172,180 ----
                      "MODE=%s\n"
                      "MAKEFILE=%s\n"
                      "ENTRYPOINT=%s\n"
+ #ifndef __MINGW32__
                      "include %s\n"
+ #endif
                      "\n\n\n",
                      o->shortName,
                      o->libName,
***************
*** 182,189 ****
--- 184,195 ----
                      o->srcDir,
                      o->mode,
                      o->makeFile,
+ #ifdef __MINGW32__
+                     o->entryName);
+ #else
                      o->entryName,
                      o->options);
+ #endif
      T_FileStream_writeLine(f, linebuf);
      
      /* TEMP_PATH  and TARG_PATH will be empty if the respective dir is . */
***************
*** 233,238 ****
--- 239,252 ----
  
      pkg_writeCharListWrap(f, o->filePaths, " ", " \\\n",0);
  
+ #ifdef __MINGW32__
+     sprintf(linebuf, "\n"
+                     "include %s\n"
+                     "\n\n\n",
+                     o->options);
+     T_FileStream_writeLine(f, linebuf);
+ #endif
+     
      T_FileStream_writeLine(f, "\n\n\n");
  
  }
***************
*** 396,402 ****
--- 410,420 ----
      T_FileStream_writeLine(f, "BASE_OBJECTS=$(NAME)_dat.o\n");
      T_FileStream_writeLine(f, "\n");
      T_FileStream_writeLine(f, "$(TEMP_DIR)/$(NAME).dat: $(CMNLIST) $(DATAFILEPATHS)\n");
+ #ifdef __MINGW32__
+     T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCMN) -c -e $(ENTRYPOINT) -n $(NAME) -s $(SRCDIRW) -t dat -d $(TEMP_DIR) 0 $(CMNLIST)\n");
+ #else
      T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCMN) -c -e $(ENTRYPOINT) -n $(NAME) -s $(SRCDIR) -t dat -d $(TEMP_DIR) 0 $(CMNLIST)\n");
+ #endif
      T_FileStream_writeLine(f, "\n");
      T_FileStream_writeLine(f, "$(TEMP_DIR)/$(NAME)_dat.o : $(TEMP_DIR)/$(NAME).dat\n");
      T_FileStream_writeLine(f, "\t$(INVOKE) $(GENCCODE) $(GENCCODE_ASSEMBLY) -n $(NAME) -e $(ENTRYPOINT) -d $(TEMP_DIR) $<\n");
